# Holiday Booking Saga — ID and Context Flow Analysis

> **Purpose**: Model how IDs, correlation, and saga context flow through a real-world saga  
> **Example**: Book a holiday (hotel + taxi + flight) with all-or-nothing semantics

---

## The Problem

A user wants to book a holiday package:

1. Reserve a **hotel** room
2. Reserve a **taxi** transfer  
3. Reserve a **flight**

If any reservation fails, all successful reservations must be cancelled.

**Key Questions**:

- How do IDs flow from saga to external systems and back?
- How does the saga know which external booking IDs to cancel?
- How does context (correlation ID, saga ID, user ID) propagate?

---

## Two Architectural Options

| Aspect | Option A: Saga Calls HTTP | Option B: Saga Calls Aggregates |
|--------|---------------------------|----------------------------------|
| HTTP calls | Saga steps call APIs directly | Aggregate effects call APIs |
| State ownership | Saga owns all booking IDs | Each aggregate owns its booking ID |
| Compensation | Saga cancels via HTTP | Aggregates cancel via their effects |
| Complexity | Simpler, saga is the orchestrator | More distributed, better separation |
| Reusability | Booking logic tied to saga | Aggregates reusable across sagas |

---

## Option A: Saga Directly Calls HTTP APIs

### Architecture

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    HolidayBookingSaga                               │
│                                                                     │
│  State:                                                             │
│    - BookingId (saga identity)                                      │
│    - UserId                                                         │
│    - HotelConfirmationId?                                           │
│    - TaxiConfirmationId?                                            │
│    - FlightConfirmationId?                                          │
│                                                                     │
│  Steps:                                                             │
│    1. ReserveHotelStep ──► HTTP POST /hotels/reserve                │
│    2. ReserveTaxiStep  ──► HTTP POST /taxis/reserve                 │
│    3. ReserveFlightStep ──► HTTP POST /flights/reserve              │
│                                                                     │
│  On failure: Compensate in reverse order via HTTP DELETE            │
└─────────────────────────────────────────────────────────────────────┘
```

### Saga State

```csharp
[SagaOptions(CompensationStrategy = CompensationStrategy.Immediate)]
[BrookName("holiday-booking-saga")]
public sealed record HolidayBookingSagaState
{
    // Saga identity
    public string BookingId { get; init; } = "";
    
    // Context passed from initiator
    public string UserId { get; init; } = "";
    public string CorrelationId { get; init; } = "";
    
    // Booking request details
    public HotelRequest HotelRequest { get; init; } = new();
    public TaxiRequest TaxiRequest { get; init; } = new();
    public FlightRequest FlightRequest { get; init; } = new();
    
    // External system confirmation IDs (populated by step success events)
    public string? HotelConfirmationId { get; init; }
    public string? TaxiConfirmationId { get; init; }
    public string? FlightConfirmationId { get; init; }
    
    // Track what's been reserved (for compensation decisions)
    public bool HotelReserved { get; init; }
    public bool TaxiReserved { get; init; }
    public bool FlightReserved { get; init; }
}

public sealed record HotelRequest(string HotelId, DateOnly CheckIn, DateOnly CheckOut, int Guests);
public sealed record TaxiRequest(string PickupLocation, string DropoffLocation, DateTimeOffset PickupTime);
public sealed record FlightRequest(string FlightNumber, DateOnly Date, int Passengers);
```

### Starting the Saga — ID Flow

```csharp
// Client/API initiates the saga
public sealed record StartHolidayBookingCommand(
    string BookingId,           // Generated by caller or API
    string UserId,
    string CorrelationId,       // For distributed tracing
    HotelRequest Hotel,
    TaxiRequest Taxi,
    FlightRequest Flight);

// Command handler creates initial state
public sealed class StartHolidayBookingHandler 
    : CommandHandlerBase<StartHolidayBookingCommand, HolidayBookingSagaState>
{
    protected override OperationResult<IReadOnlyList<object>> HandleCore(
        StartHolidayBookingCommand command,
        HolidayBookingSagaState? state)
    {
        if (state is not null)
            return OperationResult.Fail("ALREADY_STARTED", "Booking already exists");
        
        return OperationResult.Ok<IReadOnlyList<object>>([
            new HolidayBookingStartedEvent(
                command.BookingId,
                command.UserId,
                command.CorrelationId,
                command.Hotel,
                command.Taxi,
                command.Flight,
                DateTimeOffset.UtcNow)
        ]);
    }
}
```

### Step Implementation — HTTP with Context

```csharp
[SagaStep(Order = 1)]
public sealed class ReserveHotelStep : HttpServiceStep<HolidayBookingSagaState>
{
    public ReserveHotelStep(IHttpClientFactory httpClientFactory) 
        : base(httpClientFactory.CreateClient("HotelApi")) { }
    
    public override string StepName => "reserve-hotel";
    
    public override bool ShouldExecute(HolidayBookingSagaState state) 
        => !state.HotelReserved;
    
    protected override HttpRequestMessage BuildRequest(HolidayBookingSagaState state)
    {
        var request = new HttpRequestMessage(HttpMethod.Post, "/api/hotels/reserve")
        {
            Content = JsonContent.Create(new
            {
                hotelId = state.HotelRequest.HotelId,
                checkIn = state.HotelRequest.CheckIn,
                checkOut = state.HotelRequest.CheckOut,
                guests = state.HotelRequest.Guests,
                
                // Pass saga context for external system's tracing/idempotency
                externalBookingRef = state.BookingId,
                correlationId = state.CorrelationId
            })
        };
        
        // Add correlation headers for distributed tracing
        request.Headers.Add("X-Correlation-Id", state.CorrelationId);
        request.Headers.Add("X-Saga-Id", state.BookingId);
        
        return request;
    }
    
    protected override async Task<IEnumerable<object>> BuildSuccessEventsAsync(
        HolidayBookingSagaState state, 
        HttpResponseMessage response)
    {
        // Parse the external system's confirmation ID
        var result = await response.Content.ReadFromJsonAsync<HotelReservationResponse>();
        
        yield return new HotelReservedEvent(
            state.BookingId,
            result!.ConfirmationId,  // External system's ID
            DateTimeOffset.UtcNow);
    }
    
    public override async Task<StepExecutionResult> CompensateAsync(
        HolidayBookingSagaState state,
        ISagaContext context,
        CancellationToken ct)
    {
        if (!state.HotelReserved || state.HotelConfirmationId is null)
            return StepExecutionResult.Succeeded();
        
        // Cancel using the external confirmation ID
        var request = new HttpRequestMessage(
            HttpMethod.Delete, 
            $"/api/hotels/reservations/{state.HotelConfirmationId}")
        {
            Headers = 
            {
                { "X-Correlation-Id", state.CorrelationId },
                { "X-Saga-Id", state.BookingId }
            }
        };
        
        var response = await Http.SendAsync(request, ct);
        
        if (!response.IsSuccessStatusCode)
            return StepExecutionResult.Failed("CANCEL_FAILED", await response.Content.ReadAsStringAsync(ct));
        
        return StepExecutionResult.Succeeded(new HotelReservationCancelledEvent(
            state.BookingId,
            state.HotelConfirmationId,
            DateTimeOffset.UtcNow));
    }
}

// Response from external hotel API
public sealed record HotelReservationResponse(string ConfirmationId, string Status);
```

### Events Capture External IDs

```csharp
// Event stores the external confirmation ID
public sealed record HotelReservedEvent(
    string BookingId,
    string HotelConfirmationId,  // From external API
    DateTimeOffset Timestamp);

// Reducer updates saga state with the external ID
public sealed class HotelReservedReducer : ReducerBase<HotelReservedEvent, HolidayBookingSagaState>
{
    protected override HolidayBookingSagaState ReduceCore(
        HotelReservedEvent @event, 
        HolidayBookingSagaState state) 
        => state with 
        { 
            HotelReserved = true, 
            HotelConfirmationId = @event.HotelConfirmationId 
        };
}
```

### Verification — Check External State

```csharp
[SagaStep(Order = 1)]
public sealed class ReserveHotelStep : HttpServiceStep<HolidayBookingSagaState>
{
    // ... Execute as above ...
    
    public override async Task<StepVerificationResult> VerifyAsync(
        HolidayBookingSagaState state,
        ISagaContext context,
        CancellationToken ct)
    {
        // Some external APIs are async — verify the reservation is confirmed
        var response = await Http.GetAsync(
            $"/api/hotels/reservations/{state.HotelConfirmationId}/status", ct);
        
        if (!response.IsSuccessStatusCode)
            return StepVerificationResult.NotYet(TimeSpan.FromSeconds(2));
        
        var status = await response.Content.ReadFromJsonAsync<ReservationStatus>(ct);
        
        return status?.State switch
        {
            "confirmed" => StepVerificationResult.Verified(),
            "pending" => StepVerificationResult.NotYet(TimeSpan.FromSeconds(5)),
            "failed" => StepVerificationResult.Failed("External reservation failed"),
            _ => StepVerificationResult.NotYet(TimeSpan.FromSeconds(2))
        };
    }
}
```

### Complete Flow Diagram

```text
┌──────────┐     ┌─────────────────────────────────────────────────────────┐
│  Client  │     │              HolidayBookingSaga                         │
└────┬─────┘     └─────────────────────────────────────────────────────────┘
     │                                    │
     │ StartHolidayBookingCommand         │
     │ (BookingId, UserId, CorrelationId) │
     │ ──────────────────────────────────►│
     │                                    │
     │                                    │ ──► HolidayBookingStartedEvent
     │                                    │     (stores all IDs in state)
     │                                    │
     │                    ┌───────────────┴───────────────┐
     │                    │      ReserveHotelStep         │
     │                    │  POST /hotels/reserve         │
     │                    │  Body: { externalBookingRef,  │
     │                    │          correlationId, ... } │
     │                    └───────────────┬───────────────┘
     │                                    │
     │                                    ▼
     │                    ┌───────────────────────────────┐
     │                    │       Hotel API Response      │
     │                    │  { confirmationId: "HTL123" } │
     │                    └───────────────┬───────────────┘
     │                                    │
     │                                    │ ──► HotelReservedEvent
     │                                    │     (HotelConfirmationId = "HTL123")
     │                                    │
     │                                    │ ──► VerifyAsync polls status
     │                                    │
     │                    ┌───────────────┴───────────────┐
     │                    │      ReserveTaxiStep          │
     │                    │  (same pattern)               │
     │                    └───────────────┬───────────────┘
     │                                    │
     │                                    │ ──► TaxiReservedEvent
     │                                    │     (TaxiConfirmationId = "TAX456")
     │                                    │
     │                    ┌───────────────┴───────────────┐
     │                    │      ReserveFlightStep        │
     │                    │  (same pattern)               │
     │                    └───────────────┬───────────────┘
     │                                    │
     │                                    │ ──► FlightReservedEvent
     │                                    │     (FlightConfirmationId = "FLT789")
     │                                    │
     │                                    │ ──► HolidayBookingCompletedEvent
     │                                    │
     ◄────────────────────────────────────┤
     │  Subscribe to SagaStatusProjection │
     │  or HolidayBookingProjection       │
```

---

## Option B: Saga Calls Aggregates (Aggregates Use Effects)

### Architecture

```text
┌─────────────────────────────────────────────────────────────────────┐
│                    HolidayBookingSaga                               │
│                                                                     │
│  Steps:                                                             │
│    1. ReserveHotelStep ──► HotelReservationAggregate.Reserve()     │
│    2. ReserveTaxiStep  ──► TaxiReservationAggregate.Reserve()      │
│    3. ReserveFlightStep ──► FlightReservationAggregate.Reserve()   │
│                                                                     │
└───────────────────────────────┬─────────────────────────────────────┘
                                │
        ┌───────────────────────┼───────────────────────┐
        ▼                       ▼                       ▼
┌───────────────────┐   ┌───────────────────┐   ┌───────────────────┐
│ HotelReservation  │   │ TaxiReservation   │   │ FlightReservation │
│    Aggregate      │   │    Aggregate      │   │    Aggregate      │
│                   │   │                   │   │                   │
│ Command Handler   │   │ Command Handler   │   │ Command Handler   │
│    ↓              │   │    ↓              │   │    ↓              │
│ Events            │   │ Events            │   │ Events            │
│    ↓              │   │    ↓              │   │    ↓              │
│ Server Effect     │   │ Server Effect     │   │ Server Effect     │
│    ↓              │   │    ↓              │   │    ↓              │
│ HTTP POST         │   │ HTTP POST         │   │ HTTP POST         │
│ to Hotel API      │   │ to Taxi API       │   │ to Flight API     │
└───────────────────┘   └───────────────────┘   └───────────────────┘
```

### Why This Pattern?

1. **Aggregates are reusable** — `HotelReservationAggregate` can be used by other sagas or directly
2. **Each aggregate owns its domain** — Hotel booking logic lives with hotel aggregate
3. **Effects are encapsulated** — HTTP call logic is in the aggregate, not the saga
4. **Better separation** — Saga only knows about aggregate commands, not HTTP

### Domain Aggregates with Server Effects

```csharp
// ============================================
// HOTEL RESERVATION AGGREGATE
// ============================================

[BrookName("hotel-reservation")]
public sealed record HotelReservationState
{
    public string ReservationId { get; init; } = "";
    public string HotelId { get; init; } = "";
    public string? ExternalConfirmationId { get; init; }
    public ReservationStatus Status { get; init; } = ReservationStatus.Pending;
    
    // Context for tracing
    public string? SagaId { get; init; }
    public string? CorrelationId { get; init; }
}

public enum ReservationStatus { Pending, Reserving, Confirmed, Cancelled, Failed }

// Command includes saga context
public sealed record ReserveHotelCommand(
    string ReservationId,
    string HotelId,
    DateOnly CheckIn,
    DateOnly CheckOut,
    int Guests,
    // Saga context passed through
    string? SagaId = null,
    string? CorrelationId = null);

// Command handler emits event, effect does HTTP
public sealed class ReserveHotelHandler 
    : CommandHandlerBase<ReserveHotelCommand, HotelReservationState>
{
    protected override OperationResult<IReadOnlyList<object>> HandleCore(
        ReserveHotelCommand command,
        HotelReservationState? state)
    {
        if (state?.Status == ReservationStatus.Confirmed)
            return OperationResult.Fail("ALREADY_RESERVED", "Already confirmed");
        
        // Emit event; server effect will call HTTP
        return OperationResult.Ok<IReadOnlyList<object>>([
            new HotelReservationRequestedEvent(
                command.ReservationId,
                command.HotelId,
                command.CheckIn,
                command.CheckOut,
                command.Guests,
                command.SagaId,
                command.CorrelationId,
                DateTimeOffset.UtcNow)
        ]);
    }
}

// SERVER-SIDE EFFECT — calls HTTP after event is persisted
public sealed class HotelReservationHttpEffect 
    : EventEffectBase<HotelReservationRequestedEvent, HotelReservationState>
{
    private HttpClient Http { get; }
    private IAggregateGrainFactory GrainFactory { get; }
    
    public HotelReservationHttpEffect(
        IHttpClientFactory httpFactory,
        IAggregateGrainFactory grainFactory)
    {
        Http = httpFactory.CreateClient("HotelApi");
        GrainFactory = grainFactory;
    }
    
    public override async IAsyncEnumerable<object> HandleAsync(
        HotelReservationRequestedEvent @event,
        HotelReservationState state,
        [EnumeratorCancellation] CancellationToken ct)
    {
        try
        {
            var request = new HttpRequestMessage(HttpMethod.Post, "/api/hotels/reserve")
            {
                Content = JsonContent.Create(new
                {
                    hotelId = @event.HotelId,
                    checkIn = @event.CheckIn,
                    checkOut = @event.CheckOut,
                    guests = @event.Guests,
                    externalBookingRef = @event.ReservationId
                })
            };
            
            // Add tracing headers from aggregate state (passed via command properties)
            if (state.CorrelationId is not null)
                request.Headers.Add("X-Correlation-Id", state.CorrelationId);
            if (state.SagaId is not null)
                request.Headers.Add("X-Saga-Id", state.SagaId);
            
            var response = await Http.SendAsync(request, ct);
            
            if (response.IsSuccessStatusCode)
            {
                var result = await response.Content.ReadFromJsonAsync<HotelApiResponse>(ct);
                
                // Dispatch success command back to this aggregate
                await GrainFactory
                    .GetGenericAggregate<HotelReservationState>(state.ReservationId)
                    .ExecuteAsync(new HotelReservationConfirmedCommand(
                        state.ReservationId,
                        result!.ConfirmationId), ct);
            }
            else
            {
                // Dispatch failure command
                await GrainFactory
                    .GetGenericAggregate<HotelReservationState>(state.ReservationId)
                    .ExecuteAsync(new HotelReservationFailedCommand(
                        state.ReservationId,
                        response.StatusCode.ToString(),
                        await response.Content.ReadAsStringAsync(ct)), ct);
            }
        }
        catch (Exception ex)
        {
            await GrainFactory
                .GetGenericAggregate<HotelReservationState>(state.ReservationId)
                .ExecuteAsync(new HotelReservationFailedCommand(
                    state.ReservationId,
                    "HTTP_ERROR",
                    ex.Message), ct);
        }
        
        yield break; // Command dispatch handles state update, no events to yield here
    }
}
```

### Saga Step — Calls Aggregate, Verifies Aggregate State

```csharp
[SagaStep(Order = 1)]
public sealed class ReserveHotelStep 
    : AggregateCommandStep<HolidayBookingSagaState, HotelReservationState>
{
    public ReserveHotelStep(IAggregateGrainFactory factory) : base(factory) { }
    
    public override string StepName => "reserve-hotel";
    
    public override bool ShouldExecute(HolidayBookingSagaState state) 
        => state.HotelReservationId is null || !state.HotelConfirmed;
    
    protected override string GetTargetEntityId(HolidayBookingSagaState state)
    {
        // Generate or use existing reservation ID
        // Stored in saga state for idempotency
        return state.HotelReservationId ?? $"{state.BookingId}-hotel";
    }
    
    protected override object BuildCommand(HolidayBookingSagaState state)
        => new ReserveHotelCommand(
            GetTargetEntityId(state),
            state.HotelRequest.HotelId,
            state.HotelRequest.CheckIn,
            state.HotelRequest.CheckOut,
            state.HotelRequest.Guests,
            // Pass saga context through to aggregate
            SagaId: state.BookingId,
            CorrelationId: state.CorrelationId);
    
    protected override IEnumerable<object> BuildSuccessEvents(HolidayBookingSagaState state)
    {
        // Record that we initiated the reservation
        yield return new HotelReservationInitiatedEvent(
            state.BookingId,
            GetTargetEntityId(state),
            DateTimeOffset.UtcNow);
    }
    
    public override async Task<StepVerificationResult> VerifyAsync(
        HolidayBookingSagaState state,
        ISagaContext context,
        CancellationToken ct)
    {
        // Poll the hotel reservation aggregate's state
        var hotelState = await AggregateFactory
            .GetGenericAggregate<HotelReservationState>(state.HotelReservationId!)
            .GetStateAsync(ct);
        
        return hotelState?.Status switch
        {
            ReservationStatus.Confirmed => StepVerificationResult.Verified(),
            ReservationStatus.Failed => StepVerificationResult.Failed(
                $"Hotel reservation failed: {hotelState.FailureReason}"),
            ReservationStatus.Pending or ReservationStatus.Reserving 
                => StepVerificationResult.NotYet(TimeSpan.FromSeconds(2)),
            _ => StepVerificationResult.NotYet(TimeSpan.FromSeconds(2))
        };
    }
    
    public override async Task<StepExecutionResult> CompensateAsync(
        HolidayBookingSagaState state,
        ISagaContext context,
        CancellationToken ct)
    {
        if (state.HotelReservationId is null)
            return StepExecutionResult.Succeeded();
        
        // Tell the hotel aggregate to cancel
        await AggregateFactory
            .GetGenericAggregate<HotelReservationState>(state.HotelReservationId)
            .ExecuteAsync(new CancelHotelReservationCommand(
                state.HotelReservationId,
                "Saga compensation"), ct);
        
        return StepExecutionResult.Succeeded(
            new HotelReservationCancelledEvent(state.BookingId, state.HotelReservationId));
    }
}
```

### Saga State — References to Child Aggregates

```csharp
[SagaOptions(CompensationStrategy = CompensationStrategy.Immediate)]
[BrookName("holiday-booking-saga")]
public sealed record HolidayBookingSagaState
{
    // Saga identity
    public string BookingId { get; init; } = "";
    public string UserId { get; init; } = "";
    public string CorrelationId { get; init; } = "";
    
    // Request details
    public HotelRequest HotelRequest { get; init; } = new();
    public TaxiRequest TaxiRequest { get; init; } = new();
    public FlightRequest FlightRequest { get; init; } = new();
    
    // References to child aggregates (NOT external IDs)
    public string? HotelReservationId { get; init; }
    public string? TaxiReservationId { get; init; }
    public string? FlightReservationId { get; init; }
    
    // Confirmation status (verified from child aggregates)
    public bool HotelConfirmed { get; init; }
    public bool TaxiConfirmed { get; init; }
    public bool FlightConfirmed { get; init; }
}
```

### Complete Flow Diagram (Option B)

```text
┌──────────┐     ┌─────────────────────────────────────────────────────────┐
│  Client  │     │              HolidayBookingSaga                         │
└────┬─────┘     └─────────────────────────────────────────────────────────┘
     │                                    │
     │ StartHolidayBookingCommand         │
     │ (BookingId, UserId, CorrelationId) │
     │ ──────────────────────────────────►│
     │                                    │
     │                                    │ ──► HolidayBookingStartedEvent
     │                                    │
     │                    ┌───────────────┴───────────────┐
     │                    │      ReserveHotelStep         │
     │                    │                               │
     │                    │  1. BuildCommand() creates:   │
     │                    │     ReserveHotelCommand       │
     │                    │       - ReservationId         │
     │                    │       - SagaId (for tracing)  │
     │                    │       - CorrelationId         │
     │                    │                               │
     │                    │  2. Dispatch to Aggregate     │
     │                    └───────────────┬───────────────┘
     │                                    │
     │                                    ▼
     │                    ┌───────────────────────────────┐
     │                    │   HotelReservationAggregate   │
     │                    │                               │
     │                    │  CommandHandler emits:        │
     │                    │    HotelReservationRequested  │
     │                    │                               │
     │                    │  Effect runs (async):         │
     │                    │    POST /hotels/reserve       │
     │                    │    Headers:                   │
     │                    │      X-Saga-Id: {sagaId}      │
     │                    │      X-Correlation-Id: {...}  │
     │                    │                               │
     │                    │  On response, dispatch:       │
     │                    │    HotelReservationConfirmed  │
     │                    │      - ExternalConfirmationId │
     │                    └───────────────┬───────────────┘
     │                                    │
     │                    ┌───────────────┴───────────────┐
     │                    │      Saga VerifyAsync()       │
     │                    │                               │
     │                    │  Poll: GetStateAsync() on     │
     │                    │        HotelReservationAgg    │
     │                    │                               │
     │                    │  Check: Status == Confirmed?  │
     │                    │    Yes → StepVerified         │
     │                    │    No  → NotYet (retry)       │
     │                    └───────────────┬───────────────┘
     │                                    │
     │                                    │ ──► HotelReservationVerifiedEvent
     │                                    │
     │                    ┌───────────────┴───────────────┐
     │                    │      ReserveTaxiStep          │
     │                    │  (same pattern)               │
     │                    └───────────────┬───────────────┘
     │                                    │
     │                    ... etc ...     │
```

---

## ID Flow Comparison

### Option A: Saga Owns Everything

```text
BookingId (saga key)
    │
    ├──► HotelConfirmationId (from external API)
    ├──► TaxiConfirmationId (from external API)
    └──► FlightConfirmationId (from external API)

Context headers on every HTTP call:
    X-Saga-Id: {BookingId}
    X-Correlation-Id: {CorrelationId}
```

### Option B: Saga References Aggregates

```text
BookingId (saga key)
    │
    ├──► HotelReservationId ──► HotelReservationAggregate
    │                              └──► ExternalConfirmationId
    │
    ├──► TaxiReservationId ──► TaxiReservationAggregate
    │                              └──► ExternalConfirmationId
    │
    └──► FlightReservationId ──► FlightReservationAggregate
                                   └──► ExternalConfirmationId

Context passed through command properties:
    ReserveHotelCommand { SagaId, CorrelationId }
    
Context headers added by aggregate effect:
    X-Saga-Id: {from command}
    X-Correlation-Id: {from command}
```

---

## Context Interface Design

### ISagaContext — Available to Steps

```csharp
public interface ISagaContext
{
    /// <summary>
    ///     The saga's entity ID.
    /// </summary>
    string SagaId { get; }
    
    /// <summary>
    ///     Correlation ID for distributed tracing.
    /// </summary>
    string? CorrelationId { get; }
    
    /// <summary>
    ///     Dispatch command to another aggregate.
    /// </summary>
    Task<OperationResult> DispatchAsync<TAggregate>(
        string entityId,
        object command,
        CancellationToken cancellationToken = default)
        where TAggregate : class;
    
    /// <summary>
    ///     Get projection state for verification.
    /// </summary>
    Task<TProjection?> GetProjectionAsync<TProjection>(
        string entityId,
        CancellationToken cancellationToken = default)
        where TProjection : class;
    
    /// <summary>
    ///     Set reminder for timeout/retry.
    /// </summary>
    Task SetReminderAsync(
        string reminderName,
        TimeSpan dueTime,
        TimeSpan? period = null);
    
    /// <summary>
    ///     Clear a reminder.
    /// </summary>
    Task ClearReminderAsync(string reminderName);
}
```

### IAggregateEffectContext — Available to Aggregate Effects

```csharp
public interface IAggregateEffectContext
{
    /// <summary>
    ///     The aggregate's entity ID.
    /// </summary>
    string EntityId { get; }
    
    /// <summary>
    ///     Dispatch command back to this or another aggregate.
    /// </summary>
    Task<OperationResult> DispatchAsync<TAggregate>(
        string entityId,
        object command,
        CancellationToken cancellationToken = default)
        where TAggregate : class;
}
```

---

## Recommendation

| Criteria | Option A (Saga → HTTP) | Option B (Saga → Aggregate → HTTP) |
|----------|------------------------|-------------------------------------|
| Simplicity | ✅ Simpler for single-use flows | ❌ More moving parts |
| Reusability | ❌ HTTP logic in saga | ✅ Aggregates reusable |
| Testability | ❌ Must mock HTTP in saga tests | ✅ Unit test aggregates separately |
| Separation | ❌ Saga knows HTTP details | ✅ Clean boundaries |
| State ownership | ❌ Saga owns external IDs | ✅ Each aggregate owns its domain |
| Compensation | ❌ Saga must call HTTP DELETE | ✅ Aggregate handles its own cancel |

**Recommendation**:

- **Use Option B for production systems** — Better separation, reusability, testability
- **Option A is acceptable** for simple, one-off integrations where creating aggregates is overkill

**Both patterns should be supported** — Mississippi should provide:

1. `HttpServiceStep<TSaga>` for Option A (direct HTTP)
2. `AggregateCommandStep<TSaga, TTarget>` for Option B (aggregate orchestration)
3. `EventEffectBase<TEvent, TAggregate>` for all server-side effects (yield events or `yield break;`)

---

## Updated Based on Server Effect PR

The `topic/server-effect` PR implements the actual effect pattern:

### Key Insights from PR Review

1. **Effects yield events, not commands** — `IAsyncEnumerable<object>` returns events to persist
2. **Two base classes**:
   - `EventEffectBase<TEvent, TAggregate>` — Yields events (enrichment pattern)
   - `SimpleEventEffectBase<TEvent, TAggregate>` — No yield (HTTP/cross-aggregate pattern)
3. **Effects can inject services** — Registered as transient via DI
4. **No context object** — Effects receive `(TEvent, TAggregate, CancellationToken)` only
5. **Context via state** — Pass saga context through command properties, store in aggregate state

### Corrected Option B Pattern

All effects use `EventEffectBase`:

- Yield events when you have results to persist
- Use `yield break;` for fire-and-forget side effects

**One pattern, simpler DX** — developers learn one base class.

---

## Open Questions

1. **Should CorrelationId be mandatory in saga state?**  
   Recommendation: Yes, require it for tracing consistency.

2. **How does the saga get notified when a child aggregate's effect completes?**  
   Current answer: Polling via `VerifyAsync()`. Future: Consider event stream subscription.

3. **Should aggregate effects have access to the originating saga context?**  
   Current answer: Yes, passed through command properties, stored in aggregate state.

4. **What happens if the HTTP call in an aggregate effect fails repeatedly?**  
   Needs design: Aggregate-level retry policy, dead-letter handling.
