# Architect Review: Unified Source Generation Spec

**Reviewer:** Principal Software Architect (skeptical perspective)
**Date:** 2025-01-18
**Status:** ‚úÖ APPROVED ‚Äî Cross-project pattern validated via POC

---

## Executive Summary

The spec is **well-researched and technically sound**. The initial concern about
cross-project generation was **resolved** through a proof-of-concept that
validated the `PrivateAssets="all"` pattern.

### POC Validation (2025-01-17)

A throwaway proof-of-concept in `.scratchpad/poc-orleans-coexist/` proved:

1. ‚úÖ **Generators CAN read types from referenced assemblies** (not just source)
2. ‚úÖ **`PrivateAssets="all"` prevents Orleans from flowing transitively**
3. ‚úÖ **Client project has ZERO Orleans DLLs in output**
4. ‚úÖ **Orleans generator still produces serialization code** (both coexist)

**POC Structure:**

```text
Source.Domain/          (Orleans SDK, [GenerateSerializer], [Id] attributes)
Source.Generator/       (Scans referenced assemblies for [GenerateClientDto])
Target.Contracts/       (PrivateAssets="all" ref to Domain, uses generator)
Target.Client/          (References only Contracts ‚Äî NO Orleans)
```

**Dual Generator Output:**

- `Source.Domain/obj/.../Source.Domain.orleans.g.cs` ‚Äî Orleans `Codec_ChannelProjection`
- `Target.Contracts/obj/.../ChannelProjectionDto.g.cs` ‚Äî Mississippi DTO (Orleans-free)

**Generated DTO (Orleans-free):**

```csharp
// <auto-generated/>
// Generated from: Source.Domain.MarkedProjection
// Orleans attributes stripped - WASM safe!
namespace Target.Contracts;
public sealed record MarkedProjectionDto
{
    public required string EntityId { get; init; }
    public required string Title { get; init; }
    public required System.DateTime CreatedAt { get; init; }
}
```

**Client Output DLLs:**

- `Mississippi.Target.Client.dll`
- `Mississippi.Target.Contracts.dll`
- ‚ùå No Orleans DLLs present

### Updated Verdict Table

| Area | Verdict | Notes |
| ---- | ------- | ----- |
| Problem Statement | ‚úÖ **VALID** | Duplication is real; 9 DTOs + 332-line DI file |
| Goals | ‚úÖ **VALID** | Orleans isolation is critical and well-articulated |
| Existing Generator Claims | ‚úÖ **VERIFIED** | All 10 claims in verification.md confirmed |
| Cross-Project Generation | ‚úÖ **VALIDATED** | POC proved `PrivateAssets="all"` pattern works |
| Attribute Naming | ‚úÖ **RESOLVED** | `Generate*`/`Define*` convention adopted per naming-taxonomy.md |
| DI Generator Approach | ‚úÖ **VALID** | Standard same-project generation; no issues |
| Phase 1 (Enable Existing) | ‚úÖ **SAFE** | Low risk; incremental improvement |
| Phases 4-5 (Client DTOs/Actions) | ‚úÖ **APPROVED** | Pattern validated; proceed with implementation |

---

## Cross-Project Source Generation: RESOLVED

### Original Concern

The original review raised a concern that Roslyn generators cannot emit to
external projects. This was **partially correct** but missed a key capability.

### Key Insight: Generators CAN Read Referenced Assemblies

While generators cannot emit to external projects, they **CAN**:

1. Run in the context of the target project (`Target.Contracts`)
2. Scan types from **referenced assemblies** via `compilation.References`
3. Find types with marker attributes (e.g., `[GenerateClientDto]`) in Domain
4. Emit Orleans-free DTOs into the target project's compilation

### The Correct Pattern

```xml
<!-- Target.Contracts.csproj -->
<ItemGroup>
  <!-- Reference Domain for type metadata; PrivateAssets prevents transitive flow -->
  <ProjectReference Include="..\Domain\Domain.csproj" PrivateAssets="all" />
  
  <!-- Generator as analyzer -->
  <ProjectReference Include="..\..\src\Generators\Generators.csproj"
                    OutputItemType="Analyzer"
                    ReferenceOutputAssembly="false" />
</ItemGroup>
```

**How It Works:**

1. `Target.Contracts` references `Domain` with `PrivateAssets="all"`
2. Domain builds first; its types are in the compiled assembly
3. Generator runs in `Target.Contracts` context
4. Generator scans `compilation.References` and finds Domain's assembly
5. Generator finds types with `[GenerateClientDto]` in Domain
6. Generator emits stripped DTOs into `Target.Contracts`
7. `PrivateAssets="all"` ensures Orleans doesn't flow to downstream consumers

### Why PrivateAssets="all" Is Critical

Without `PrivateAssets="all"`:

```text
Client ‚Üí Contracts ‚Üí Domain ‚Üí Orleans.Serialization ‚ùå
```

With `PrivateAssets="all"`:

```text
Client ‚Üí Contracts (generated DTOs only, no Domain dependency at runtime)
                  ‚Ü≥ Domain (compile-time only, not transitive) ‚úÖ
```

---

## Original Concern (Archived for Reference)

The original spec used `OutputItemType="Analyzer"` on the Domain reference,
which was incorrect. The correct pattern validated via POC uses:

```xml
<ProjectReference Include="..\Domain\Domain.csproj" PrivateAssets="all" />
<ProjectReference Include="..\..\Generators\Generators.csproj"
                  OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
```

Not:

```xml
<ProjectReference Include="..\Domain\Domain.csproj"
                  OutputItemType="Analyzer" ReferenceOutputAssembly="false" />
```

---

## Attribute Naming Review ‚Äî RESOLVED

The naming convention has been resolved via integration with the project-naming
work. See [naming-taxonomy.md](naming-taxonomy.md) for complete details.

### Adopted Convention

| Pattern | Examples | Purpose |
|---------|----------|---------|
| `Generate*` | `[GenerateAggregateService]`, `[GenerateClientDto]`, `[GenerateClientAction]` | Triggers source generation |
| `Define*` | `[DefineProjectionPath]`, `[DefineBrookName]` | Assigns identity/metadata |

### Rationale

- **`Generate*`** aligns with Orleans `[GenerateSerializer]` style
- **`Define*`** follows Orleans identity marker style (`[Alias]`, `[Id]`)

### Migration Approach

Since this is **pre-production**, we do a **clean rename** without backward
compatibility shims:

```csharp
// Rename attribute directly (no shims needed)
[AttributeUsage(AttributeTargets.Class)]
public sealed class GenerateAggregateServiceAttribute : Attribute
{
    public GenerateAggregateServiceAttribute(string route) => Route = route;
    public string Route { get; }
}
```

Update all usages in one pass; delete old attribute names.

---

## Claim Verification Status

### Verified (No Issues)

| ID | Claim | Evidence |
| -- | ----- | -------- |
| C1 | AggregateServiceGenerator exists | Line 19: `IIncrementalGenerator` |
| C2 | Only UserAggregate has `[AggregateService]` | grep confirms |
| C3 | Generated IUserService is unused | Program.cs uses grain factory directly |
| C4 | ProjectionApiGenerator strips Orleans attrs | Lines 237-245 filter [Id], [GenerateSerializer] |
| C5 | Client uses manual Contracts DTOs | .csproj references confirm |
| C6 | 9 manual DTOs exist in Contracts | ls confirms file count |
| C7 | CascadeRegistrations has 80+ calls | 332 lines, 80+ registrations |
| C8 | Client is Orleans-free | No Orleans package refs |
| C9 | ProjectionPath drives discovery | InletBlazorSignalRBuilder.ScanProjectionDtos() |
| C10 | Generators respect internal accessibility | Lines 98-105 check DeclaredAccessibility |
| C11 | Cross-project generation via PrivateAssets | ‚úÖ **VALIDATED via POC** |

---

## Phase Risk Assessment

| Phase | Risk | Recommendation |
| ----- | ---- | -------------- |
| **Phase 1: Enable Existing Generators** | üü¢ Low | Proceed |
| **Phase 2: Verify Projection DTOs** | üü¢ Low | Proceed |
| **Phase 3: DI Generator** | üü¢ Low | Proceed |
| **Phase 4: Client DTO Generator** | üü¢ Low | **APPROVED** ‚Äî pattern validated |
| **Phase 5: Client Action Generator** | üü¢ Low | **APPROVED** ‚Äî same pattern applies |

---

## Summary

1. ‚úÖ **Cross-project pattern VALIDATED** via POC using `PrivateAssets="all"`
2. ‚úÖ **Attribute naming RESOLVED** ‚Äî `Generate*`/`Define*` convention adopted
3. ‚úÖ **All phases APPROVED** ‚Äî proceed with implementation (Phase 0 first)

---

## Approval

| Condition | Status |
| --------- | ------ |
| All Phases (0-5) | ‚úÖ APPROVED ‚Äî Proceed with implementation |
| Attribute naming | ‚úÖ RESOLVED ‚Äî `Generate*`/`Define*` convention adopted |

**Next Action:** Proceed with Phase 0 (attribute naming alignment), then Phase 1.
