# ADR-0004: Source Generator Architecture

**Status**: Accepted
**Date**: 2026-01-03

## Context

Ripples needs to eliminate boilerplate by auto-generating:
- HTTP controllers for projections and commands
- Route registries for WASM URL construction
- DI registrations for `IRipple<T>` implementations
- Command dispatcher interfaces and implementations

We must decide:
1. How to organize generators (single vs multiple)
2. What templates to use (string building vs Scriban)
3. How to handle incremental generation for performance

## Decision

We will implement **five incremental source generators** in a single `Ripples.Generators` package:

### Generator Structure

| Generator | Trigger | Output |
|-----------|---------|--------|
| `ProjectionControllerGenerator` | `[UxProjection]` on record | `*ProjectionController.g.cs` |
| `AggregateControllerGenerator` | `[UxAggregate]` on interface | `*AggregateController.g.cs` |
| `RouteRegistryGenerator` | All `[UxProjection]` + `[UxAggregate]` | `RouteRegistry.g.cs` |
| `RippleRegistrationGenerator` | All `[UxProjection]` | `RippleServiceRegistrations.g.cs` |
| `CommandDispatcherGenerator` | `[UxAggregate]` on interface | `I*CommandDispatcher.g.cs` |

### Incremental Generation

All generators use `IIncrementalGenerator` for performance:

```csharp
[Generator]
public sealed class ProjectionControllerGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var projections = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                "Mississippi.Ripples.Abstractions.UxProjectionAttribute",
                predicate: static (node, _) => node is RecordDeclarationSyntax or ClassDeclarationSyntax,
                transform: static (ctx, _) => ExtractProjectionInfo(ctx))
            .Where(static p => p is not null);

        context.RegisterSourceOutput(projections, GenerateController);
    }
}
```

### Template Strategy

Use **raw string literals** (C# 11+) for templates—no external dependencies:

```csharp
private static string GenerateController(ProjectionInfo info) => $$"""
    // <auto-generated/>
    #nullable enable
    
    namespace {{info.Namespace}};
    
    [GeneratedCode("Mississippi.Ripples.Generators", "1.0.0")]
    [Route("api/projections/{{info.Route}}/{entityId}")]
    [ApiController]
    public sealed partial class {{info.TypeName}}Controller 
        : UxProjectionControllerBase<{{info.TypeName}}>
    {
        // ...
    }
    """;
```

### Package Structure

```
Ripples.Generators/
├── Ripples.Generators.csproj
├── Generators/
│   ├── ProjectionControllerGenerator.cs
│   ├── AggregateControllerGenerator.cs
│   ├── RouteRegistryGenerator.cs
│   ├── RippleRegistrationGenerator.cs
│   └── CommandDispatcherGenerator.cs
├── Models/
│   ├── ProjectionInfo.cs
│   ├── AggregateInfo.cs
│   └── CommandInfo.cs
└── Helpers/
    ├── RoslynExtensions.cs
    └── NamingConventions.cs
```

## Consequences

### Positive

- Incremental generators only run when inputs change
- No external template engine dependencies
- Raw string literals are easy to read and maintain
- Single package simplifies versioning

### Negative

- All generators in one package means all recompile together
- Raw strings harder to test than separate template files
- Must target `netstandard2.0` (older C# features limited)

### Neutral

- Analyzer tests can verify generated code compiles
- Generators can emit diagnostics for validation errors
