# Task 02: Server-Side Saga Generators

## Objective

Create source generators that produce server-side saga controllers and DTOs, enabling HTTP endpoints for saga initiation.

## Rationale

Aggregates have `AggregateControllerGenerator` and `CommandServerDtoGenerator`. Sagas need equivalent generators so developers don't write boilerplate controllers.

## Deliverables

### 1. `SagaControllerGenerator`

**Location:** `src/Inlet.Server.Generators/SagaControllerGenerator.cs`

**Triggers on:** `[GenerateSagaEndpoints(InputType = typeof(TInput))]` attribute on saga state

**Generates:** `{SagaName}SagaController.g.cs`

**Example output:**

```csharp
// <auto-generated />
namespace Spring.Server.Controllers.Sagas;

/// <summary>
///     Controller for starting and managing TransferFunds sagas.
/// </summary>
[ApiController]
[Route("api/sagas/transfer-funds")]
public sealed class TransferFundsSagaController : ControllerBase
{
    public TransferFundsSagaController(
        ISagaOrchestrator orchestrator,
        IMapper<StartTransferFundsSagaDto, TransferFundsSagaInput> mapper,
        ILogger<TransferFundsSagaController> logger)
    {
        Orchestrator = orchestrator;
        Mapper = mapper;
        Logger = logger;
    }
    
    private ILogger<TransferFundsSagaController> Logger { get; }
    private IMapper<StartTransferFundsSagaDto, TransferFundsSagaInput> Mapper { get; }
    private ISagaOrchestrator Orchestrator { get; }
    
    /// <summary>
    ///     Starts a new TransferFunds saga instance.
    /// </summary>
    [HttpPost("{sagaId:guid}")]
    public async Task<ActionResult> StartAsync(
        [FromRoute] Guid sagaId,
        [FromBody] StartTransferFundsSagaDto request,
        CancellationToken cancellationToken = default)
    {
        ArgumentNullException.ThrowIfNull(request);
        
        TransferFundsSagaInput input = Mapper.Map(request);
        
        try
        {
            await Orchestrator.StartAsync<TransferFundsSagaState, TransferFundsSagaInput>(
                sagaId, 
                input, 
                request.CorrelationId);
            
            return Accepted();
        }
        catch (InvalidOperationException ex)
        {
            Logger.SagaStartFailed(sagaId, ex.Message);
            return BadRequest(new { error = ex.Message });
        }
    }
    
    /// <summary>
    ///     Gets the current status of a saga instance.
    /// </summary>
    [HttpGet("{sagaId:guid}/status")]
    public async Task<ActionResult<SagaStatusDto>> GetStatusAsync(
        [FromRoute] Guid sagaId,
        CancellationToken cancellationToken = default)
    {
        SagaStatusProjection? status = await Orchestrator.GetStatusAsync(sagaId);
        
        if (status is null)
        {
            return NotFound();
        }
        
        return Ok(MapToDto(status));
    }
}
```

### 2. `SagaServerDtoGenerator`

**Location:** `src/Inlet.Server.Generators/SagaServerDtoGenerator.cs`

**Generates:** `Start{SagaName}SagaDto.g.cs`

**Example output:**

```csharp
// <auto-generated />
namespace Spring.Server.Controllers.Sagas.Dtos;

/// <summary>
///     DTO for starting a TransferFunds saga.
/// </summary>
public sealed record StartTransferFundsSagaDto
{
    /// <summary>
    ///     Gets the source account identifier.
    /// </summary>
    public required string SourceAccountId { get; init; }
    
    /// <summary>
    ///     Gets the destination account identifier.
    /// </summary>
    public required string DestinationAccountId { get; init; }
    
    /// <summary>
    ///     Gets the transfer amount.
    /// </summary>
    public required decimal Amount { get; init; }
    
    /// <summary>
    ///     Gets an optional correlation ID for distributed tracing.
    /// </summary>
    public string? CorrelationId { get; init; }
}
```

### 3. `SagaServerMapperGenerator`

**Location:** `src/Inlet.Server.Generators/SagaServerMapperGenerator.cs`

**Generates:** `Start{SagaName}SagaDtoMapper.g.cs`

Maps from DTO to saga input type.

### 4. `SagaServerRegistrationGenerator`

**Location:** `src/Inlet.Server.Generators/SagaServerRegistrationGenerator.cs`

**Generates:** `{SagaName}SagaServerRegistrations.g.cs`

```csharp
public static IServiceCollection Add{SagaName}SagaServer(this IServiceCollection services)
{
    services.AddSingleton<IMapper<StartTransferFundsSagaDto, TransferFundsSagaInput>, 
        StartTransferFundsSagaDtoMapper>();
    return services;
}
```

## Generator Detection Logic

1. Scan for types with `[GenerateSagaEndpoints]` attribute
2. Read `InputType` property from attribute to get saga input type
3. Read input type's properties via reflection/symbol analysis
4. Generate DTO with same properties + `CorrelationId`
5. Generate controller with Start and GetStatus endpoints
6. Generate mapper and registration

## Acceptance Criteria

- [ ] `SagaControllerGenerator` produces valid controller code
- [ ] `SagaServerDtoGenerator` produces valid DTO code
- [ ] `SagaServerMapperGenerator` produces valid mapper code
- [ ] `SagaServerRegistrationGenerator` produces registration extension
- [ ] Generated code compiles with zero warnings
- [ ] Route follows pattern: `api/sagas/{kebab-case-saga-name}/{sagaId}`
- [ ] DTO includes all input properties plus `CorrelationId`

## Dependencies

- Saga infrastructure (`ISagaOrchestrator`, `SagaStatusProjection`)
- `[GenerateSagaEndpoints]` attribute with `InputType` property

## Blocked By

- [01-saga-abstractions](01-saga-abstractions.md) (for types)

## Blocks

- [04-generator-tests](04-generator-tests.md)
- [05-domain-saga](05-domain-saga.md)
