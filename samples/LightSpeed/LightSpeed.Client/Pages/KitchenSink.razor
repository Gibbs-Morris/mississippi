@page "/kitchen-sink"
@using Mississippi.Refraction.Components.Molecules
@using Mississippi.Refraction.Components.Molecules.MisButton
@using Mississippi.Refraction.Components.Molecules.MisButton.Actions
@using Mississippi.Refraction.Components.Molecules.MisCheckboxActions
@using Mississippi.Refraction.Components.Molecules.MisSelectActions
@using Mississippi.Refraction.Components.Molecules.MisTextInputActions
@inherits StoreComponent

<h1>Kitchen Sink</h1>

<p>Centralized control diagnostics for Refraction components. Start with <strong>MisButton</strong> and scale this pattern as new controls are added.</p>
<p>Theme sample: edit <strong>refraction.tokens.luminous.css</strong>, <strong>refraction.luminous.base.css</strong>, or <strong>refraction.theme.luminous.css</strong> in the Luminous package to see token-based overrides in action.</p>
<p>Theme packaging guide: see <strong>samples/LightSpeed/README.md</strong> under <strong>Refraction Theming Sample</strong>.</p>

<section>
    <h2>Typography</h2>
    <p class="mis-body-lg">Luminous theme typography: <strong>Rajdhani</strong> for headings, <strong>Space Grotesk</strong> for body, <strong>JetBrains Mono</strong> for code.</p>

    <h3>Type Scale</h3>
    <div style="display: flex; flex-direction: column; gap: var(--mis-space-md);">
        <div class="mis-display">Display — 40px / 300 weight (Rajdhani Light)</div>
        <div class="mis-h1">Heading 1 — 32px / 300 weight (Rajdhani Light)</div>
        <h2>Heading 2 — 24px / 400 weight (Rajdhani Regular)</h2>
        <h3>Heading 3 — 20px / 500 weight (Rajdhani Medium)</h3>
        <p class="mis-body-lg">Body Large — 17px / 400 weight (Space Grotesk Regular)</p>
        <p>Body — 16px / 400 weight (Space Grotesk Regular)</p>
        <span class="mis-ui">UI Text — 14px / 500 weight (Space Grotesk Medium)</span>
        <span class="mis-caption">Caption — 12px / 500 weight (Space Grotesk Medium)</span>
    </div>

    <h3>Code / Monospace</h3>
    <p>Inline code example: <code>const greeting = "Hello, Luminous!";</code></p>
    <pre><code>// JetBrains Mono — 13px / 400 weight
function calculateEventPosition(events) {
    return events.reduce((acc, e) => acc + e.sequence, 0);
}</code></pre>
    <p class="mis-code-sm">Small code (12px): <code class="mis-code-sm">AGGREGATE_ID: 7f3d8c1a-9e2b-4f6a</code></p>

    <h3>Font Weights</h3>
    <p style="font-weight: var(--mis-font-weight-light);">Light (300) — Delicate and airy</p>
    <p style="font-weight: var(--mis-font-weight-regular);">Regular (400) — Standard reading weight</p>
    <p style="font-weight: var(--mis-font-weight-medium);">Medium (500) — Subtle emphasis</p>
    <p style="font-weight: var(--mis-font-weight-semibold);">Semibold (600) — Strong emphasis</p>
</section>

<section>
    <h2>MisButton</h2>

    <h3>Control Inputs</h3>
    <div>
        <label>
            Text
            <input value="@ButtonModel.Text" @oninput="HandleTextChanged" />
        </label>
    </div>
    <div>
        <label>
            IntentId
            <input value="@ButtonModel.IntentId" @oninput="HandleIntentIdChanged" />
        </label>
    </div>
    <div>
        <label>
            AriaLabel
            <input value="@ButtonModel.AriaLabel" @oninput="HandleAriaLabelChanged" />
        </label>
    </div>
    <div>
        <label>
            Title
            <input value="@ButtonModel.Title" @oninput="HandleTitleChanged" />
        </label>
    </div>
    <div>
        <label>
            CssClass
            <input value="@ButtonModel.CssClass" @oninput="HandleCssClassChanged" />
        </label>
    </div>
    <div>
        <label>
            Type
            <select value="@ButtonModel.Type" @onchange="HandleTypeChanged">
                @foreach (MisButtonType type in Enum.GetValues<MisButtonType>())
                {
                    <option value="@type">@type</option>
                }
            </select>
        </label>
    </div>
    <div>
        <label>
            <input type="checkbox" checked="@ButtonModel.IsDisabled" @onchange="HandleIsDisabledChanged" /> Disabled
        </label>
    </div>

    <h3>Preview</h3>
    <MisButton Model="@ButtonModel"
               OnAction="@((IMisButtonAction action) => HandleMisButtonActionAsync(action))" />

    <h3>Events</h3>
    <button type="button" @onclick="HandleClearEvents">Clear Events</button>
    @if (ButtonEvents.Count == 0)
    {
        <p>No events recorded yet.</p>
    }
    else
    {
        <ul>
            @foreach (string buttonEvent in ButtonEvents)
            {
                <li>@buttonEvent</li>
            }
        </ul>
    }
</section>

<section>
    <h2>MisCheckbox</h2>

    <h3>Control Inputs</h3>
    <div>
        <label>
            Value Attribute
            <input value="@CheckboxModel.Value" @oninput="HandleCheckboxValueChanged" />
        </label>
    </div>
    <div>
        <label>
            IntentId
            <input value="@CheckboxModel.IntentId" @oninput="HandleCheckboxIntentIdChanged" />
        </label>
    </div>
    <div>
        <label>
            AriaLabel
            <input value="@CheckboxModel.AriaLabel" @oninput="HandleCheckboxAriaLabelChanged" />
        </label>
    </div>
    <div>
        <label>
            Title
            <input value="@CheckboxModel.Title" @oninput="HandleCheckboxTitleChanged" />
        </label>
    </div>
    <div>
        <label>
            CssClass
            <input value="@CheckboxModel.CssClass" @oninput="HandleCheckboxCssClassChanged" />
        </label>
    </div>
    <div>
        <label>
            Visual State
            <select value="@CheckboxModel.State" @onchange="HandleCheckboxStateChanged">
                @foreach (MisCheckboxState state in Enum.GetValues<MisCheckboxState>())
                {
                    <option value="@state">@state</option>
                }
            </select>
        </label>
    </div>
    <div>
        <label>
            <input type="checkbox" checked="@CheckboxModel.IsChecked" @onchange="HandleCheckboxIsCheckedChanged" /> Checked
        </label>
    </div>
    <div>
        <label>
            <input type="checkbox" checked="@CheckboxModel.IsDisabled" @onchange="HandleCheckboxIsDisabledChanged" /> Disabled
        </label>
    </div>
    <div>
        <label>
            <input type="checkbox" checked="@CheckboxModel.IsRequired" @onchange="HandleCheckboxIsRequiredChanged" /> Required
        </label>
    </div>

    <h3>Preview</h3>
    <label style="display: inline-flex; align-items: center; gap: var(--mis-space-sm);">
        <MisCheckbox Model="@CheckboxModel"
                     OnAction="@((IMisCheckboxAction action) => HandleMisCheckboxActionAsync(action))" />
        Accept terms
    </label>

    <h3>Events</h3>
    <button type="button" @onclick="HandleClearCheckboxEvents">Clear Events</button>
    @if (CheckboxEvents.Count == 0)
    {
        <p>No events recorded yet.</p>
    }
    else
    {
        <ul>
            @foreach (string checkboxEvent in CheckboxEvents)
            {
                <li>@checkboxEvent</li>
            }
        </ul>
    }
</section>

<section>
    <h2>MisTextInput</h2>

    <h3>Control Inputs</h3>
    <div>
        <label>
            Value
            <input value="@TextInputModel.Value" @oninput="HandleInputValueChanged" />
        </label>
    </div>
    <div>
        <label>
            IntentId
            <input value="@TextInputModel.IntentId" @oninput="HandleInputIntentIdChanged" />
        </label>
    </div>
    <div>
        <label>
            AriaLabel
            <input value="@TextInputModel.AriaLabel" @oninput="HandleInputAriaLabelChanged" />
        </label>
    </div>
    <div>
        <label>
            Placeholder
            <input value="@TextInputModel.Placeholder" @oninput="HandleInputPlaceholderChanged" />
        </label>
    </div>
    <div>
        <label>
            Title
            <input value="@TextInputModel.Title" @oninput="HandleInputTitleChanged" />
        </label>
    </div>
    <div>
        <label>
            CssClass
            <input value="@TextInputModel.CssClass" @oninput="HandleInputCssClassChanged" />
        </label>
    </div>
    <div>
        <label>
            AutoComplete
            <input value="@TextInputModel.AutoComplete" @oninput="HandleInputAutoCompleteChanged" />
        </label>
    </div>
    <div>
        <label>
            Type
            <select value="@TextInputModel.Type" @onchange="HandleInputTypeChanged">
                @foreach (MisTextInputType type in Enum.GetValues<MisTextInputType>())
                {
                    <option value="@type">@type</option>
                }
            </select>
        </label>
    </div>
    <div>
        <label>
            <input type="checkbox" checked="@TextInputModel.IsDisabled" @onchange="HandleInputIsDisabledChanged" /> Disabled
        </label>
    </div>
    <div>
        <label>
            <input type="checkbox" checked="@TextInputModel.IsReadOnly" @onchange="HandleInputIsReadOnlyChanged" /> Read-only
        </label>
    </div>

    <h3>Preview</h3>
    <MisTextInput Model="@TextInputModel"
                  OnAction="@((IMisTextInputAction action) => HandleMisTextInputActionAsync(action))" />

    <h3>Events</h3>
    <button type="button" @onclick="HandleClearTextInputEvents">Clear Events</button>
    @if (TextInputEvents.Count == 0)
    {
        <p>No events recorded yet.</p>
    }
    else
    {
        <ul>
            @foreach (string textInputEvent in TextInputEvents)
            {
                <li>@textInputEvent</li>
            }
        </ul>
    }
</section>

<section>
    <h2>MisSelect</h2>

    <h3>Control Inputs</h3>
    <div>
        <label>
            Value
            <input value="@SelectModel.Value" @oninput="HandleSelectValueChanged" />
        </label>
    </div>
    <div>
        <label>
            IntentId
            <input value="@SelectModel.IntentId" @oninput="HandleSelectIntentIdChanged" />
        </label>
    </div>
    <div>
        <label>
            AriaLabel
            <input value="@SelectModel.AriaLabel" @oninput="HandleSelectAriaLabelChanged" />
        </label>
    </div>
    <div>
        <label>
            Placeholder
            <input value="@SelectModel.Placeholder" @oninput="HandleSelectPlaceholderChanged" />
        </label>
    </div>
    <div>
        <label>
            Title
            <input value="@SelectModel.Title" @oninput="HandleSelectTitleChanged" />
        </label>
    </div>
    <div>
        <label>
            CssClass
            <input value="@SelectModel.CssClass" @oninput="HandleSelectCssClassChanged" />
        </label>
    </div>
    <div>
        <label>
            Visual State
            <select value="@SelectModel.State" @onchange="HandleSelectStateChanged">
                @foreach (MisSelectState state in Enum.GetValues<MisSelectState>())
                {
                    <option value="@state">@state</option>
                }
            </select>
        </label>
    </div>
    <div>
        <label>
            Options (one per line; format: value|label|disabled)
            <textarea rows="6" @oninput="HandleSelectOptionsChanged">@FormatSelectOptionsInput(SelectModel.Options)</textarea>
        </label>
    </div>
    <div>
        <label>
            <input type="checkbox" checked="@SelectModel.IsDisabled" @onchange="HandleSelectIsDisabledChanged" /> Disabled
        </label>
    </div>
    <div>
        <label>
            <input type="checkbox" checked="@SelectModel.IsRequired" @onchange="HandleSelectIsRequiredChanged" /> Required
        </label>
    </div>

    <h3>Preview</h3>
    <MisSelect Model="@SelectModel"
               OnAction="@((IMisSelectAction action) => HandleMisSelectActionAsync(action))" />

    <h3>Events</h3>
    <button type="button" @onclick="HandleClearSelectEvents">Clear Events</button>
    @if (SelectEvents.Count == 0)
    {
        <p>No events recorded yet.</p>
    }
    else
    {
        <ul>
            @foreach (string selectEvent in SelectEvents)
            {
                <li>@selectEvent</li>
            }
        </ul>
    }
</section>