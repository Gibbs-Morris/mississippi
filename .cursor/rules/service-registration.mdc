---
description: Service Registration and Configuration Pattern
globs: ["**/*.cs"]
alwaysApply: false
---
# Service Registration and Configuration Pattern
**Source:** .github/instructions/service-registration.instructions.md


# Service Registration and Configuration Pattern

This document defines the service registration standards and configuration patterns for dependency injection in the Mississippi Framework. All service registration classes must follow these guidelines to ensure consistency, maintainability, and proper configuration handling across features.

## Core Principles

### Hierarchical Feature-Based Registration
- **Feature-aligned organization** — service registration follows the feature namespace structure
- **ServiceRegistration class per feature** — create `public static class ServiceRegistration` in each feature folder with `Add{FeatureName}()` methods
- **Parent-child registration pattern** — parent features call child feature registrations to build composable service collections
- **Public at logical boundaries** — make registration methods `public` only at product/feature boundaries where consumers would reasonably register just that subset
- **Internal for implementation details** — sub-features and implementation components should have `internal` registration methods

### Configuration and Options Pattern
- **Always use Options pattern for configuration** — NEVER use direct configuration parameters in constructors; always use `IOptions<T>`, `IOptionsSnapshot<T>`, or `IOptionsMonitor<T>`
- **Make everything configurable** — follow cloud-native principles by externalizing all configuration; prefer configuration over hard-coded values
- **Support multiple configuration overloads** — provide overloads for `Action<TOptions>`, `IConfiguration`, and explicit parameters to support different consumption patterns
- **Private core registration method** — implement core service registration in a private parameterless method, then create public overloads that handle configuration
- **Options classes follow naming conventions** — use `{FeatureName}Options` naming pattern (e.g., `BrookStorageOptions`, `StreamingOptions`)
- **Default options values** — provide sensible defaults in options classes using property initializers
- **Validate options at startup** — use `IValidateOptions<T>` or `ValidateOnStart()` to catch configuration errors early
- **Connection string patterns** — accept connection strings as parameters and register clients using factory patterns, not direct instantiation in DI

### Integration Requirements
- **Follow dependency injection property pattern** — all registered services must use `private Type Name { get; }` pattern when injected
- **Consistent naming pattern** — use `Add{FeatureName}()` naming convention following PascalCase rules from naming guidelines
- **XML documentation requirements** — follow naming conventions for all public registration methods with parameter and return value documentation
- **Access control compliance** — follow sealed classes and minimal access principles from C# guidelines

### Orleans and Hosting Service Integration
- **Service registration must be synchronous** — NEVER perform async operations (database calls, external service calls) during service registration
- **Use IHostedService for async initialization** — defer async setup operations to hosted services that run after DI container is built
- **Use Orleans lifecycle participants** — for Orleans-specific initialization that needs to happen at specific lifecycle stages
- **Factory patterns for deferred initialization** — register factories that perform async operations when first called, not during registration
- **Database/external service initialization** — always use hosted services or lifecycle participants, never inline in registration methods

## Service Registration Implementation Pattern

### Required File Structure
```
Mississippi.EventSourcing/
├── ServiceRegistration.cs              // Calls child registrations
├── Streams/
│   ├── ServiceRegistration.cs          // Registers stream services
│   └── Batching/
│       └── ServiceRegistration.cs      // Registers batching services
└── Storage/
    └── ServiceRegistration.cs          // Registers storage services
```

### Private Core + Public Overloads Pattern

```csharp
namespace Mississippi.EventSourcing.Cosmos
{
    /// <summary>
    /// Provides service registration for Cosmos DB storage with comprehensive configuration support.
    /// Follows the established pattern of private core method + public configuration overloads.
    /// </summary>
    public static class ServiceRegistration
    {
        /// <summary>
        /// Private core registration method that registers all services without configuration.
        /// This is called by all public overloads after configuration is handled.
        /// </summary>
        /// <param name="services">The service collection to register services with.</param>
        /// <returns>The service collection for method chaining.</returns>
        private static IServiceCollection AddCosmosBrookStorageProvider(this IServiceCollection services)
        {
            // Register all core services using dependency injection property pattern
            return services
                .AddSingleton<IBrookStorageProvider, BrookStorageProvider>()
                .AddSingleton<IBrookRecoveryService, BrookRecoveryService>()
                .AddSingleton<IEventBrookReader, EventBrookReader>()
                .AddSingleton<IEventBrookAppender, EventBrookAppender>()
                .AddSingleton<ICosmosRepository, CosmosRepository>()
                .AddSingleton<IDistributedLockManager, BlobDistributedLockManager>()
                .AddSingleton<IBatchSizeEstimator, BatchSizeEstimator>()
                .AddSingleton<IRetryPolicy, CosmosRetryPolicy>()
                .AddSingleton<CosmosContainerInitializationService>()
                .AddHostedService<CosmosContainerInitializationService>(provider =>
                    provider.GetRequiredService<CosmosContainerInitializationService>())
                .AddSingleton<Container>(provider =>
                {
                    var initService = provider.GetRequiredService<CosmosContainerInitializationService>();
                    return initService.GetContainer();
                });
        }

        /// <summary>
        /// Registers Cosmos DB storage provider with explicit connection strings and optional configuration.
        /// This overload supports the most common usage pattern with connection strings.
        /// </summary>
        /// <param name="services">The service collection to register services with.</param>
        /// <param name="cosmosConnectionString">The Cosmos DB connection string.</param>
        /// <param name="blobStorageConnectionString">The Azure Blob Storage connection string for distributed locking.</param>
        /// <param name="configureOptions">Optional action to configure additional storage options.</param>
        /// <returns>The service collection for method chaining.</returns>
        public static IServiceCollection AddCosmosBrookStorageProvider(
            this IServiceCollection services,
            string cosmosConnectionString,
            string blobStorageConnectionString,
            Action<BrookStorageOptions>? configureOptions = null)
        {
            // Register clients using factory pattern (not direct instantiation)
            services.AddSingleton<CosmosClient>(_ => new CosmosClient(cosmosConnectionString));
            services.AddSingleton<BlobServiceClient>(_ => new BlobServiceClient(blobStorageConnectionString));

            // Configure options if provided
            if (configureOptions != null)
            {
                services.Configure(configureOptions);
            }

            return services.AddCosmosBrookStorageProvider();
        }

        /// <summary>
        /// Registers Cosmos DB storage provider with configuration action only.
        /// This overload is useful when connection strings are configured elsewhere.
        /// </summary>
        /// <param name="services">The service collection to register services with.</param>
        /// <param name="configureOptions">Action to configure the storage options.</param>
        /// <returns>The service collection for method chaining.</returns>
        public static IServiceCollection AddCosmosBrookStorageProvider(
            this IServiceCollection services,
            Action<BrookStorageOptions> configureOptions)
        {
            services.Configure(configureOptions);
            return services.AddCosmosBrookStorageProvider();
        }

        /// <summary>
        /// Registers Cosmos DB storage provider with IConfiguration binding.
        /// This overload supports appsettings.json and other configuration sources.
        /// </summary>
        /// <param name="services">The service collection to register services with.</param>
        /// <param name="configuration">The configuration section containing BrookStorageOptions.</param>
        /// <returns>The service collection for method chaining.</returns>
        public static IServiceCollection AddCosmosBrookStorageProvider(
            this IServiceCollection services,
            IConfiguration configuration)
        {
            services.Configure<BrookStorageOptions>(configuration);
            return services.AddCosmosBrookStorageProvider();
        }

        /// <summary>
        /// Registers Cosmos DB storage provider with validation.
        /// This overload demonstrates options validation for production scenarios.
        /// </summary>
        /// <param name="services">The service collection to register services with.</param>
        /// <param name="cosmosConnectionString">The Cosmos DB connection string.</param>
        /// <param name="blobStorageConnectionString">The Azure Blob Storage connection string.</param>
        /// <param name="configureOptions">Action to configure the storage options.</param>
        /// <returns>The service collection for method chaining.</returns>
        public static IServiceCollection AddCosmosBrookStorageProviderWithValidation(
            this IServiceCollection services,
            string cosmosConnectionString,
            string blobStorageConnectionString,
            Action<BrookStorageOptions>? configureOptions = null)
        {
            // Register clients
            services.AddSingleton<CosmosClient>(_ => new CosmosClient(cosmosConnectionString));
            services.AddSingleton<BlobServiceClient>(_ => new BlobServiceClient(blobStorageConnectionString));

            // Configure options with validation
            var optionsBuilder = services.AddOptions<BrookStorageOptions>();
            
            if (configureOptions != null)
            {
                optionsBuilder.Configure(configureOptions);
            }
            
            // Add validation rules
            optionsBuilder.Validate(options =>
            {
                return !string.IsNullOrWhiteSpace(options.DatabaseName) &&
                       !string.IsNullOrWhiteSpace(options.EventsContainer) &&
                       !string.IsNullOrWhiteSpace(options.HeadsContainer) &&
                       options.MaxBatchSize > 0 &&
                       options.RequestTimeoutSeconds > 0 &&
                       options.MaxRetryAttempts >= 0;
            }, "BrookStorageOptions validation failed. Check DatabaseName, container names, and numeric values.")
            .ValidateOnStart(); // Fail fast during startup if configuration is invalid

            return services.AddCosmosBrookStorageProvider();
        }
    }
}
```

### Options Class Pattern

```csharp
namespace Mississippi.EventSourcing.Cosmos
{
    /// <summary>
    /// Configuration options for Cosmos DB brook storage provider.
    /// Provides sensible defaults while allowing full customization.
    /// </summary>
    public sealed class BrookStorageOptions
    {
        /// <summary>
        /// Gets or sets the Cosmos DB database name.
        /// Default: "EventStore"
        /// </summary>
        [Required]
        [MinLength(1)]
        public string DatabaseName { get; set; } = "EventStore";
        
        /// <summary>
        /// Gets or sets the events container name.
        /// Default: "Events"
        /// </summary>
        [Required]
        [MinLength(1)]
        public string EventsContainer { get; set; } = "Events";
        
        /// <summary>
        /// Gets or sets the heads container name.
        /// Default: "Heads"
        /// </summary>
        [Required]
        [MinLength(1)]
        public string HeadsContainer { get; set; } = "Heads";
        
        /// <summary>
        /// Gets or sets the maximum batch size for event operations.
        /// Default: 100
        /// </summary>
        [Range(1, 10000)]
        public int MaxBatchSize { get; set; } = 100;
        
        /// <summary>
        /// Gets or sets the request timeout in seconds.
        /// Default: 30
        /// </summary>
        [Range(1, 300)]
        public int RequestTimeoutSeconds { get; set; } = 30;
        
        /// <summary>
        /// Gets or sets the maximum retry attempts for transient failures.
        /// Default: 3
        /// </summary>
        [Range(0, 10)]
        public int MaxRetryAttempts { get; set; } = 3;
        
        /// <summary>
        /// Gets or sets a value indicating whether to enable automatic container creation.
        /// Default: true
        /// </summary>
        public bool AutoCreateContainers { get; set; } = true;
    }
}
```

### Hierarchical Registration Example

```csharp
// Root level service registration - Mississippi.EventSourcing/ServiceRegistration.cs
namespace Mississippi.EventSourcing
{
    /// <summary>
    /// Provides service registration for the complete EventSourcing feature.
    /// This is a logical product boundary, so the registration method is public.
    /// </summary>
    public static class ServiceRegistration
    {
        /// <summary>
        /// Registers all EventSourcing services including streams, storage, and core components.
        /// </summary>
        /// <param name="services">The service collection to register services with.</param>
        /// <returns>The service collection for method chaining.</returns>
        public static IServiceCollection AddEventSourcing(this IServiceCollection services)
        {
            return services
                .AddStreams()           // Calls child feature registration
                .AddEventSourcingCore() // This feature's core services
                .AddScoped<IEventBus, EventBus>()
                .AddSingleton<IEventStore, EventStore>();
        }
        
        /// <summary>
        /// Registers only the core EventSourcing services without storage providers.
        /// Public method as consumers might want just core functionality.
        /// </summary>
        /// <param name="services">The service collection to register services with.</param>
        /// <returns>The service collection for method chaining.</returns>
        public static IServiceCollection AddEventSourcingCore(this IServiceCollection services)
        {
            return services
                .AddScoped<IEventSerializer, EventSerializer>()
                .AddScoped<IEventMetadataFactory, EventMetadataFactory>();
        }
    }
}

// Child feature registration - Mississippi.EventSourcing.Streams/ServiceRegistration.cs
namespace Mississippi.EventSourcing.Streams
{
    /// <summary>
    /// Provides service registration for stream processing capabilities.
    /// Internal class as this is an implementation detail of EventSourcing.
    /// </summary>
    internal static class ServiceRegistration
    {
        /// <summary>
        /// Registers stream processing services and their dependencies.
        /// Internal method as consumers shouldn't register streams independently.
        /// </summary>
        /// <param name="services">The service collection to register services with.</param>
        /// <returns>The service collection for method chaining.</returns>
        internal static IServiceCollection AddStreams(this IServiceCollection services)
        {
            return services
                .AddBatching()          // Calls sub-feature registration
                .AddScoped<IStreamProcessor, StreamProcessor>()
                .AddScoped<IStreamValidator, StreamValidator>()
                .Configure<StreamSettings>(options =>
                {
                    options.BatchSize = 100;
                    options.MaxConcurrency = 10;
                });
        }
    }
}
```

## Async Initialization Patterns

### IHostedService for Database Initialization

```csharp
namespace Mississippi.EventSourcing.Cosmos
{
    /// <summary>
    /// Hosted service for initializing Cosmos DB containers during application startup.
    /// Demonstrates proper async initialization outside of service registration.
    /// </summary>
    internal sealed class CosmosContainerInitializationService : IHostedService
    {
        private ILogger<CosmosContainerInitializationService> Logger { get; }
        private IOptions<BrookStorageOptions> Options { get; }
        private CosmosClient CosmosClient { get; }
        private Container? _container;

        public CosmosContainerInitializationService(
            ILogger<CosmosContainerInitializationService> logger,
            IOptions<BrookStorageOptions> options,
            CosmosClient cosmosClient)
        {
            Logger = logger;
            Options = options;
            CosmosClient = cosmosClient;
        }

        /// <summary>
        /// Initializes Cosmos DB database and containers asynchronously during startup.
        /// This runs after DI container is built, allowing async operations.
        /// </summary>
        public async Task StartAsync(CancellationToken cancellationToken)
        {
            try
            {
                Logger.CosmosInitializationStarted(Options.Value.DatabaseName);

                // Create database if it doesn't exist
                var databaseResponse = await CosmosClient.CreateDatabaseIfNotExistsAsync(
                    Options.Value.DatabaseName,
                    cancellationToken: cancellationToken);

                var database = databaseResponse.Database;

                // Create containers if auto-creation is enabled
                if (Options.Value.AutoCreateContainers)
                {
                    // Create events container
                    await database.CreateContainerIfNotExistsAsync(
                        Options.Value.EventsContainer,
                        "/partitionKey",
                        cancellationToken: cancellationToken);

                    // Create heads container
                    await database.CreateContainerIfNotExistsAsync(
                        Options.Value.HeadsContainer,
                        "/partitionKey",
                        cancellationToken: cancellationToken);
                }

                // Store container reference for factory
                _container = database.GetContainer(Options.Value.EventsContainer);

                Logger.CosmosInitializationCompleted(Options.Value.DatabaseName);
            }
            catch (Exception ex)
            {
                Logger.CosmosInitializationFailed(Options.Value.DatabaseName, ex);
                throw;
            }
        }

        public Task StopAsync(CancellationToken cancellationToken)
        {
            Logger.CosmosShutdownStarted();
            return Task.CompletedTask;
        }

        /// <summary>
        /// Gets the initialized container. Throws if initialization hasn't completed.
        /// </summary>
        public Container GetContainer()
        {
            return _container ?? throw new InvalidOperationException(
                "Container not initialized. Ensure CosmosContainerInitializationService has started.");
        }
    }

    /// <summary>
    /// Service registration that properly uses hosted service for async initialization.
    /// Registration remains synchronous, async work deferred to hosted service.
    /// </summary>
    public static class ServiceRegistration
    {
        public static IServiceCollection AddCosmosBrookStorageProvider(
            this IServiceCollection services,
            string cosmosConnectionString,
            string blobStorageConnectionString,
            Action<BrookStorageOptions>? configureOptions = null)
        {
            // ✅ GOOD: Synchronous client registration
            services.AddSingleton<CosmosClient>(_ => new CosmosClient(cosmosConnectionString));
            services.AddSingleton<BlobServiceClient>(_ => new BlobServiceClient(blobStorageConnectionString));

            // ✅ GOOD: Register hosted service for async initialization
            services.AddSingleton<CosmosContainerInitializationService>();
            services.AddHostedService<CosmosContainerInitializationService>(provider =>
                provider.GetRequiredService<CosmosContainerInitializationService>());

            // ✅ GOOD: Factory pattern for deferred container access
            services.AddSingleton<Container>(provider =>
            {
                var initService = provider.GetRequiredService<CosmosContainerInitializationService>();
                return initService.GetContainer(); // Will throw if not initialized
            });

            if (configureOptions != null)
            {
                services.Configure(configureOptions);
            }

            return services.AddCosmosBrookStorageProvider();
        }
    }
}
```

### Orleans Lifecycle Participant Pattern

```csharp
namespace Mississippi.EventSourcing.Orleans
{
    /// <summary>
    /// Orleans lifecycle participant for event sourcing initialization.
    /// Demonstrates proper Orleans-specific async initialization.
    /// </summary>
    internal sealed class EventSourcingLifecycleParticipant : ILifecycleParticipant<ISiloLifecycle>
    {
        private ILogger<EventSourcingLifecycleParticipant> Logger { get; }
        private IStreamProvider StreamProvider { get; }

        public EventSourcingLifecycleParticipant(
            ILogger<EventSourcingLifecycleParticipant> logger,
            IStreamProvider streamProvider)
        {
            Logger = logger;
            StreamProvider = streamProvider;
        }

        public void Participate(ISiloLifecycle lifecycle)
        {
            // Register for specific Orleans lifecycle stages
            lifecycle.Subscribe(
                nameof(EventSourcingLifecycleParticipant),
                ServiceLifecycleStage.ApplicationServices,
                OnStart,
                OnStop);
        }

        private async Task OnStart(CancellationToken cancellationToken)
        {
            Logger.EventSourcingInitializationStarted();

            try
            {
                // Perform Orleans-specific async initialization
                await InitializeStreamProvidersAsync(cancellationToken);
                await ValidateGrainConfigurationAsync(cancellationToken);

                Logger.EventSourcingInitializationCompleted();
            }
            catch (Exception ex)
            {
                Logger.EventSourcingInitializationFailed(ex);
                throw;
            }
        }

        private async Task OnStop(CancellationToken cancellationToken)
        {
            Logger.EventSourcingShutdownStarted();
            
            // Cleanup async resources
            await CleanupStreamResourcesAsync(cancellationToken);
            
            Logger.EventSourcingShutdownCompleted();
        }

        private async Task InitializeStreamProvidersAsync(CancellationToken cancellationToken)
        {
            // Orleans-specific async initialization
            var streams = StreamProvider.GetStreamsAsync<string>("EventStream");
            await foreach (var stream in streams.WithCancellation(cancellationToken))
            {
                // Initialize stream subscriptions
            }
        }

        private Task ValidateGrainConfigurationAsync(CancellationToken cancellationToken)
        {
            // Validate Orleans grain configuration
            return Task.CompletedTask;
        }

        private Task CleanupStreamResourcesAsync(CancellationToken cancellationToken)
        {
            // Cleanup stream subscriptions
            return Task.CompletedTask;
        }
    }

    /// <summary>
    /// Orleans silo configuration with lifecycle participant.
    /// </summary>
    public static class OrleansServiceRegistration
    {
        public static ISiloBuilder AddEventSourcing(this ISiloBuilder builder)
        {
            return builder
                .AddMemoryStreams("EventStreamProvider")
                .ConfigureServices(services =>
                {
                    // ✅ GOOD: Register lifecycle participant for Orleans-specific async work
                    services.AddSingleton<EventSourcingLifecycleParticipant>();
                    services.AddSingleton<ILifecycleParticipant<ISiloLifecycle>>(provider =>
                        provider.GetRequiredService<EventSourcingLifecycleParticipant>());
                });
        }
    }
}
```

### Factory Pattern for Deferred Async Operations

```csharp
namespace Mississippi.EventSourcing.Storage
{
    /// <summary>
    /// Factory interface for creating storage connections with async initialization.
    /// </summary>
    public interface IEventStoreConnectionFactory
    {
        Task<IEventStoreConnection> CreateConnectionAsync(CancellationToken cancellationToken = default);
    }

    /// <summary>
    /// Factory implementation that performs async database connection setup.
    /// Defers async operations until first use, not during registration.
    /// </summary>
    internal sealed class EventStoreConnectionFactory : IEventStoreConnectionFactory
    {
        private ILogger<EventStoreConnectionFactory> Logger { get; }
        private IOptions<EventStoreOptions> Options { get; }
        private readonly SemaphoreSlim initializationLock = new(1, 1);
        private IEventStoreConnection? _connection;
        private bool _isInitialized;

        public EventStoreConnectionFactory(
            ILogger<EventStoreConnectionFactory> logger,
            IOptions<EventStoreOptions> options)
        {
            Logger = logger;
            Options = options;
        }

        public async Task<IEventStoreConnection> CreateConnectionAsync(CancellationToken cancellationToken = default)
        {
            if (_isInitialized && _connection != null)
            {
                return _connection;
            }

            await initializationLock.WaitAsync(cancellationToken);
            try
            {
                if (_isInitialized && _connection != null)
                {
                    return _connection;
                }

                Logger.EventStoreConnectionInitializationStarted();

                // ✅ GOOD: Async operations happen here, not during DI registration
                _connection = await CreateConnectionInternalAsync(cancellationToken);
                await _connection.ValidateConnectionAsync(cancellationToken);

                _isInitialized = true;

                Logger.EventStoreConnectionInitializationCompleted();
                return _connection;
            }
            catch (Exception ex)
            {
                Logger.EventStoreConnectionInitializationFailed(ex);
                throw;
            }
            finally
            {
                initializationLock.Release();
            }
        }

        private async Task<IEventStoreConnection> CreateConnectionInternalAsync(CancellationToken cancellationToken)
        {
            // Perform actual async database connection setup
            var connection = new EventStoreConnection(Options.Value.ConnectionString);
            await connection.OpenAsync(cancellationToken);
            return connection;
        }
    }

    /// <summary>
    /// Service registration using factory pattern for deferred async operations.
    /// </summary>
    public static class ServiceRegistration
    {
        public static IServiceCollection AddEventStore(
            this IServiceCollection services,
            string connectionString,
            Action<EventStoreOptions>? configureOptions = null)
        {
            if (configureOptions != null)
            {
                services.Configure(configureOptions);
            }

            // ✅ GOOD: Register factory for deferred async initialization
            services.AddSingleton<IEventStoreConnectionFactory, EventStoreConnectionFactory>();

            // ✅ GOOD: Register service that uses factory
            services.AddScoped<IEventStore>(provider =>
            {
                var factory = provider.GetRequiredService<IEventStoreConnectionFactory>();
                return new EventStore(factory, provider.GetRequiredService<ILogger<EventStore>>());
            });

            return services;
        }
    }
}
```

## Configuration Patterns

### appsettings.json Configuration

```json
{
  "BrookStorage": {
    "DatabaseName": "EventStore",
    "EventsContainer": "Events",
    "HeadsContainer": "Heads",
    "MaxBatchSize": 100,
    "RequestTimeoutSeconds": 30,
    "MaxRetryAttempts": 3,
    "AutoCreateContainers": true
  },
  "ConnectionStrings": {
    "CosmosDb": "AccountEndpoint=https://...",
    "BlobStorage": "DefaultEndpointsProtocol=https;..."
  }
}
```

### Usage Patterns

```csharp
namespace SampleApplication
{
    public static class Program
    {
        public static void Main(string[] args)
        {
            var services = new ServiceCollection();
            var configuration = new ConfigurationBuilder().Build();

            // Pattern 1: Connection strings with optional configuration
            services.AddCosmosBrookStorageProvider(
                "cosmos-connection-string",
                "blob-storage-connection-string",
                options =>
                {
                    options.DatabaseName = "MyEventStore";
                    options.MaxBatchSize = 200;
                    options.RequestTimeoutSeconds = 60;
                });

            // Pattern 2: Configuration action only (connection strings configured elsewhere)
            services.AddCosmosBrookStorageProvider(options =>
            {
                options.EventsContainer = "CustomEvents";
                options.HeadsContainer = "CustomHeads";
                options.AutoCreateContainers = false;
            });

            // Pattern 3: IConfiguration binding (appsettings.json)
            services.AddCosmosBrookStorageProvider(
                configuration.GetSection("BrookStorage"));

            // Pattern 4: With validation for production scenarios
            services.AddCosmosBrookStorageProviderWithValidation(
                "cosmos-connection-string",
                "blob-storage-connection-string",
                options =>
                {
                    options.DatabaseName = "ProductionEventStore";
                    options.MaxRetryAttempts = 5;
                });
        }
    }
}
```

## Anti-Patterns to Avoid

### Async Operations Anti-Patterns

```csharp
// ❌ BAD - Async operations during service registration
public static class BadAsyncServiceRegistration
{
    // NEVER DO THIS - Service registration must be synchronous
    public static async Task<IServiceCollection> AddEventSourcingBadAsync(this IServiceCollection services)
    {
        // ❌ WRONG: Async operations in registration method
        var cosmosClient = new CosmosClient("connection-string");
        await cosmosClient.CreateDatabaseIfNotExistsAsync("EventStore"); // Blocks DI setup!
        
        services.AddSingleton(cosmosClient);
        return services;
    }
    
    // NEVER DO THIS - Database calls during registration
    public static IServiceCollection AddEventSourcingWithDatabaseCheck(this IServiceCollection services)
    {
        // ❌ WRONG: Synchronous database calls that can block startup
        var connectionString = "connection-string";
        using var connection = new SqlConnection(connectionString);
        connection.Open(); // Can fail and blocks entire application startup!
        
        // Check if database exists
        var command = new SqlCommand("SELECT 1", connection);
        command.ExecuteScalar(); // Blocks DI container building!
        
        services.AddScoped<IEventStore>(_ => new EventStore(connectionString));
        return services;
    }
    
    // NEVER DO THIS - HTTP calls during registration
    public static IServiceCollection AddExternalServiceWithValidation(this IServiceCollection services)
    {
        // ❌ WRONG: HTTP calls during registration
        using var httpClient = new HttpClient();
        var response = httpClient.GetAsync("https://api.external.com/health").Result; // Blocks!
        
        if (!response.IsSuccessStatusCode)
        {
            throw new Exception("External service not available"); // Fails app startup
        }
        
        services.AddHttpClient<IExternalService, ExternalService>();
        return services;
    }
}

// ❌ BAD - Factory that performs async work synchronously
public static class BadSynchronousFactory
{
    public static IServiceCollection AddEventStore(this IServiceCollection services)
    {
        services.AddSingleton<IEventStore>(provider =>
        {
            var logger = provider.GetRequiredService<ILogger<EventStore>>();
            
            // ❌ WRONG: .Result or .Wait() on async operations
            var connection = CreateConnectionAsync().Result; // Deadlock risk!
            return new EventStore(connection, logger);
        });
        
        return services;
    }
    
    private static async Task<IDbConnection> CreateConnectionAsync()
    {
        var connection = new SqlConnection("connection-string");
        await connection.OpenAsync(); // This gets blocked by .Result above
        return connection;
    }
}

// ✅ GOOD - Proper patterns for async initialization
public static class GoodAsyncPatterns
{
    // ✅ GOOD: Register hosted service for async work
    public static IServiceCollection AddEventSourcing(this IServiceCollection services)
    {
        // Synchronous registration only
        services.AddSingleton<CosmosClient>(_ => new CosmosClient("connection-string"));
        
        // Async work delegated to hosted service
        services.AddSingleton<DatabaseInitializationService>();
        services.AddHostedService<DatabaseInitializationService>(provider =>
            provider.GetRequiredService<DatabaseInitializationService>());
        
        // Factory for deferred async operations
        services.AddScoped<IEventStore>(provider =>
        {
            var factory = provider.GetRequiredService<IEventStoreConnectionFactory>();
            return new EventStore(factory, provider.GetRequiredService<ILogger<EventStore>>());
        });
        
        return services;
    }
    
    // ✅ GOOD: Orleans lifecycle participant for Orleans-specific async work
    public static ISiloBuilder AddEventSourcing(this ISiloBuilder builder)
    {
        return builder.ConfigureServices(services =>
        {
            // Synchronous registration
            services.AddSingleton<EventSourcingLifecycleParticipant>();
            services.AddSingleton<ILifecycleParticipant<ISiloLifecycle>>(provider =>
                provider.GetRequiredService<EventSourcingLifecycleParticipant>());
        });
    }
    
    // ✅ GOOD: Configuration validation without async operations
    public static IServiceCollection AddEventSourcingWithValidation(this IServiceCollection services)
    {
        services.AddOptions<EventSourcingOptions>()
            .Validate(options => !string.IsNullOrEmpty(options.ConnectionString))
            .ValidateOnStart(); // Validates synchronously at startup
        
        return services;
    }
}
```

### Service Registration Anti-Patterns

```csharp
// ❌ BAD - Monolithic registration file
public static class AllServiceRegistrations  // Violates feature separation
{
    public static IServiceCollection AddEverything(this IServiceCollection services)
    {
        // 200+ lines of unrelated service registrations
        services.AddScoped<IOrderService, OrderService>();
        services.AddScoped<IInventoryService, InventoryService>();
        services.AddScoped<IEmailService, EmailService>();
        services.AddScoped<IEventStore, EventStore>();
        services.AddScoped<IBatchProcessor, BatchProcessor>();
        // ... many more unrelated services
        return services;
    }
}

// ❌ BAD - Wrong access levels
public static class InternalServiceRegistration
{
    // Wrong: Implementation detail exposed as public
    public static IServiceCollection AddBatching(this IServiceCollection services)
    {
        return services.AddScoped<IBatchProcessor, BatchProcessor>();
    }
}

// ❌ BAD - Non-hierarchical registration
public static class EventSourcingRegistration
{
    public static IServiceCollection AddEventSourcing(this IServiceCollection services)
    {
        // Wrong: Manually registering all sub-components instead of calling child registrations
        services.AddScoped<IStreamProcessor, StreamProcessor>();
        services.AddScoped<IBatchProcessor, BatchProcessor>();
        services.AddScoped<IEventStore, EventStore>();
        return services;
    }
}

// ❌ BAD - Wrong naming convention
public static class EventSourcingServices  // Should be "ServiceRegistration"
{
    public static IServiceCollection RegisterEventSourcing(...)  // Should be "AddEventSourcing"
    {
        return services;
    }
}
```

### Configuration Anti-Patterns

```csharp
// ❌ BAD - Direct configuration parameters in constructors
public class BadEventStore
{
    public BadEventStore(
        string cosmosConnectionString,    // Should use IOptions<T>
        string databaseName,              // Should use IOptions<T>  
        int maxRetryAttempts,            // Should use IOptions<T>
        bool autoCreateContainers)       // Should use IOptions<T>
    {
        // Wrong: Direct parameter injection instead of Options pattern
    }
}

// ❌ BAD - Hard-coded configuration values
public class BadStorageProvider
{
    private const string DatabaseName = "EventStore";        // Should be configurable
    private const int MaxBatchSize = 100;                   // Should be configurable
    private const string ConnectionString = "hardcoded";     // Major security issue
}

// ❌ BAD - Wrong Options pattern usage
public class BadOptionsConsumer
{
    private readonly MyOptions _options; // Should be IOptions<MyOptions>
    
    public BadOptionsConsumer(MyOptions options) // Wrong: Direct options injection
    {
        _options = options;
    }
}

// ✅ GOOD - Proper Options pattern with dependency injection properties
internal sealed class EventStore : IEventStore
{
    // Following mandatory dependency injection property pattern
    private ILogger<EventStore> Logger { get; }
    private IOptions<EventStoreOptions> Options { get; }
    private CosmosClient CosmosClient { get; }
    
    public EventStore(
        ILogger<EventStore> logger,
        IOptions<EventStoreOptions> options,    // Correct: IOptions<T> injection
        CosmosClient cosmosClient)
    {
        Logger = logger;
        Options = options;
        CosmosClient = cosmosClient;
    }
    
    public async Task StoreEventAsync(DomainEvent domainEvent)
    {
        // Access configuration through Options.Value
        var database = CosmosClient.GetDatabase(Options.Value.DatabaseName);
        var batchSize = Options.Value.MaxBatchSize;
        
        Logger.EventStoreOperationStarted(domainEvent.Id, batchSize);
        // Implementation using configured values
    }
}
```

## Enforcement

These service registration standards should be enforced through:

1. **Code Reviews**: Always verify adherence to hierarchical registration patterns, access control decisions, configuration handling, and synchronous registration requirements
2. **Static Analysis**: Use .NET analyzers and treat warnings as errors, especially for access modifier violations and async operation detection in registration methods
3. **Unit Tests**: Maintain high test coverage and quality for service registration methods, configuration validation, and hosted service initialization
4. **Build Pipeline**: Fail builds on quality gate violations, including improper access control, missing configuration support, and async operations in registration
5. **Documentation**: Keep these guidelines updated with examples, especially for async initialization patterns and Orleans lifecycle participation
6. **Configuration Validation**: Ensure all Options classes include validation and fail-fast startup checks
7. **Service Registration Reviews**: Verify all registration methods are synchronous and follow the private core + public overloads pattern with proper configuration support
8. **Async Pattern Reviews**: Ensure all async initialization uses IHostedService, Orleans lifecycle participants, or factory patterns - never inline in registration methods
9. **Orleans Integration Reviews**: Verify Orleans-specific async work uses lifecycle participants and proper service lifecycle stages

## Related Guidelines

This document should be read in conjunction with:

- **C# General Development Best Practices** (`.github/instructions/csharp.instructions.md`) - For SOLID principles, dependency injection patterns, and access control principles
- **Logging Rules** (`.github/instructions/logging-rules.instructions.md`) - For high-performance logging patterns, LoggerExtensions classes, and mandatory ILogger usage with dependency injection properties
- **Orleans Best Practices** (`.github/instructions/orleans.instructions.md`) - For Orleans-specific grain development patterns, POCO grain requirements, and IGrainBase implementation with sealed classes
- **Build Rules** (`.github/instructions/build-rules.instructions.md`) - For quality standards, zero warnings policy, and build pipeline requirements that enforce access control analyzer rules
- **Naming Conventions** (`.github/instructions/naming.instructions.md`) - For ServiceRegistration class naming patterns, feature-based namespace structure, and XML documentation requirements for public members
- **Project File Management** (`.github/instructions/projects.instructions.md`) - For proper PackageReference usage and centralized package management

### Cross-Reference Alignment

- **Service Registration + C# Access Control**: ServiceRegistration classes must follow access control principles with sealed classes and minimal exposure
- **Service Registration + Naming**: ServiceRegistration classes must follow `public static class ServiceRegistration` naming with `Add{FeatureName}()` method patterns
- **Service Registration + Build Rules**: Registration methods must maintain zero warnings and pass analyzer checks for access control violations
- **Service Registration + Orleans**: All Orleans grains registered must follow POCO pattern with IGrainBase and sealed classes; async initialization must use Orleans lifecycle participants
- **Service Registration + Logging**: All hosted services and lifecycle participants must use LoggerExtensions pattern for async initialization logging
- **Configuration + Options Pattern**: All configuration must use `IOptions<T>` pattern with dependency injection properties following `private IOptions<T> Name { get; }` pattern
- **Configuration + Logging**: All options validation failures must be logged using LoggerExtensions pattern with proper correlation IDs
- **Configuration + Build Rules**: Options classes must include validation rules that fail fast at startup, enforced through build pipeline
- **Configuration + Naming**: Options classes must follow `{FeatureName}Options` naming pattern with XML documentation for all properties
- **Async Initialization + Orleans**: Orleans-specific async work must use `ILifecycleParticipant<ISiloLifecycle>` with appropriate service lifecycle stages
- **Async Initialization + Hosting**: Non-Orleans async work must use `IHostedService` pattern with proper startup/shutdown lifecycle management
- **Factory Patterns + Dependency Injection**: All factories must follow dependency injection property pattern and use proper thread-safe initialization

## Further Reading

- .NET dependency injection: [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)
- Options pattern in .NET: [https://learn.microsoft.com/en-us/dotnet/core/extensions/options](https://learn.microsoft.com/en-us/dotnet/core/extensions/options)
- Configuration in .NET: [https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration](https://learn.microsoft.com/en-us/dotnet/core/extensions/configuration)
- Extension methods: [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods)
- IHostedService background tasks: [https://learn.microsoft.com/en-us/dotnet/core/extensions/hosted-services](https://learn.microsoft.com/en-us/dotnet/core/extensions/hosted-services)
- Orleans lifecycle management: [https://learn.microsoft.com/en-us/dotnet/orleans/implementation/grain-lifecycle](https://learn.microsoft.com/en-us/dotnet/orleans/implementation/grain-lifecycle)
- Orleans startup tasks: [https://learn.microsoft.com/en-us/dotnet/orleans/implementation/startup-tasks](https://learn.microsoft.com/en-us/dotnet/orleans/implementation/startup-tasks)
- Factory pattern in .NET: [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines#factory-pattern](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection-guidelines#factory-pattern)
