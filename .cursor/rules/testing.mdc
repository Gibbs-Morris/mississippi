---
description: Testing Strategy and Quality Gates
alwaysApply: true
---
// sync: source 6 MD:.github/instructions/testing.instructions.md ; synced: 2025-08-24 ; commit: be73e40
# Testing Strategy and Quality Gates
**Source:** .github/instructions/testing.instructions.md
**Last synced:** 2025-08-24


# Testing Strategy and Quality Gates

This document defines the Mississippi repository’s testing strategy and expectations. It complements the Build Rules and Quality Standards and clarifies how tests are organized, named, and executed across CI.

We use an L0–L4 layered testing model to keep feedback fast while ensuring end-to-end confidence.

## Test Levels at a Glance

| Level  | Description                                                                    | Dependencies                                         | Where It Runs                                                                                 |
| ------ | ------------------------------------------------------------------------------ | ---------------------------------------------------- | --------------------------------------------------------------------------------------------- |
| **L0** | Pure unit tests — in‑memory, blazing‑fast                                      | Assembly-only, no external state                     | Inline with dev and PR builds (Microsoft Learn [1], Microsoft for Developers [2])             |
| **L1** | Slightly richer unit tests — may involve SQL, file system, minimal infra       | Code + lightweight environment                       | Still run early, often in CI (Microsoft for Developers [2], Microsoft Learn [3])              |
| **L2** | Functional tests against test deployments — with key stubs/mocks               | Deployed services, with mocks for heavy dependencies | Typically in daily rolling CI pipelines (Microsoft for Developers [2], Microsoft Learn [3])   |
| **L3** | End-to-end tests against production-like instances — real UI flows, full stack | Production-like deployment, often UI-driven          | Triggered per release or as “test in prod” (Microsoft for Developers [2])                     |
| **L4** | Restricted integration tests in production — synthetic checks/smoke paths      | Fully deployed system in true production             | Final gatekeeper before or after deployment (Microsoft Learn [3])                             |

[1]: https://learn.microsoft.com/en-us/answers/questions/28698/azure-datacenter-tier-certification?utm_source=chatgpt.com
[2]: https://devblogs.microsoft.com/bharry/testing-in-a-cloud-delivery-cadence/?utm_source=chatgpt.com
[3]: https://learn.microsoft.com/en-us/devops/develop/shift-left-make-testing-fast-reliable?utm_source=chatgpt.com

## Test Project Conventions

These conventions match `Directory.Build.props` so analyzers, InternalsVisibleTo, and tooling work consistently:

- Project name suffixes: use one project per level when appropriate
  - `<Product>.<Feature>.L0Tests`
  - `<Product>.<Feature>.L1Tests`
  - `<Product>.<Feature>.L2Tests`
  - `<Product>.<Feature>.L3Tests`
  - `<Product>.<Feature>.L4Tests`
  - Legacy naming: generic `<…>.Tests`, `<…>.UnitTests`, and `<…>.IntegrationTests` are supported for compatibility but should be migrated to L0–L4 naming over time
  - Prefer per-level projects for clarity and analyzer consistency; migrate legacy projects when touched
- Any project ending with `Tests` is treated as a test project and pulls common test packages (xUnit, runner, coverlet, Allure, Moq)
- InternalsVisibleTo is already configured for `.Tests`, `.UnitTests`, `.IntegrationTests`, and `.L0Tests` … `.L4Tests` so tests can exercise internal members safely
- Target framework, analyzers, and zero-warnings policy apply to test projects as well

## Frameworks and Tools

- Unit testing: xUnit (Microsoft.NET.Test.Sdk + xunit.runner.visualstudio)
- Mocking: Moq
- Coverage: coverlet.collector (collected in CI)
- Reporting: Allure.Xunit (optional annotations/labels)
- UI and API journeys: Playwright (used primarily at L3; optionally at L2 for API flows)
- Mutation testing: Stryker.NET (Mississippi solution only)

## Coverage and Mutation Targets

- Coverage
  - Aim for 100% unit test coverage on new and changed code paths
  - Absolute minimum: 80% lines/branches for Mississippi projects (SonarCloud gate); target 95–100% where technically feasible
  - No coverage regressions: touched files should not decrease in coverage
- Mutation testing
  - Run Stryker.NET for Mississippi projects; keep or raise the mutation score
  - Default thresholds align with repository `stryker-config.json`: high 90, low 80, break 80; avoid score regressions on changed areas
  - Treat surviving mutants as defects in test quality and address them; prefer targeted tests over muting/ignoring

## Level Details and Guardrails

### L0 — Pure unit tests
- Scope: business logic, pure functions, orchestration seams; no I/O, no timers sleeping, no network
- Dependencies: in-memory only; replace collaborators with test doubles/mocks
- Speed: sub-50ms typical per test; designed for PR and local tight loops
- Runs: always in PR builds for the Mississippi solution; subject to mutation testing requirements
- Requirements:
  - Deterministic, no wall-clock sleeps; prefer fake clocks and injected time sources
  - No file system, no environment variables, no network; constructor-only DI seams
  - Prefer records/immutability friendly patterns from C# guidelines

### L1 — Unit/component with light infra
- Scope: still “unit-level” but may touch minimal infra: local file system, in-proc databases, mock HTTP handlers
- Dependencies: ephemeral and isolated per test; use temp directories and in-memory or containerized dev DBs spun up per run
- Runs: included in CI for early signal; keep fast and parallel-safe
- Requirements:
  - No cross-test interference; isolate state and ports
  - Bound execution time; avoid flakiness; prefer fakes/spies over real cloud services
  - Keep external processes optional so the suite remains reliable on dev and CI agents

### L2 — Functional against test deployments
- Scope: validate feature slices against deployed test environments; mock or stub heavy/expensive dependencies
- Dependencies: test deployment URL(s), seeded test data, controlled mocks for third-party systems
- Runs: scheduled or on-demand pipelines (not required for every PR)
- Requirements:
  - Idempotent and self-cleaning; avoid global state
  - Parallelizable where possible; shard by feature
  - Clear diagnostics and assertions that align with logging rules

### L3 — End-to-end in prod-like
- Scope: real user flows, cross-service and UI journeys using Playwright; full stack with real storage and messaging
- Dependencies: prod-like environment with realistic configuration
- Runs: per release or as “test in prod” prior to broad exposure
- Requirements:
  - Use Playwright for UI and API request flows; prefer resilient selectors and stable routes over brittle timing
  - Tag with scenarios and components for reporting (Allure labels optional)
  - Capture traces/screenshots/video on failure for triage

### L4 — Restricted checks in production
- Scope: synthetic monitoring and gated smoke tests that run safely in production (read-only or harmless writes)
- Dependencies: live endpoints and observability hooks
- Runs: immediately post-deploy and/or continuously on a cadence
- Requirements:
  - Strictly non-destructive; use dedicated synthetic accounts/resources
  - Tight timeouts and clear rollback signals
  - Align with SLO/SLA dashboards for alerting

## Where Tests Live

- Mississippi solution (core libraries): emphasize L0 (required) and L1 (selectively). Mutation testing applies here per Build Rules.
- Samples solution (apps + examples): include L0/L1 examples only; mutation testing is not required.
- L2/L3/L4 projects may live under `tests/` or `samples/` as dedicated test applications; wire them into scheduled CI rather than PR gates.

## Patterns and Practices

- xUnit
  - Prefer method naming: `MethodName_Should_Outcome_GivenCondition`
  - Use `Theory` + inline/member data for input spaces
  - Use `IClassFixture`/`CollectionDefinition` to manage shared expensive setup without test interdependence
  - Async all the way; no `.Result`/`.Wait()`; time-bound operations with cancellation tokens
- Mocks/Fakes
  - Default to simple fakes or hand-rolled stubs at L0; use Moq where interaction verification matters
  - Verify behavior and state; avoid over-specifying interactions
- File system and time
  - Use temp directories via the test framework; ensure cleanup
  - Inject clocks and random sources; avoid `DateTime.UtcNow`/`new Random()` in code under test
- Playwright (L3, optionally L2)
  - Keep selectors resilient (data-test-id over CSS classes)
  - Use APIRequestContext for API-level flows; avoid UI when API suffices
  - Capture artifacts (trace/screenshots) on failure; close contexts reliably

## CI Expectations and Quality Gates

- Zero warnings policy applies to tests; treat analyzer violations as build blockers
- PR gates: L0 (required) and L1 (where present) for Mississippi; Samples keep minimal, illustrative tests
- Coverage: collected via coverlet; aim 100%, minimum 80% on Mississippi projects (target 95–100%); no regressions on touched code
- Mutation testing: Mississippi solution only via Stryker.NET; keep or raise mutation score when touching logic; fix surviving mutants

## Tooling and Scripts

Use the PowerShell scripts documented in Build Rules to run tests and mutation checks:
- `scripts/unit-test-mississippi-solution.ps1`
- `scripts/unit-test-sample-solution.ps1`
- `scripts/mutation-test-mississippi-solution.ps1`
- `scripts/orchestrate-solutions.ps1` (also via `./go.ps1`)

## Author and Reviewer Checklists

Author
- [ ] Added/updated L0 tests for all new or changed logic
- [ ] Considered L1 tests when infra seams are involved
- [ ] Tests are deterministic, isolated, and fast
- [ ] Assertions cover behavior and edge cases; no sleeps or time flakiness
- [ ] For UI/API journeys, added Playwright tests at L3 (or L2 API flows) where valuable
- [ ] Coverage meets goals (target 100%, minimum 80%; aim 95–100%); no regressions on touched code
- [ ] Mutation score maintained or improved; surviving mutants addressed or justified

Reviewer
- [ ] L0 present for core logic; L1 used judiciously
- [ ] No external calls in L0; minimal, isolated infra in L1
- [ ] Tests follow naming, async, and DI seam patterns
- [ ] Coverage target met (≥80%, aiming for 95–100%) with no regressions on touched files
- [ ] Mutation score non-regression; surviving mutants handled appropriately
- [ ] Playwright usage is resilient and artifacts are captured on failure

## Non-Goals and Clarifications

- Do not promote heavyweight, slow tests into PR gates; keep PR feedback fast
- Prefer moving complex E2E checks to L3 with Playwright rather than bloating L1/L2
- Samples are examples: they demonstrate testing patterns but aren’t subject to mutation testing

---

This guidance aligns with Build Rules and Quality Standards and with repository-wide analyzers and conventions. Use it with the C#, Logging, Orleans, and Project instructions to keep tests reliable and fast.

## Related Guidelines

This document should be read in conjunction with:

- **Build Rules and Quality Standards** (`.github/instructions/build-rules.instructions.md`) - For zero-warnings policy, CI gates, and mutation testing enforcement
- **C# General Development Best Practices** (`.github/instructions/csharp.instructions.md`) - For testability patterns, DI seams, and immutability
- **Logging Rules** (`.github/instructions/logging-rules.instructions.md`) - For LoggerExtensions usage and structured logging in tests and testable code
- **Orleans Best Practices** (`.github/instructions/orleans.instructions.md`) - For Orleans-safe patterns that influence test design (no blocking, DI seams)
- **Orleans Serialization** (`.github/instructions/orleans-serialization.instructions.md`) - For serializer patterns and analyzer compliance that affect tests
- **Project File Management** (`.github/instructions/projects.instructions.md`) - For automatic test project configuration and centralized package management

<!-- sync: excluded ; justification: no corresponding testing.mdc rule file; synced: 2025-08-24 ; commit: {short-sha} -->
