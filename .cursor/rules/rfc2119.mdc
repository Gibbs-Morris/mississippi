---
description: RFC 2119 Keyword Usage for Instruction Authors
globs: ["**/*.instructions.md,.github/copilot-instructions.md,agents.md"]
alwaysApply: false
---
# RFC 2119 Keyword Usage for Instruction Authors
**Source:** .github/instructions/rfc2119.instructions.md


# RFC 2119 Keyword Usage for Instruction Authors

Governing thought: Centralize and use RFC 2119 keywords consistently so instruction files express mandatory vs optional behavior unambiguously for humans and automation.

## Rules (RFC 2119)

- Authors **MUST** use RFC 2119 keywords only to set normative requirements; otherwise, authors **SHOULD** prefer plain descriptive prose. Why: Keeps rules unambiguous and reduces accidental “policy by example.”
- RFC 2119 keywords **MUST** appear in UPPERCASE (`MUST`, `MUST NOT`, `SHOULD`, `SHOULD NOT`, `MAY`, plus synonyms `REQUIRED`, `SHALL`, `SHALL NOT`). Why: Signals normative weight to readers and tooling.
- Each instruction file **MUST** keep all normative statements consolidated in a single “Rules (RFC 2119)” section near the top. Why: Improves discoverability and enables automated parsing.
- RFC 2119 keywords **SHOULD NOT** appear outside the Rules section, except when quoting standards or in clearly explanatory, non‑normative examples. Why: Prevents stray or conflicting requirements.
- Every normative bullet **MUST** include one requirement per sentence and **MUST** include a brief “Why” rationale line when not obvious. Why: Avoids chained/conflicting rules and clarifies intent.
- Instruction files **MUST** include YAML front matter with an `applyTo` directive and **MUST** start with an H1 title and a one‑sentence governing thought. Why: Aligns with the repository template for agents and reviewers.
- Instruction files **MUST** include a short Drift check note near the top reminding readers that referenced scripts remain authoritative. Why: Prevents divergence from automation.
- When exceptions are realistic, authors **SHOULD** prefer `SHOULD`/`SHOULD NOT`; otherwise default to `MUST`/`MUST NOT`. Why: Matches enforcement strength to reality.
- For any requirement, authors **MUST** scope the audience explicitly (e.g., “Agents…”, “Scripts…”, “Reviewers…”). Why: Reduces misinterpretation.
- Conflicting requirement levels across files **MUST NOT** exist; authors **MUST** resolve conflicts before merging. Why: Prevents policy drift.

## Scope and Audience

Applies to everyone authoring or reviewing `*.instructions.md` and related repository rule files (including `.github/copilot-instructions.md` and `agents.md`).

## At-a-Glance Quick-Start

- Use RFC 2119 keywords only for normative requirements; keep other prose descriptive.
- Write keywords in uppercase; place all requirements in the Rules section.
- Add a one‑line “Why” to each rule; scope the audience; document precise exceptions.

> Drift check: When examples reference repository scripts, treat the scripts as the source of truth; open them before citing usage or outputs.

## Core Principles and Rationale

- Shared vocabulary enables consistent, enforceable requirements across files.
- Centralizing rules improves readability and supports automated checks by tools (Copilot, Cursor, custom linters).
- Clear rationale prevents accidental weakening or misapplication of policies.

## Procedures

### Writing a new normative rule

1. Draft a single‑sentence requirement using an RFC 2119 keyword in uppercase.
2. Add a brief “Why” line immediately after when not obvious.
3. Scope the audience (“Agents”, “Authors”, “Scripts”).
4. Place the rule in the file’s Rules section; remove duplicate/stray normative text elsewhere.
5. If an exception exists, describe exact conditions rather than softening the keyword.

**Why:** Produces precise, machine‑parsable requirements without ambiguity.

### Reviewing instruction files

1. Confirm the file has front matter, H1, governing thought, and a consolidated Rules section.
2. Verify all RFC 2119 keywords are in the Rules section (or quoted in examples).
3. Check each rule has one requirement per sentence and an appropriate “Why.”
4. Ensure no conflicting requirement levels across related files; request resolution if found.

**Why:** Keeps documents conformant to the template and prevents policy drift.

## Examples

Example rule bullets (illustrative):

```markdown
- Agents MUST run `pwsh ./go.ps1` before marking a fix complete.  
  Why: This script orchestrates every build/test gate and catches regressions.
- Test authors SHOULD add mutation tests when touching Mississippi projects.  
  Why: Mutation score enforces assertion quality without over‑constraining Samples.
- Instruction updates MAY include diagrams when they clarify complex flows.
```

### Keyword meanings (reference)

| Keyword | Meaning in this repository |
| --- | --- |
| **MUST / REQUIRED / SHALL** | Absolute requirement; no deviation permitted. |
| **MUST NOT / SHALL NOT** | Absolute prohibition. |
| **SHOULD / RECOMMENDED** | Strong recommendation; rare, well‑documented exceptions may apply. |
| **SHOULD NOT / NOT RECOMMENDED** | Strong advice against; exceptions must be explicitly justified. |
| **MAY / OPTIONAL** | Truly optional; acceptable when omitted. |

> Treat `REQUIRED` and `SHALL` as synonyms for `MUST`, and `SHALL NOT` as a synonym for `MUST NOT`. Use the form that reads best.

## Anti-Patterns

- ❌ Using lowercase (“must”, “should”) — automation may not recognize normative intent.
- ❌ Chaining multiple requirements in one sentence — split into separate bullets.
- ❌ Downgrading a `MUST` to `SHOULD` to avoid work — document a precise exception instead.
- ❌ Sprinkling RFC keywords into narrative or marketing text — keep them in Rules or examples only.
- ❌ Omitting rationale — without “Why,” reviewers cannot judge keyword strength.

## External References

- RFC 2119 (Key words for use in RFCs to Indicate Requirement Levels): <https://www.rfc-editor.org/rfc/rfc2119>
- Instruction Authoring Guide: ./.github/instructions/authoring.instructions.md
