---
description: Abstractions Projects Instructions
alwaysApply: true
---
# Abstractions Projects Instructions
**Source:** .github/instructions/abstractions-projects.instructions.md


# Abstractions Projects Instructions

Governing thought: Split long-lived contracts into dedicated `*.Abstractions` assemblies so consumers depend only on stable interfaces.

## Rules (RFC 2119)

- `*.Abstractions` projects **MUST** contain only public contracts (interfaces, abstract bases, DTOs, domain exceptions, CQRS requests); no infrastructure, DI, hosting, or persistence helpers. Implementations **MUST** stay in the main library, which **MUST** reference its abstractions; abstractions **MUST NOT** depend on implementations. Consumers **SHOULD** reference abstractions unless they need the default implementation.
- When all mandatory triggers apply (cross-assembly/service contracts, multiple implementations present/expected, stable public API) and no abstractions project exists, contributors **MUST** create `<Name>.Abstractions` before changing the contracts. When optional triggers apply (dependency minimization, testing/mocking, reuse, versioning flexibility), creation **SHOULD** happen unless a deliberate tighter coupling decision is documented.
- Types describing *what* a component does **SHOULD** live in abstractions; types describing *how* it works **MUST** stay in the main project. Naming **SHOULD** follow `{Vendor}.{Area}[.{Feature}].Abstractions`.

## Quick Start

- Evaluate triggers, scaffold `<Product>.<Feature>.Abstractions` when required, keep dependencies minimal.
- Reference abstractions from the main project; keep implementations, storage, and DI extensions in the main assembly.

## Review Checklist

- [ ] Contracts only in `*.Abstractions`; infrastructure kept in main assembly.
- [ ] Mandatory/optional triggers considered; abstractions project created when required.
- [ ] Naming and references follow the abstractions pattern.
