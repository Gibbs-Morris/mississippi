---
description: Test Improvement Workflow (Legacy/Non‚ÄëTDD Code)
alwaysApply: true
---
# Test Improvement Workflow (Legacy/Non‚ÄëTDD Code)
**Source:** .github/instructions/test-improvement.instructions.md


# Test Improvement Workflow (Legacy/Non‚ÄëTDD Code)

This guide defines a practical, repeatable loop to raise unit test coverage and mutation score on projects that were not originally written with TDD. It complements the broader Testing and Build Rules documents and provides exact commands using `scripts/test-project-quality.ps1`.

> **Drift check:** Before running any PowerShell script referenced here, open the script in `scripts/` (or the specified path) to confirm its current behavior matches this guidance. Treat this document as best-effort context‚Äîthe scripts remain the source of truth for step ordering and options.

## At-a-Glance Improvement Loop

1) Prepare tools once.

```powershell
pwsh -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "dotnet tool restore"
```

2) Establish baseline (tests + coverage only), then add tests to reach target coverage.

```powershell
pwsh ./scripts/test-project-quality.ps1 -TestProject <YourTestProject> -SkipMutation
```

3) Build-only check anytime to surface warnings/errors.

```powershell
dotnet build ./tests/<YourTestProject>/<YourTestProject>.csproj -c Release -warnaserror
```

4) Add mutation testing; improve assertions/branches until threshold is met (Mississippi only).

```powershell
pwsh ./scripts/test-project-quality.ps1 -TestProject <YourTestProject>
```

5) Iterate quickly using `-NoBuild` after the initial build, but keep separate build checks for zero‚Äëwarnings.

## Read This First

- Read all `.github/instructions/*.instructions.md` files before making changes so your approach aligns with repository-wide standards.
- Cross‚Äëreference:
  - `.github/instructions/testing.instructions.md`
  - `.github/instructions/build-rules.instructions.md`

## Guardrails

- Do not edit anything outside of the `tests/` folder during this workflow unless explicitly approved. Assume production code is correct until tests demonstrate a defect. If you believe production changes are required, pause and request confirmation first.

- For gaps that require parallel attention (coverage hot spots, mutation survivors), create small, discrete tasks in `.scratchpad/tasks/pending` so agents can claim and close them deterministically (see `.github/instructions/agent-scratchpad.instructions.md`). The scratchpad is ephemeral and ignored by Git; never reference it from source or tests.

## üö® CRITICAL RULE: ZERO WARNINGS IN TESTS üö®

**‚ö†Ô∏è ATTENTION: Zero warnings policy applies to test code too! ‚ö†Ô∏è**

### The Rule for Test Code

- **NEVER disable warnings in test files** - Test code must meet the same quality standards as production code
- **NEVER suppress analyzer rules in tests** - Test code should be exemplary and follow all best practices
- **NEVER use `#pragma warning disable` in tests** - If you need to suppress a warning in tests, the test design is wrong
- **ALWAYS fix test code warnings** - Test code should demonstrate proper patterns and practices
- **Maintain analyzer and StyleCop cleanliness in tests** - Zero warnings policy applies everywhere
- **Zero new warnings/errors** - Do not introduce any new compiler, analyzer, StyleCop, or ReSharper warnings or errors during this loop. Fix any newly introduced issues immediately before proceeding.

### Why Test Code Quality Matters

- **Tests are documentation** - They show how to use your code correctly
- **Tests demonstrate patterns** - They should exemplify best practices
- **Test code is production code** - It runs in CI and affects build quality
- **Poor test code creates technical debt** - Just like poor production code

## Targets (per Build/Testing rules)

- Coverage: default target 95% unless otherwise specified. Absolute minimum remains 80% per Testing rules; aim for 100% on changed code paths with no regressions.
- Mutation score: default target 80% unless otherwise specified (Samples are exempt from mutation testing; see Testing rules).
- Flexibility: If a task sets explicit targets (e.g., 100% or 95%), follow those. Some legacy code may be difficult to unit‚Äëtest without refactoring; document constraints and request approval before proposing production changes.

## Script Overview: `scripts/test-project-quality.ps1`

Parameters:

- `-TestProject <Name|Path>`: Test project name (e.g., `Core.Tests`) or a direct path to the test `.csproj` (or its directory).
- `-SkipMutation`: Skip Stryker mutation testing for faster loops.
- `-SourceProject <path>`: Manually point to the source `.csproj` when inference from `<ProjectReference>` is ambiguous.
- `-Configuration Release` (default) and `-NoBuild` for faster re‚Äëruns once built.

Notes:

- The script runs `dotnet test`, which builds the test project by default. If you pass `-NoBuild`, run an explicit `dotnet build` to surface any new warnings/errors as part of the zero‚Äënew‚Äëwarnings policy.

Outputs (machine‚Äëreadable): `RESULT`, `TEST_TOTAL`, `TEST_PASSED`, `TEST_FAILED`, `TEST_SKIPPED`, `COVERAGE`, and when not skipping mutation: `MUTATION_SCORE`, `MUTATION_RESULT`. These outputs are designed for AI agents in both Cursor and GitHub Copilot to parse and act on consistently.

Artifacts:

- Test results and coverage: `test-results/<TestProject>/` (includes `test_results.trx` and `coverage.cobertura.xml`).
- Mutation reports: latest under `StrykerOutput/**/` (JSON/Markdown/HTML).

## Step‚Äëby‚ÄëStep Improvement Loop

1) Prepare once

```powershell
pwsh -NoLogo -NoProfile -ExecutionPolicy Bypass -Command "dotnet tool restore"
```

2) Quick baseline (tests + coverage only)

```powershell
pwsh ./scripts/test-project-quality.ps1 -TestProject <YourTestProject> -SkipMutation
```

- If coverage is below your target (default 95%), identify gaps using `test-results/<YourTestProject>/coverage.cobertura.xml` in your IDE or a coverage viewer. Prioritize:
  - Core business logic (L0 tests), edge cases, error paths, branches, and boundary conditions.
  - Recently changed files to prevent regressions.
- Add tests under `tests/<YourTestProject>/` only. Re‚Äërun the same command until coverage meets your target (default `‚â• 95%`) and all tests pass.

Build‚Äëonly check (surface warnings/errors)

```powershell
dotnet build ./tests/<YourTestProject>/<YourTestProject>.csproj -c Release -warnaserror
```

- Run this at any point to quickly catch new compiler/analyzer warnings or errors. Note: `dotnet test` already builds unless you use `-NoBuild`.

3) Add mutation testing (quality of assertions and branches)

```powershell
pwsh ./scripts/test-project-quality.ps1 -TestProject <YourTestProject>
```

- If `MUTATION_SCORE < 80%`, open the latest Stryker report in `StrykerOutput/**/` and focus on surviving mutants. Typical fixes:
  - Strengthen assertions (not just happy path; verify behavior, state, and interactions).
  - Add missing branch and exception-path coverage.
  - Use representative inputs (boundary values, null/empty, min/max).
  - Replace overly broad mocks with fakes or refine setups to exercise real logic.
- Add tests under `tests/` only and re‚Äërun until `MUTATION_SCORE ‚â• 80%`.

4) Tight loop for speed

- After the initial build, you can append `-NoBuild` to speed up iterations:

```powershell
pwsh ./scripts/test-project-quality.ps1 -TestProject <YourTestProject> -SkipMutation -NoBuild
pwsh ./scripts/test-project-quality.ps1 -TestProject <YourTestProject> -NoBuild
```

- When using `-NoBuild`, run a separate build to enforce the zero‚Äënew‚Äëwarnings policy:

```powershell
dotnet build ./tests/<YourTestProject>/<YourTestProject>.csproj -c Release -warnaserror
```

5) Ambiguity resolution

- If the script cannot infer the source project (multiple `<ProjectReference>` entries or none under `/src/`), provide it explicitly:

```powershell
pwsh ./scripts/test-project-quality.ps1 -TestProject <YourTestProject> -SourceProject ./src/<Project>/<Project>.csproj
```

## When Tests Imply Production Changes

If, after solid tests, behavior appears incorrect or untestable due to design constraints:

- Document the failing scenario and proposed change.
- Request explicit approval before editing any file outside `tests/`.
- Once approved, follow the standard Build Rules: update tests first, then implement, and run the full pipeline.

## Tips

- Prefer L0 tests (pure in‚Äëmemory) for speed and determinism; only use light infra (L1) when necessary.
- Use `Theory` with data sets for input spaces; exercise both success and failure paths.
- Keep tests isolated, deterministic, and fast; avoid wall‚Äëclock sleeps, random, and external state.

## Related Guidelines

- `.github/instructions/testing.instructions.md` ‚Äî testing layers, conventions, and CI expectations
- `.github/instructions/build-rules.instructions.md` ‚Äî zero‚Äëwarnings policy and full pipeline gates
