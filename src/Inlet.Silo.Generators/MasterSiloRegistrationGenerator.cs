using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Silo.Generators;

/// <summary>
///     Generates a master registration method that calls all aggregate and projection registrations in the silo.
/// </summary>
/// <remarks>
///     <para>
///         This generator produces a single entry point for all silo-side registrations by scanning
///         for types marked with [GenerateAggregateEndpoints] and [UxProjection] attributes,
///         then generating a master extension method that calls their respective registration methods.
///     </para>
///     <para>
///         Example: For a project with root namespace "Spring.Domain", generates "AddSpringDomain()" in "Spring.Silo".
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class MasterSiloRegistrationGenerator : IIncrementalGenerator
{
    private const string GenerateAggregateEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateAggregateEndpointsAttribute";

    private const string GenerateProjectionEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateProjectionEndpointsAttribute";

    /// <summary>
    ///     Recursively finds aggregates and projections in a namespace.
    /// </summary>
    private static void FindMarkedTypesInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol aggregateAttrSymbol,
        INamedTypeSymbol projectionAttrSymbol,
        List<string> aggregateNames,
        List<string> projectionNames
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            // Check for [GenerateAggregateEndpoints]
            if (typeSymbol.GetAttributes()
                .Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, aggregateAttrSymbol)))
            {
                // Extract aggregate name (remove "Aggregate" suffix if present)
                string aggregateName = typeSymbol.Name.EndsWith("Aggregate", StringComparison.Ordinal)
                    ? typeSymbol.Name.Substring(0, typeSymbol.Name.Length - "Aggregate".Length)
                    : typeSymbol.Name;
                aggregateNames.Add(aggregateName);
            }

            // Check for [GenerateProjectionEndpoints]
            if (typeSymbol.GetAttributes()
                .Any(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, projectionAttrSymbol)))
            {
                // Extract projection name (remove "Projection" suffix if present)
                string projectionName = typeSymbol.Name.EndsWith("Projection", StringComparison.Ordinal)
                    ? typeSymbol.Name.Substring(0, typeSymbol.Name.Length - "Projection".Length)
                    : typeSymbol.Name;
                projectionNames.Add(projectionName);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindMarkedTypesInNamespace(childNs, aggregateAttrSymbol, projectionAttrSymbol, aggregateNames, projectionNames);
        }
    }

    /// <summary>
    ///     Generates the master registration extension method.
    /// </summary>
    private static string GenerateMasterRegistration(
        string targetRootNamespace,
        List<string> aggregateNames,
        List<string> projectionNames
    )
    {
        // Extract the product name from the root namespace
        // For "Spring.Domain", we want "Spring"
        // For "Spring.Silo", we want "Spring"
        string productName = targetRootNamespace.Split('.')[0];

        string outputNamespace = productName + ".Silo";
        string methodName = "Add" + productName + "Domain";
        string registrationsNamespace = productName + ".Silo.Registrations";

        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("Microsoft.Extensions.DependencyInjection");

        // Add using for the registrations namespace where generated methods live
        if (aggregateNames.Count > 0 || projectionNames.Count > 0)
        {
            sb.AppendUsing(registrationsNamespace);
        }

        sb.AppendFileScopedNamespace(outputNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Extension methods for registering all {productName} domain services.");
        sb.AppendGeneratedCodeAttribute("MasterSiloRegistrationGenerator");
        sb.AppendLine("public static class ServiceRegistration");
        sb.OpenBrace();
        sb.AppendSummary($"Adds all {productName} domain services to the service collection.");
        sb.AppendLine("/// <param name=\"services\">The service collection.</param>");
        sb.AppendLine("/// <returns>The service collection for chaining.</returns>");
        sb.AppendLine($"public static IServiceCollection {methodName}(");
        sb.IncreaseIndent();
        sb.AppendLine("this IServiceCollection services");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();

        // Call all aggregate registration methods
        foreach (string aggregateName in aggregateNames.OrderBy(n => n))
        {
            sb.AppendLine($"services.Add{aggregateName}Aggregate();");
        }

        // Call all projection registration methods
        foreach (string projectionName in projectionNames.OrderBy(n => n))
        {
            sb.AppendLine($"services.Add{projectionName}Projection();");
        }

        sb.AppendLine();
        sb.AppendLine("return services;");
        sb.CloseBrace();
        sb.CloseBrace();
        return sb.ToString();
    }

    /// <summary>
    ///     Gets all marked types from the compilation.
    /// </summary>
    private static (List<string> AggregateNames, List<string> ProjectionNames) GetMarkedTypesFromCompilation(
        Compilation compilation
    )
    {
        List<string> aggregateNames = new();
        List<string> projectionNames = new();

        INamedTypeSymbol? aggregateAttrSymbol = compilation.GetTypeByMetadataName(GenerateAggregateEndpointsAttributeFullName);
        INamedTypeSymbol? projectionAttrSymbol = compilation.GetTypeByMetadataName(GenerateProjectionEndpointsAttributeFullName);

        if (aggregateAttrSymbol is null && projectionAttrSymbol is null)
        {
            return (aggregateNames, projectionNames);
        }

        // Scan all referenced assemblies
        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindMarkedTypesInNamespace(
                referencedAssembly.GlobalNamespace,
                aggregateAttrSymbol!,
                projectionAttrSymbol!,
                aggregateNames,
                projectionNames);
        }

        return (aggregateNames, projectionNames);
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        // Include the current assembly
        yield return compilation.Assembly;

        // Include all referenced assemblies
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Combine compilation with options provider
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);

        // Use the compilation provider to scan for marked types
        IncrementalValueProvider<(string TargetRootNamespace, List<string> AggregateNames, List<string> ProjectionNames)>
            markedTypesProvider = compilationAndOptions.Select((
                source,
                _
            ) =>
            {
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.RootNamespaceProperty,
                    out string? rootNamespace);
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.AssemblyNameProperty,
                    out string? assemblyName);
                string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                    rootNamespace,
                    assemblyName,
                    source.Compilation);

                (List<string> aggregateNames, List<string> projectionNames) = GetMarkedTypesFromCompilation(
                    source.Compilation);

                return (targetRootNamespace, aggregateNames, projectionNames);
            });

        // Register source output
        context.RegisterSourceOutput(
            markedTypesProvider,
            static (
                spc,
                data
            ) =>
            {
                if (data.AggregateNames.Count == 0 && data.ProjectionNames.Count == 0)
                {
                    return;
                }

                string registrationSource = GenerateMasterRegistration(
                    data.TargetRootNamespace,
                    data.AggregateNames,
                    data.ProjectionNames);
                spc.AddSource("ServiceRegistration.g.cs", SourceText.From(registrationSource, Encoding.UTF8));
            });
    }
}
