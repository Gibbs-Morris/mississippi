using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Silo.Generators;

/// <summary>
///     Generates domain registration wrappers for silo projects.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DomainSiloRegistrationGenerator : IIncrementalGenerator
{
    private const string GenerateAggregateEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateAggregateEndpointsAttribute";

    private const string GenerateProjectionEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateProjectionEndpointsAttribute";

    private const string GenerateSagaEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateSagaEndpointsAttribute";

    private const string GenerateSagaEndpointsAttributeGenericFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateSagaEndpointsAttribute`1";

    /// <inheritdoc />
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)> source =
            context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);
        context.RegisterSourceOutput(
            source,
            static (
                spc,
                value
            ) => Generate(spc, value.Compilation, value.Options));
    }

    private static void Generate(
        SourceProductionContext context,
        Compilation compilation,
        AnalyzerConfigOptionsProvider optionsProvider
    )
    {
        string targetRootNamespace = ResolveTargetRootNamespace(compilation, optionsProvider);
        string? productNamespace = GetProductNamespace(targetRootNamespace, ".Silo");
        if (string.IsNullOrWhiteSpace(productNamespace))
        {
            return;
        }

        string productTypeName = BuildTypeName(productNamespace);
        HashSet<string> aggregateNames = GetAggregateNames(compilation);
        HashSet<string> projectionNames = GetProjectionNames(compilation);
        HashSet<string> sagaNames = GetSagaNames(compilation);
        if (aggregateNames.Count == 0 && projectionNames.Count == 0 && sagaNames.Count == 0)
        {
            return;
        }

        string registrationsNamespace = targetRootNamespace + ".Registrations";
        string className = productTypeName + "DomainSiloRegistrations";
        string methodName = "Add" + productTypeName + "Domain";

        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("Mississippi.Common.Abstractions.Builders");
        sb.AppendFileScopedNamespace(registrationsNamespace);
        sb.AppendLine();
        sb.AppendSummary("Extension methods for registering the domain silo services.");
        sb.AppendGeneratedCodeAttribute("DomainSiloRegistrationGenerator");
        sb.AppendLine($"public static class {className}");
        sb.OpenBrace();
        sb.AppendSummary("Adds domain silo registrations generated from the domain project.");
        sb.AppendLine("/// <param name=\"builder\">The Mississippi silo builder.</param>");
        sb.AppendLine("/// <returns>The builder for chaining.</returns>");
        sb.AppendLine($"public static IMississippiSiloBuilder {methodName}(");
        sb.IncreaseIndent();
        sb.AppendLine("this IMississippiSiloBuilder builder");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();
        sb.AppendLine("ArgumentNullException.ThrowIfNull(builder);");
        foreach (string aggregateName in aggregateNames.OrderBy(x => x, StringComparer.Ordinal))
        {
            sb.AppendLine($"builder.Add{aggregateName}Aggregate();");
        }

        foreach (string sagaName in sagaNames.OrderBy(x => x, StringComparer.Ordinal))
        {
            sb.AppendLine($"builder.Add{sagaName}Saga();");
        }

        foreach (string projectionName in projectionNames.OrderBy(x => x, StringComparer.Ordinal))
        {
            sb.AppendLine($"builder.Add{projectionName}Projection();");
        }

        sb.AppendLine("return builder;");
        sb.CloseBrace();
        sb.CloseBrace();
        context.AddSource(
            className + ".g.cs",
            SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static HashSet<string> GetAggregateNames(
        Compilation compilation
    )
    {
        HashSet<string> aggregateNames = new(StringComparer.Ordinal);
        INamedTypeSymbol? aggregateAttrSymbol =
            compilation.GetTypeByMetadataName(GenerateAggregateEndpointsAttributeFullName);
        if (aggregateAttrSymbol is null)
        {
            return aggregateNames;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindAggregatesInNamespace(referencedAssembly.GlobalNamespace, aggregateAttrSymbol, aggregateNames);
        }

        return aggregateNames;
    }

    private static HashSet<string> GetProjectionNames(
        Compilation compilation
    )
    {
        HashSet<string> projectionNames = new(StringComparer.Ordinal);
        INamedTypeSymbol? projectionAttrSymbol =
            compilation.GetTypeByMetadataName(GenerateProjectionEndpointsAttributeFullName);
        if (projectionAttrSymbol is null)
        {
            return projectionNames;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindProjectionsInNamespace(referencedAssembly.GlobalNamespace, projectionAttrSymbol, projectionNames);
        }

        return projectionNames;
    }

    private static HashSet<string> GetSagaNames(
        Compilation compilation
    )
    {
        HashSet<string> sagaNames = new(StringComparer.Ordinal);
        INamedTypeSymbol? sagaAttrSymbol =
            compilation.GetTypeByMetadataName(GenerateSagaEndpointsAttributeFullName);
        INamedTypeSymbol? sagaAttrGenericSymbol =
            compilation.GetTypeByMetadataName(GenerateSagaEndpointsAttributeGenericFullName);
        if (sagaAttrSymbol is null && sagaAttrGenericSymbol is null)
        {
            return sagaNames;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindSagasInNamespace(referencedAssembly.GlobalNamespace, sagaAttrSymbol, sagaAttrGenericSymbol, sagaNames);
        }

        return sagaNames;
    }

    private static void FindAggregatesInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol aggregateAttrSymbol,
        HashSet<string> aggregateNames
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            if (typeSymbol.GetAttributes()
                    .Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, aggregateAttrSymbol)))
            {
                string aggregateName = NamingConventions.RemoveSuffix(typeSymbol.Name, "Aggregate");
                if (!string.IsNullOrWhiteSpace(aggregateName))
                {
                    aggregateNames.Add(aggregateName);
                }
            }
        }

        foreach (INamespaceSymbol child in namespaceSymbol.GetNamespaceMembers())
        {
            FindAggregatesInNamespace(child, aggregateAttrSymbol, aggregateNames);
        }
    }

    private static void FindProjectionsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol projectionAttrSymbol,
        HashSet<string> projectionNames
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            if (typeSymbol.GetAttributes()
                    .Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, projectionAttrSymbol)))
            {
                string projectionName = NamingConventions.RemoveSuffix(typeSymbol.Name, "Projection");
                if (!string.IsNullOrWhiteSpace(projectionName))
                {
                    projectionNames.Add(projectionName);
                }
            }
        }

        foreach (INamespaceSymbol child in namespaceSymbol.GetNamespaceMembers())
        {
            FindProjectionsInNamespace(child, projectionAttrSymbol, projectionNames);
        }
    }

    private static void FindSagasInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol? sagaAttrSymbol,
        INamedTypeSymbol? sagaAttrGenericSymbol,
        HashSet<string> sagaNames
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            if (typeSymbol.GetAttributes().Any(attr => MatchesSagaAttribute(attr, sagaAttrSymbol, sagaAttrGenericSymbol)))
            {
                string sagaName = RemoveSagaSuffix(typeSymbol.Name);
                if (!string.IsNullOrWhiteSpace(sagaName))
                {
                    sagaNames.Add(sagaName);
                }
            }
        }

        foreach (INamespaceSymbol child in namespaceSymbol.GetNamespaceMembers())
        {
            FindSagasInNamespace(child, sagaAttrSymbol, sagaAttrGenericSymbol, sagaNames);
        }
    }

    private static bool MatchesSagaAttribute(
        AttributeData attr,
        INamedTypeSymbol? sagaAttrSymbol,
        INamedTypeSymbol? sagaAttrGenericSymbol
    )
    {
        if (attr.AttributeClass is null)
        {
            return false;
        }

        if (sagaAttrSymbol is not null && SymbolEqualityComparer.Default.Equals(attr.AttributeClass, sagaAttrSymbol))
        {
            return true;
        }

        return sagaAttrGenericSymbol is not null &&
               SymbolEqualityComparer.Default.Equals(attr.AttributeClass.OriginalDefinition, sagaAttrGenericSymbol);
    }

    private static string RemoveSagaSuffix(
        string typeName
    )
    {
        const string sagaStateSuffix = "SagaState";
        if (typeName.EndsWith(sagaStateSuffix, StringComparison.Ordinal))
        {
            return typeName.Substring(0, typeName.Length - sagaStateSuffix.Length);
        }

        return NamingConventions.RemoveSuffix(typeName, "Saga");
    }

    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    private static string ResolveTargetRootNamespace(
        Compilation compilation,
        AnalyzerConfigOptionsProvider optionsProvider
    )
    {
        optionsProvider.GlobalOptions.TryGetValue(
            TargetNamespaceResolver.RootNamespaceProperty,
            out string? rootNamespace);
        optionsProvider.GlobalOptions.TryGetValue(
            TargetNamespaceResolver.AssemblyNameProperty,
            out string? assemblyName);
        return TargetNamespaceResolver.GetTargetRootNamespace(rootNamespace, assemblyName, compilation);
    }

    private static string? GetProductNamespace(
        string targetRootNamespace,
        string suffix
    )
    {
        if (!targetRootNamespace.EndsWith(suffix, StringComparison.Ordinal))
        {
            return null;
        }

        return targetRootNamespace.Substring(0, targetRootNamespace.Length - suffix.Length);
    }

    private static string BuildTypeName(
        string namespacePrefix
    )
    {
        string[] parts = namespacePrefix.Split('.', StringSplitOptions.RemoveEmptyEntries);
        return string.Concat(parts);
    }
}
