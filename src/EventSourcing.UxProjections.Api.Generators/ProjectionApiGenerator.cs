using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using Mississippi.EventSourcing.UxProjections.Api.Generators.Models;


namespace Mississippi.EventSourcing.UxProjections.Api.Generators;

/// <summary>
///     Incremental source generator for UX projection API controllers.
/// </summary>
/// <remarks>
///     <para>
///         This generator scans for classes decorated with <c>[UxProjection]</c>
///         and emits partial controller classes that inherit from
///         <c>UxProjectionControllerBase&lt;TProjection&gt;</c>.
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class ProjectionApiGenerator : IIncrementalGenerator
{
    private const string BatchRequestClassSource = @"// <auto-generated/>
// This file was generated by Mississippi.EventSourcing.UxProjections.Api.Generators.
// Do not edit this file directly.
#nullable enable

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;

namespace Mississippi.EventSourcing.UxProjections.Api;

/// <summary>
///     Request model for batch projection retrieval.
/// </summary>
[GeneratedCode(""Mississippi.EventSourcing.UxProjections.Api.Generators"", ""1.0.0"")]
public sealed class BatchProjectionRequest
{
    /// <summary>
    ///     Gets or sets the entity IDs to retrieve.
    /// </summary>
    public IReadOnlyList<string> EntityIds { get; set; } = Array.Empty<string>();
}
";

    private const string UxProjectionAttributeFullName =
        "Mississippi.EventSourcing.UxProjections.Abstractions.Attributes.UxProjectionAttribute";

    private static ProjectionApiInfo? ExtractProjectionInfo(
        GeneratorAttributeSyntaxContext context,
        CancellationToken ct
    )
    {
        ct.ThrowIfCancellationRequested();
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        AttributeData? attribute = null;
        foreach (AttributeData attr in typeSymbol.GetAttributes())
        {
            if (attr.AttributeClass?.ToDisplayString() == UxProjectionAttributeFullName)
            {
                attribute = attr;
                break;
            }
        }

        if (attribute is null)
        {
            return null;
        }

        // Extract route from constructor argument
        string route = attribute.ConstructorArguments.Length > 0
            ? attribute.ConstructorArguments[0].Value?.ToString() ?? string.Empty
            : string.Empty;

        // Extract optional properties
        bool isBatchEnabled = true;
        string? authorize = null;
        foreach (KeyValuePair<string, TypedConstant> arg in attribute.NamedArguments)
        {
            switch (arg.Key)
            {
                case "IsBatchEnabled":
                    isBatchEnabled = (bool)(arg.Value.Value ?? true);
                    break;
                case "Authorize":
                    authorize = arg.Value.Value?.ToString();
                    break;
            }
        }

        return new()
        {
            FullTypeName = typeSymbol.ToDisplayString(),
            TypeName = typeSymbol.Name,
            Namespace = typeSymbol.ContainingNamespace.ToDisplayString(),
            Route = route,
            IsBatchEnabled = isBatchEnabled,
            Authorize = authorize,
        };
    }

    private static string GenerateProjectionController(
        ProjectionApiInfo projection
    )
    {
        string authorizeAttribute = projection.Authorize is not null
            ? $"\n    [Authorize(Policy = \"{projection.Authorize}\")]"
            : string.Empty;
        string batchMethod = projection.IsBatchEnabled
            ? $@"

    /// <summary>
    ///     Gets multiple projections in a single request.
    /// </summary>
    /// <param name=""request"">The batch request containing entity IDs.</param>
    /// <param name=""cancellationToken"">A token to cancel the operation.</param>
    /// <returns>A dictionary mapping entity IDs to projections.</returns>
    [HttpPost(""batch"")]
    [ProducesResponseType(typeof(Dictionary<string, {projection.TypeName}>), StatusCodes.Status200OK)]
    public async Task<ActionResult<Dictionary<string, {projection.TypeName}>>> GetBatchAsync(
        [FromBody] BatchProjectionRequest request,
        CancellationToken cancellationToken = default)
    {{
        return await GetBatchCoreAsync(request.EntityIds, cancellationToken);
    }}"
            : string.Empty;
        return $@"// <auto-generated/>
// This file was generated by Mississippi.EventSourcing.UxProjections.Api.Generators.
// Do not edit this file directly.
#nullable enable

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

using Mississippi.EventSourcing.UxProjections.Abstractions;
using Mississippi.EventSourcing.UxProjections.Api;

namespace {projection.Namespace};

/// <summary>
///     Generated API controller for <see cref=""{projection.TypeName}""/> projection.
/// </summary>
/// <remarks>
///     <para>
///         This controller was auto-generated from the <c>[UxProjection]</c> attribute.
///         To customize behavior, create a partial class with additional methods.
///     </para>
/// </remarks>
[GeneratedCode(""Mississippi.EventSourcing.UxProjections.Api.Generators"", ""1.0.0"")]
[Route(""api/projections/{projection.Route}/{{entityId}}"")]{authorizeAttribute}
[ApiController]
[Produces(""application/json"")]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public sealed partial class {projection.TypeName}Controller
    : UxProjectionControllerBase<{projection.TypeName}>
{{
    /// <summary>
    ///     Initializes a new instance of the <see cref=""{projection.TypeName}Controller""/> class.
    /// </summary>
    /// <param name=""uxProjectionGrainFactory"">Factory for resolving UX projection grains.</param>
    /// <param name=""logger"">The logger instance.</param>
    public {projection.TypeName}Controller(
        IUxProjectionGrainFactory uxProjectionGrainFactory,
        ILogger<UxProjectionControllerBase<{projection.TypeName}>> logger)
        : base(uxProjectionGrainFactory, logger)
    {{
    }}{batchMethod}
}}
";
    }

    /// <inheritdoc />
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Filter for types with [UxProjection] attribute
        IncrementalValuesProvider<ProjectionApiInfo> projections = context.SyntaxProvider.ForAttributeWithMetadataName(
                UxProjectionAttributeFullName,
                static (
                    node,
                    _
                ) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (
                    ctx,
                    ct
                ) => ExtractProjectionInfo(ctx, ct))
            .Where(static info => info is not null)!;

        // Collect all projections
        IncrementalValueProvider<ImmutableArray<ProjectionApiInfo>> allProjections = projections.Collect();

        // Generate projection controllers
        context.RegisterSourceOutput(
            projections,
            static (
                spc,
                projection
            ) =>
            {
                string source = GenerateProjectionController(projection);
                spc.AddSource($"{projection.TypeName}Controller.g.cs", source);
            });

        // Generate shared BatchProjectionRequest class when any projections exist
        context.RegisterSourceOutput(
            allProjections,
            static (
                spc,
                projections
            ) =>
            {
                if (projections.Length == 0)
                {
                    return;
                }

                spc.AddSource("BatchProjectionRequest.g.cs", BatchRequestClassSource);
            });
    }
}