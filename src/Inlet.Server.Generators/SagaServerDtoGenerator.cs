using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Analysis;
using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Server.Generators;

/// <summary>
///     Generates server-side saga DTOs and mappers for sagas marked with [GenerateSagaEndpoints].
/// </summary>
/// <remarks>
///     <para>This generator produces:</para>
///     <list type="bullet">
///         <item>Start{SagaName}SagaDto - DTO for saga start requests with all input properties plus CorrelationId.</item>
///         <item>Start{SagaName}SagaDtoMapper - Maps DTO to saga input type.</item>
///         <item>Registration extension method for DI.</item>
///     </list>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class SagaServerDtoGenerator : IIncrementalGenerator
{
    private const string GenerateSagaEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateSagaEndpointsAttribute";

    private const string GeneratorName = "SagaServerDtoGenerator";

    private const string ISagaDefinitionFullName = "Mississippi.EventSourcing.Sagas.Abstractions.ISagaDefinition";

    /// <summary>
    ///     Recursively finds sagas in a namespace.
    /// </summary>
    private static void FindSagasInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol sagaAttrSymbol,
        INamedTypeSymbol sagaDefinitionSymbol,
        List<SagaInputInfo> sagas,
        string targetRootNamespace
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            SagaInputInfo? info = TryGetSagaInputInfo(
                typeSymbol,
                sagaAttrSymbol,
                sagaDefinitionSymbol,
                targetRootNamespace);
            if (info is not null)
            {
                sagas.Add(info);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindSagasInNamespace(childNs, sagaAttrSymbol, sagaDefinitionSymbol, sagas, targetRootNamespace);
        }
    }

    /// <summary>
    ///     Generates all code for a saga.
    /// </summary>
    private static void GenerateCode(
        SourceProductionContext context,
        SagaInputInfo saga
    )
    {
        // Generate DTO
        string dtoSource = GenerateDto(saga);
        context.AddSource($"{saga.DtoTypeName}.g.cs", SourceText.From(dtoSource, Encoding.UTF8));

        // Generate Mapper
        string mapperSource = GenerateMapper(saga);
        context.AddSource($"{saga.MapperTypeName}.g.cs", SourceText.From(mapperSource, Encoding.UTF8));

        // Generate Registration
        string registrationSource = GenerateRegistration(saga);
        context.AddSource(
            $"{saga.SagaName}SagaServerRegistrations.g.cs",
            SourceText.From(registrationSource, Encoding.UTF8));
    }

    /// <summary>
    ///     Generates the DTO record source.
    /// </summary>
    private static string GenerateDto(
        SagaInputInfo saga
    )
    {
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("System.Text.Json.Serialization");
        sb.AppendFileScopedNamespace(saga.OutputNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Request DTO for starting a {saga.SagaName} saga.");
        sb.AppendGeneratedCodeAttribute(GeneratorName);
        sb.AppendLine($"public sealed record {saga.DtoTypeName}");
        sb.OpenBrace();

        // Generate properties from input type
        foreach (PropertyModel prop in saga.InputProperties)
        {
            string jsonPropertyName = NamingConventions.ToCamelCase(prop.Name);
            sb.AppendSummary($"Gets the {jsonPropertyName} value.");
            sb.AppendLine($"[JsonPropertyName(\"{jsonPropertyName}\")]");
            if (prop.IsRequired)
            {
                sb.AppendLine("[JsonRequired]");
                sb.AppendLine($"public required {prop.SourceTypeName} {prop.Name} {{ get; init; }}");
            }
            else if (prop.IsNullable)
            {
                sb.AppendLine($"public {prop.SourceTypeName} {prop.Name} {{ get; init; }}");
            }
            else
            {
                sb.AppendLine($"public {prop.SourceTypeName} {prop.Name} {{ get; init; }} = default!;");
            }

            sb.AppendLine();
        }

        // Always add CorrelationId
        sb.AppendSummary("Gets an optional correlation ID for distributed tracing.");
        sb.AppendLine("[JsonPropertyName(\"correlationId\")]");
        sb.AppendLine("public string? CorrelationId { get; init; }");
        sb.CloseBrace();
        return sb.ToString();
    }

    /// <summary>
    ///     Generates the mapper class.
    /// </summary>
    private static string GenerateMapper(
        SagaInputInfo saga
    )
    {
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("Mississippi.Common.Abstractions.Mapping");
        sb.AppendUsing(saga.InputNamespace);
        sb.AppendFileScopedNamespace(saga.OutputNamespace + ".Mappers");
        sb.AppendLine();
        sb.AppendSummary($"Maps {saga.DtoTypeName} to {saga.InputTypeName}.");
        sb.AppendGeneratedCodeAttribute(GeneratorName);
        sb.AppendLine(
            $"internal sealed class {saga.MapperTypeName} : IMapper<{saga.DtoTypeName}, {saga.InputTypeName}>");
        sb.OpenBrace();

        // Map method
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public {saga.InputTypeName} Map(");
        sb.IncreaseIndent();
        sb.AppendLine($"{saga.DtoTypeName} input");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();
        sb.AppendLine("ArgumentNullException.ThrowIfNull(input);");
        sb.AppendLine();

        // Use object initializer
        sb.AppendLine($"return new {saga.InputTypeName}");
        sb.OpenBrace();
        for (int i = 0; i < saga.InputProperties.Length; i++)
        {
            PropertyModel prop = saga.InputProperties[i];
            string comma = i < (saga.InputProperties.Length - 1) ? "," : string.Empty;
            sb.AppendLine($"{prop.Name} = input.{prop.Name}{comma}");
        }

        sb.CloseBrace();
        sb.AppendLine(";");
        sb.CloseBrace();
        sb.CloseBrace();
        return sb.ToString();
    }

    /// <summary>
    ///     Generates the registration extension.
    /// </summary>
    private static string GenerateRegistration(
        SagaInputInfo saga
    )
    {
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("Microsoft.Extensions.DependencyInjection");
        sb.AppendUsing("Mississippi.Common.Abstractions.Mapping");
        sb.AppendUsing(saga.InputNamespace);
        sb.AppendFileScopedNamespace(saga.OutputNamespace + ".Mappers");
        sb.AppendLine();
        sb.AppendSummary($"Service registration for {saga.SagaName} saga server components.");
        sb.AppendGeneratedCodeAttribute(GeneratorName);
        sb.AppendLine($"public static class {saga.SagaName}SagaServerRegistrations");
        sb.OpenBrace();
        sb.AppendSummary($"Adds {saga.SagaName} saga server mappers to the service collection.");
        sb.AppendLine("/// <param name=\"services\">The service collection.</param>");
        sb.AppendLine("/// <returns>The service collection for chaining.</returns>");
        sb.AppendLine($"public static IServiceCollection Add{saga.SagaName}SagaServer(");
        sb.IncreaseIndent();
        sb.AppendLine("this IServiceCollection services");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();
        sb.AppendLine(
            $"services.AddSingleton<IMapper<{saga.DtoTypeName}, {saga.InputTypeName}>, {saga.MapperTypeName}>();");
        sb.AppendLine("return services;");
        sb.CloseBrace();
        sb.CloseBrace();
        return sb.ToString();
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Gets saga information from the compilation.
    /// </summary>
    private static List<SagaInputInfo> GetSagasFromCompilation(
        Compilation compilation,
        string targetRootNamespace
    )
    {
        List<SagaInputInfo> sagas = [];
        INamedTypeSymbol? sagaAttrSymbol = compilation.GetTypeByMetadataName(GenerateSagaEndpointsAttributeFullName);
        INamedTypeSymbol? sagaDefinitionSymbol = compilation.GetTypeByMetadataName(ISagaDefinitionFullName);
        if (sagaAttrSymbol is null || sagaDefinitionSymbol is null)
        {
            return sagas;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindSagasInNamespace(
                referencedAssembly.GlobalNamespace,
                sagaAttrSymbol,
                sagaDefinitionSymbol,
                sagas,
                targetRootNamespace);
        }

        return sagas;
    }

    /// <summary>
    ///     Tries to get saga input info from a type symbol.
    /// </summary>
    private static SagaInputInfo? TryGetSagaInputInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol sagaAttrSymbol,
        INamedTypeSymbol sagaDefinitionSymbol,
        string targetRootNamespace
    )
    {
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, sagaAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        bool implementsSagaDefinition = typeSymbol.AllInterfaces.Any(i =>
            SymbolEqualityComparer.Default.Equals(i, sagaDefinitionSymbol));
        if (!implementsSagaDefinition)
        {
            return null;
        }

        TypedConstant inputTypeArg = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "InputType").Value;
        if (inputTypeArg.IsNull || inputTypeArg.Value is not INamedTypeSymbol inputTypeSymbol)
        {
            return null;
        }

        // Extract saga name
        string sagaName = typeSymbol.Name;
        if (sagaName.EndsWith("SagaState", StringComparison.Ordinal))
        {
            sagaName = sagaName.Substring(0, sagaName.Length - "SagaState".Length);
        }
        else if (sagaName.EndsWith("Saga", StringComparison.Ordinal))
        {
            sagaName = sagaName.Substring(0, sagaName.Length - "Saga".Length);
        }

        string stateNamespace = typeSymbol.ContainingNamespace.ToDisplayString();
        string inputNamespace = inputTypeSymbol.ContainingNamespace.ToDisplayString();
        string outputNamespace = NamingConventions.GetServerSagaNamespace(stateNamespace, targetRootNamespace);

        // Extract input properties
        PropertyModel[] inputProperties = inputTypeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => (p.DeclaredAccessibility == Accessibility.Public) && p.GetMethod is not null)
            .Select(p => new PropertyModel(p))
            .ToArray();
        return new(sagaName, inputTypeSymbol.Name, inputNamespace, outputNamespace, inputProperties);
    }

    /// <inheritdoc />
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);
        IncrementalValueProvider<List<SagaInputInfo>> sagasProvider = compilationAndOptions.Select((
            source,
            _
        ) =>
        {
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.RootNamespaceProperty,
                out string? rootNamespace);
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.AssemblyNameProperty,
                out string? assemblyName);
            string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                rootNamespace,
                assemblyName,
                source.Compilation);
            return GetSagasFromCompilation(source.Compilation, targetRootNamespace);
        });
        context.RegisterSourceOutput(
            sagasProvider,
            static (
                spc,
                sagas
            ) =>
            {
                foreach (SagaInputInfo saga in sagas)
                {
                    GenerateCode(spc, saga);
                }
            });
    }

    /// <summary>
    ///     Information about a saga's input type for DTO generation.
    /// </summary>
    private sealed class SagaInputInfo
    {
        public SagaInputInfo(
            string sagaName,
            string inputTypeName,
            string inputNamespace,
            string outputNamespace,
            PropertyModel[] inputProperties
        )
        {
            SagaName = sagaName;
            InputTypeName = inputTypeName;
            InputNamespace = inputNamespace;
            OutputNamespace = outputNamespace;
            InputProperties = inputProperties;
        }

        public string DtoTypeName => "Start" + SagaName + "SagaDto";

        public string InputNamespace { get; }

        public PropertyModel[] InputProperties { get; }

        public string InputTypeName { get; }

        public string MapperTypeName => "Start" + SagaName + "SagaDtoMapper";

        public string OutputNamespace { get; }

        public string SagaName { get; }
    }
}