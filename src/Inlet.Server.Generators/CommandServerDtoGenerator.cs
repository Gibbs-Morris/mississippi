using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Analysis;
using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Server.Generators;

/// <summary>
///     Generates server-side command DTOs for commands marked with [GenerateCommand].
/// </summary>
/// <remarks>
///     <para>This generator produces:</para>
///     <list type="bullet">
///         <item>DTO record with JSON serialization attributes for each command.</item>
///         <item>Mapper implementing IMapper&lt;TDto, TCommand&gt;.</item>
///         <item>Mapper registration extension method (grouped by aggregate).</item>
///     </list>
///     <para>
///         The generator scans both the current compilation and referenced assemblies
///         to find command types decorated with [GenerateCommand].
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class CommandServerDtoGenerator : IIncrementalGenerator
{
    private const string GenerateCommandAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateCommandAttribute";

    /// <summary>
    ///     Recursively finds commands in a namespace.
    /// </summary>
    private static void FindCommandsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        List<CommandInfo> commands,
        string targetRootNamespace
    )
    {
        // Check types in this namespace
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            CommandInfo? info = TryGetCommandInfo(typeSymbol, generateAttrSymbol, targetRootNamespace);
            if (info is not null)
            {
                commands.Add(info);
            }
        }

        // Recurse into nested namespaces
        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindCommandsInNamespace(childNs, generateAttrSymbol, commands, targetRootNamespace);
        }
    }

    /// <summary>
    ///     Generates all aggregate-level code (mapper registrations).
    /// </summary>
    private static void GenerateAggregateCode(
        SourceProductionContext context,
        IGrouping<string, CommandInfo> aggregateGroup
    )
    {
        // Generate Mapper Registrations for this aggregate
        string registrationsSource = GenerateMapperRegistrations(aggregateGroup);
        string aggregateName = GetAggregateNameFromNamespace(aggregateGroup.Key);
        context.AddSource(
            $"{aggregateName}AggregateMapperRegistrations.g.cs",
            SourceText.From(registrationsSource, Encoding.UTF8));
    }

    /// <summary>
    ///     Generates all code for a command.
    /// </summary>
    private static void GenerateCode(
        SourceProductionContext context,
        CommandInfo command
    )
    {
        // Generate DTO
        string dtoSource = GenerateDto(command);
        context.AddSource($"{command.Model.DtoTypeName}.g.cs", SourceText.From(dtoSource, Encoding.UTF8));

        // Generate Mapper
        string mapperSource = GenerateMapper(command);
        context.AddSource($"{GetMapperTypeName(command)}.g.cs", SourceText.From(mapperSource, Encoding.UTF8));
    }

    /// <summary>
    ///     Generates the DTO record source.
    /// </summary>
    private static string GenerateDto(
        CommandInfo command
    )
    {
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("System.Text.Json.Serialization");
        sb.AppendFileScopedNamespace(command.OutputNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Request DTO for <see cref=\"{command.Model.FullTypeName}\"/>.");
        sb.AppendGeneratedCodeAttribute("CommandServerDtoGenerator");
        sb.AppendLine($"public sealed record {command.Model.DtoTypeName}");
        sb.OpenBrace();

        // Generate properties
        foreach (PropertyModel prop in command.Model.Properties)
        {
            string jsonPropertyName = NamingConventions.ToCamelCase(prop.Name);
            sb.AppendSummary($"Gets the {NamingConventions.ToCamelCase(prop.Name)} value.");
            sb.AppendLine($"[JsonPropertyName(\"{jsonPropertyName}\")]");
            if (prop.IsRequired)
            {
                sb.AppendLine("[JsonRequired]");
                sb.AppendLine($"public required {prop.SourceTypeName} {prop.Name} {{ get; init; }}");
            }
            else if (prop.IsNullable)
            {
                // Nullable types don't need an explicit default
                sb.AppendLine($"public {prop.SourceTypeName} {prop.Name} {{ get; init; }}");
            }
            else
            {
                // Non-nullable non-required value types get an explicit default to suppress S6964
                sb.AppendLine($"public {prop.SourceTypeName} {prop.Name} {{ get; init; }} = default!;");
            }

            sb.AppendLine();
        }

        sb.CloseBrace();
        return sb.ToString();
    }

    /// <summary>
    ///     Generates the mapper class that maps DTO to command.
    /// </summary>
    private static string GenerateMapper(
        CommandInfo command
    )
    {
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("Mississippi.Common.Abstractions.Mapping");
        sb.AppendUsing(command.Model.Namespace);
        sb.AppendFileScopedNamespace(command.OutputNamespace + ".Mappers");
        sb.AppendLine();
        string mapperName = GetMapperTypeName(command);
        sb.AppendSummary($"Maps {command.Model.DtoTypeName} to {command.Model.TypeName} command.");
        sb.AppendGeneratedCodeAttribute("CommandServerDtoGenerator");
        sb.AppendLine(
            $"internal sealed class {mapperName} : IMapper<{command.Model.DtoTypeName}, {command.Model.TypeName}>");
        sb.OpenBrace();

        // Map method
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public {command.Model.TypeName} Map(");
        sb.IncreaseIndent();
        sb.AppendLine($"{command.Model.DtoTypeName} input");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();
        sb.AppendLine("ArgumentNullException.ThrowIfNull(input);");

        // For positional records, use constructor syntax; otherwise use object initializer
        if (command.Model.IsPositionalRecord)
        {
            // Use constructor call for positional records
            sb.Append($"return new {command.Model.TypeName}(");
            for (int i = 0; i < command.Model.Properties.Length; i++)
            {
                PropertyModel prop = command.Model.Properties[i];
                string comma = i < (command.Model.Properties.Length - 1) ? ", " : string.Empty;
                sb.Append($"input.{prop.Name}{comma}");
            }

            sb.AppendLine(");");
        }
        else
        {
            // Use object initializer for regular records
            sb.AppendLine("return new()");
            sb.OpenBrace();
            for (int i = 0; i < command.Model.Properties.Length; i++)
            {
                PropertyModel prop = command.Model.Properties[i];
                string comma = i < (command.Model.Properties.Length - 1) ? "," : string.Empty;

                // Direct assignment - command properties are typically primitives
                sb.AppendLine($"{prop.Name} = input.{prop.Name}{comma}");
            }

            sb.CloseBrace();
            sb.AppendLine(";");
        }

        sb.CloseBrace();
        sb.CloseBrace();
        return sb.ToString();
    }

    /// <summary>
    ///     Generates the mapper registration extension for an aggregate's commands.
    /// </summary>
    private static string GenerateMapperRegistrations(
        IGrouping<string, CommandInfo> aggregateGroup
    )
    {
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("Microsoft.Extensions.DependencyInjection");
        sb.AppendUsing("Mississippi.Common.Abstractions.Mapping");

        // Add using for each unique command namespace using LINQ
        aggregateGroup.Select(c => c.Model.Namespace).Distinct().ToList().ForEach(ns => sb.AppendUsing(ns));
        CommandInfo first = aggregateGroup.First();
        sb.AppendFileScopedNamespace(first.OutputNamespace + ".Mappers");
        sb.AppendLine();
        string aggregateName = GetAggregateNameFromNamespace(aggregateGroup.Key);
        string registrationsName = $"{aggregateName}AggregateMapperRegistrations";
        sb.AppendSummary($"Service registration for {aggregateName} aggregate DTO mappers.");
        sb.AppendGeneratedCodeAttribute("CommandServerDtoGenerator");
        sb.AppendLine($"internal static class {registrationsName}");
        sb.OpenBrace();
        sb.AppendSummary($"Adds {aggregateName} aggregate DTO to command mappers to the service collection.");
        sb.AppendLine("/// <param name=\"services\">The service collection.</param>");
        sb.AppendLine("/// <returns>The service collection for chaining.</returns>");
        sb.AppendLine($"public static IServiceCollection Add{aggregateName}AggregateMappers(");
        sb.IncreaseIndent();
        sb.AppendLine("this IServiceCollection services");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();
        foreach (CommandInfo command in aggregateGroup)
        {
            sb.AppendLine(
                $"services.AddMapper<{command.Model.DtoTypeName}, {command.Model.TypeName}, {GetMapperTypeName(command)}>();");
        }

        sb.AppendLine("return services;");
        sb.CloseBrace();
        sb.CloseBrace();
        return sb.ToString();
    }

    /// <summary>
    ///     Gets the aggregate name from a command namespace.
    /// </summary>
    /// <remarks>
    ///     Extracts "BankAccount" from "Contoso.Domain.Aggregates.BankAccount.Commands".
    /// </remarks>
    private static string GetAggregateNameFromNamespace(
        string commandNamespace
    )
    {
        // Pattern: *.Aggregates.{AggregateName}.Commands
        string[] parts = commandNamespace.Split('.');
        int aggregatesIndex = Array.IndexOf(parts, "Aggregates");
        if ((aggregatesIndex >= 0) && (aggregatesIndex < (parts.Length - 2)))
        {
            return parts[aggregatesIndex + 1];
        }

        // Fallback: use last segment before "Commands"
        int commandsIndex = Array.IndexOf(parts, "Commands");
        if (commandsIndex > 0)
        {
            return parts[commandsIndex - 1];
        }

        return "Unknown";
    }

    /// <summary>
    ///     Gets command information from the compilation, including referenced assemblies.
    /// </summary>
    private static List<CommandInfo> GetCommandsFromCompilation(
        Compilation compilation,
        string targetRootNamespace
    )
    {
        List<CommandInfo> commands = new();

        // Get the attribute symbol
        INamedTypeSymbol? generateAttrSymbol = compilation.GetTypeByMetadataName(GenerateCommandAttributeFullName);
        if (generateAttrSymbol is null)
        {
            return commands;
        }

        // Scan all assemblies referenced by this compilation
        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindCommandsInNamespace(
                referencedAssembly.GlobalNamespace,
                generateAttrSymbol,
                commands,
                targetRootNamespace);
        }

        return commands;
    }

    /// <summary>
    ///     Gets the mapper type name for a command.
    /// </summary>
    private static string GetMapperTypeName(
        CommandInfo command
    ) =>
        command.Model.DtoTypeName + "Mapper";

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        // Include the current assembly
        yield return compilation.Assembly;

        // Include all referenced assemblies
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get command info from a type symbol.
    /// </summary>
    private static CommandInfo? TryGetCommandInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol,
        string targetRootNamespace
    )
    {
        // Check for [GenerateCommand] attribute
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, generateAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        // Get Route from named argument, fallback to kebab-case of type name
        string? route = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "Route").Value.Value?.ToString();
        if (string.IsNullOrEmpty(route))
        {
            route = NamingConventions.ToKebabCase(typeSymbol.Name);
        }

        // Get HttpMethod from named argument, default to POST
        string httpMethod =
            attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "HttpMethod").Value.Value?.ToString() ?? "POST";

        // Build command model
        CommandModel model = new(typeSymbol, route!, httpMethod);
        string outputNamespace = NamingConventions.GetServerCommandDtoNamespace(model.Namespace, targetRootNamespace);
        return new(model, outputNamespace);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Combine compilation with options provider
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);

        // Use the compilation provider to scan referenced assemblies
        IncrementalValueProvider<List<CommandInfo>> commandsProvider = compilationAndOptions.Select((
            source,
            _
        ) =>
        {
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.RootNamespaceProperty,
                out string? rootNamespace);
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.AssemblyNameProperty,
                out string? assemblyName);
            string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                rootNamespace,
                assemblyName,
                source.Compilation);
            return GetCommandsFromCompilation(source.Compilation, targetRootNamespace);
        });

        // Register source output for individual commands (DTOs and mappers)
        context.RegisterSourceOutput(
            commandsProvider,
            static (
                spc,
                commands
            ) =>
            {
                foreach (CommandInfo command in commands)
                {
                    GenerateCode(spc, command);
                }

                // Group by aggregate namespace and generate registrations
                IEnumerable<IGrouping<string, CommandInfo>> aggregateGroups = commands.GroupBy(c => c.Model.Namespace);
                foreach (IGrouping<string, CommandInfo> aggregateGroup in aggregateGroups)
                {
                    GenerateAggregateCode(spc, aggregateGroup);
                }
            });
    }

    /// <summary>
    ///     Information about a command type.
    /// </summary>
    private sealed class CommandInfo
    {
        public CommandInfo(
            CommandModel model,
            string outputNamespace
        )
        {
            Model = model;
            OutputNamespace = outputNamespace;
        }

        public CommandModel Model { get; }

        public string OutputNamespace { get; }
    }
}