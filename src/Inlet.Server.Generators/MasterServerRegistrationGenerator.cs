using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Server.Generators;

/// <summary>
///     Generates a master registration method that calls all mapper registrations in the server.
/// </summary>
/// <remarks>
///     <para>
///         This generator produces a single entry point for all server-side registrations by scanning
///         for generated registration classes (e.g., BankAccountAggregateMapperRegistrations)
///         and creating a master extension method that calls them all.
///     </para>
///     <para>
///         Example: For a project with root namespace "Spring.Server", generates "AddSpring()" in "Spring.Server".
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class MasterServerRegistrationGenerator : IIncrementalGenerator
{
    /// <summary>
    ///     Recursively finds registration methods in a namespace.
    /// </summary>
    private static void FindRegistrationMethodsInNamespace(
        INamespaceSymbol namespaceSymbol,
        List<RegistrationMethodInfo> registrationMethods
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            // Look for static classes ending in "Registrations"
            if (!typeSymbol.IsStatic || !typeSymbol.Name.EndsWith("Registrations", StringComparison.Ordinal))
            {
                continue;
            }

            // Find all public static extension methods that extend IServiceCollection
            foreach (IMethodSymbol method in typeSymbol.GetMembers().OfType<IMethodSymbol>())
            {
                if (!method.IsStatic || !method.IsExtensionMethod || method.DeclaredAccessibility != Accessibility.Public)
                {
                    continue;
                }

                // Check if it extends IServiceCollection
                if (method.Parameters.Length < 1)
                {
                    continue;
                }

                IParameterSymbol firstParam = method.Parameters[0];
                if (firstParam.Type.ToDisplayString() != "Microsoft.Extensions.DependencyInjection.IServiceCollection")
                {
                    continue;
                }

                // Found a registration method
                registrationMethods.Add(
                    new RegistrationMethodInfo(
                        typeSymbol.ContainingNamespace.ToDisplayString(),
                        method.Name));
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindRegistrationMethodsInNamespace(childNs, registrationMethods);
        }
    }

    /// <summary>
    ///     Generates the master registration extension method.
    /// </summary>
    private static string GenerateMasterRegistration(
        string targetRootNamespace,
        List<RegistrationMethodInfo> registrationMethods
    )
    {
        // Extract the product name from the root namespace
        // For "Spring.Server", we want "Spring"
        string productName = targetRootNamespace.Split('.')[0];

        string outputNamespace = productName + ".Server";
        string methodName = "Add" + productName;

        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("Microsoft.Extensions.DependencyInjection");

        // Add usings for all namespaces containing registration methods
        HashSet<string> namespaces = new();
        foreach (RegistrationMethodInfo method in registrationMethods)
        {
            namespaces.Add(method.Namespace);
        }

        foreach (string ns in namespaces.OrderBy(n => n))
        {
            sb.AppendUsing(ns);
        }

        sb.AppendFileScopedNamespace(outputNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Extension methods for registering all {productName} server services.");
        sb.AppendGeneratedCodeAttribute("MasterServerRegistrationGenerator");
        sb.AppendLine("public static class ServiceRegistration");
        sb.OpenBrace();
        sb.AppendSummary($"Adds all {productName} server services to the service collection.");
        sb.AppendLine("/// <param name=\"services\">The service collection.</param>");
        sb.AppendLine("/// <returns>The service collection for chaining.</returns>");
        sb.AppendLine($"public static IServiceCollection {methodName}(");
        sb.IncreaseIndent();
        sb.AppendLine("this IServiceCollection services");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();

        // Call all registration methods
        foreach (RegistrationMethodInfo method in registrationMethods.OrderBy(m => m.MethodName))
        {
            sb.AppendLine($"services.{method.MethodName}();");
        }

        sb.AppendLine();
        sb.AppendLine("return services;");
        sb.CloseBrace();
        sb.CloseBrace();
        return sb.ToString();
    }

    /// <summary>
    ///     Gets all registration methods from the compilation.
    /// </summary>
    private static List<RegistrationMethodInfo> GetRegistrationMethodsFromCompilation(
        Compilation compilation
    )
    {
        List<RegistrationMethodInfo> registrationMethods = new();

        // Scan only the current assembly (not references)
        FindRegistrationMethodsInNamespace(compilation.Assembly.GlobalNamespace, registrationMethods);

        return registrationMethods;
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Combine compilation with options provider
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);

        // Use the compilation provider to scan for registration methods
        IncrementalValueProvider<(string TargetRootNamespace, List<RegistrationMethodInfo> RegistrationMethods)>
            registrationsProvider = compilationAndOptions.Select((
                source,
                _
            ) =>
            {
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.RootNamespaceProperty,
                    out string? rootNamespace);
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.AssemblyNameProperty,
                    out string? assemblyName);
                string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                    rootNamespace,
                    assemblyName,
                    source.Compilation);

                List<RegistrationMethodInfo> registrationMethods = GetRegistrationMethodsFromCompilation(
                    source.Compilation);

                return (targetRootNamespace, registrationMethods);
            });

        // Register source output
        context.RegisterSourceOutput(
            registrationsProvider,
            static (
                spc,
                data
            ) =>
            {
                if (data.RegistrationMethods.Count == 0)
                {
                    return;
                }

                string registrationSource = GenerateMasterRegistration(
                    data.TargetRootNamespace,
                    data.RegistrationMethods);
                spc.AddSource("ServiceRegistration.g.cs", SourceText.From(registrationSource, Encoding.UTF8));
            });
    }

    /// <summary>
    ///     Information about a registration method.
    /// </summary>
    private sealed class RegistrationMethodInfo
    {
        public RegistrationMethodInfo(
            string @namespace,
            string methodName
        )
        {
            Namespace = @namespace;
            MethodName = methodName;
        }

        public string MethodName { get; }

        public string Namespace { get; }
    }
}
