using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Server.Generators;

/// <summary>
///     Generates server-side saga controllers for sagas marked with [GenerateSagaEndpoints].
/// </summary>
/// <remarks>
///     <para>This generator produces:</para>
///     <list type="bullet">
///         <item>Controller class with endpoints for starting and querying saga status.</item>
///         <item>POST /{sagaId} endpoint to start a new saga instance.</item>
///         <item>GET /{sagaId}/status endpoint to get current saga status.</item>
///     </list>
///     <para>
///         The generator scans both the current compilation and referenced assemblies
///         to find saga types decorated with [GenerateSagaEndpoints] that have an InputType set.
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class SagaControllerGenerator : IIncrementalGenerator
{
    private const string GenerateSagaEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateSagaEndpointsAttribute";

    private const string GeneratorName = "SagaControllerGenerator";

    private const string ISagaDefinitionFullName = "Mississippi.EventSourcing.Sagas.Abstractions.ISagaDefinition";

    /// <summary>
    ///     Recursively finds sagas in a namespace.
    /// </summary>
    private static void FindSagasInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol sagaAttrSymbol,
        INamedTypeSymbol sagaDefinitionSymbol,
        List<SagaInfo> sagas,
        string targetRootNamespace
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            SagaInfo? info = TryGetSagaInfo(typeSymbol, sagaAttrSymbol, sagaDefinitionSymbol, targetRootNamespace);
            if (info is not null)
            {
                sagas.Add(info);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindSagasInNamespace(childNs, sagaAttrSymbol, sagaDefinitionSymbol, sagas, targetRootNamespace);
        }
    }

    /// <summary>
    ///     Generates the constructor.
    /// </summary>
    private static void GenerateConstructor(
        SourceBuilder sb,
        SagaInfo saga
    )
    {
        sb.AppendSummary($"Initializes a new instance of the <see cref=\"{saga.ControllerTypeName}\" /> class.");
        sb.AppendLine("/// <param name=\"orchestrator\">The saga orchestrator.</param>");
        sb.AppendLine("/// <param name=\"mapper\">The DTO to input mapper.</param>");
        sb.AppendLine("/// <param name=\"logger\">The logger for diagnostic output.</param>");
        sb.AppendLine($"public {saga.ControllerTypeName}(");
        sb.IncreaseIndent();
        sb.AppendLine("ISagaOrchestrator orchestrator,");
        sb.AppendLine($"IMapper<{saga.DtoTypeName}, {saga.InputTypeName}> mapper,");
        sb.AppendLine($"ILogger<{saga.ControllerTypeName}> logger");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();
        sb.AppendLine("Orchestrator = orchestrator;");
        sb.AppendLine("Mapper = mapper;");
        sb.AppendLine("Logger = logger;");
        sb.CloseBrace();
    }

    /// <summary>
    ///     Generates the saga controller.
    /// </summary>
    private static string GenerateController(
        SagaInfo saga
    )
    {
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("System.Threading");
        sb.AppendUsing("System.Threading.Tasks");
        sb.AppendUsing("Microsoft.AspNetCore.Mvc");
        sb.AppendUsing("Microsoft.Extensions.Logging");
        sb.AppendUsing("Mississippi.Common.Abstractions.Mapping");
        sb.AppendUsing("Mississippi.EventSourcing.Sagas.Abstractions");
        sb.AppendUsing("Mississippi.EventSourcing.Sagas.Abstractions.Projections");
        sb.AppendUsing(saga.StateNamespace);
        if (!string.IsNullOrEmpty(saga.InputNamespace) && (saga.InputNamespace != saga.StateNamespace))
        {
            sb.AppendUsing(saga.InputNamespace);
        }

        sb.AppendFileScopedNamespace(saga.OutputNamespace);
        sb.AppendLine();

        // Controller class
        sb.AppendSummary($"Controller for starting and managing {saga.SagaName} sagas.");
        sb.AppendGeneratedCodeAttribute(GeneratorName);
        sb.AppendLine("[ApiController]");
        sb.AppendLine($"[Route(\"api/sagas/{saga.RoutePrefix}\")]");
        sb.AppendLine($"public sealed class {saga.ControllerTypeName} : ControllerBase");
        sb.OpenBrace();

        // Constructor
        GenerateConstructor(sb, saga);
        sb.AppendLine();

        // Properties
        sb.AppendLine($"private ILogger<{saga.ControllerTypeName}> Logger {{ get; }}");
        sb.AppendLine();
        sb.AppendLine($"private IMapper<{saga.DtoTypeName}, {saga.InputTypeName}> Mapper {{ get; }}");
        sb.AppendLine();
        sb.AppendLine("private ISagaOrchestrator Orchestrator { get; }");
        sb.AppendLine();

        // Start endpoint
        GenerateStartEndpoint(sb, saga);
        sb.AppendLine();

        // Status endpoint
        GenerateStatusEndpoint(sb, saga);
        sb.CloseBrace();
        return sb.ToString();
    }

    /// <summary>
    ///     Generates the Start saga endpoint.
    /// </summary>
    private static void GenerateStartEndpoint(
        SourceBuilder sb,
        SagaInfo saga
    )
    {
        sb.AppendSummary($"Starts a new {saga.SagaName} saga instance.");
        sb.AppendLine("/// <param name=\"sagaId\">The unique saga instance identifier.</param>");
        sb.AppendLine("/// <param name=\"request\">The saga start request.</param>");
        sb.AppendLine("/// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine("/// <returns>Ok if the saga was started successfully.</returns>");
        sb.AppendLine("[HttpPost(\"{sagaId:guid}\")]");
        sb.AppendLine("public async Task<ActionResult> StartAsync(");
        sb.IncreaseIndent();
        sb.AppendLine("[FromRoute] Guid sagaId,");
        sb.AppendLine($"[FromBody] {saga.DtoTypeName} request,");
        sb.AppendLine("CancellationToken cancellationToken = default");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();
        sb.AppendLine("ArgumentNullException.ThrowIfNull(request);");
        sb.AppendLine();
        sb.AppendLine($"{saga.InputTypeName} input = Mapper.Map(request);");
        sb.AppendLine();
        sb.AppendLine("try");
        sb.OpenBrace();
        sb.AppendLine($"await Orchestrator.StartAsync<{saga.StateTypeName}, {saga.InputTypeName}>(");
        sb.IncreaseIndent();
        sb.AppendLine("sagaId,");
        sb.AppendLine("input,");
        sb.AppendLine("request.CorrelationId);");
        sb.DecreaseIndent();
        sb.AppendLine();
        sb.AppendLine("return Ok();");
        sb.CloseBrace();
        sb.AppendLine("catch (InvalidOperationException ex)");
        sb.OpenBrace();
        sb.AppendLine("Logger.LogWarning(ex, \"Failed to start saga {SagaId}\", sagaId);");
        sb.AppendLine("return BadRequest(new { error = ex.Message });");
        sb.CloseBrace();
        sb.CloseBrace();
    }

    /// <summary>
    ///     Generates the Status endpoint.
    /// </summary>
    private static void GenerateStatusEndpoint(
        SourceBuilder sb,
        SagaInfo saga
    )
    {
        sb.AppendSummary($"Gets the current status of a {saga.SagaName} saga instance.");
        sb.AppendLine("/// <param name=\"sagaId\">The saga instance identifier.</param>");
        sb.AppendLine("/// <param name=\"cancellationToken\">Cancellation token.</param>");
        sb.AppendLine("/// <returns>The saga status, or NotFound if the saga doesn't exist.</returns>");
        sb.AppendLine("[HttpGet(\"{sagaId:guid}/status\")]");
        sb.AppendLine("public async Task<ActionResult<SagaStatusProjection>> GetStatusAsync(");
        sb.IncreaseIndent();
        sb.AppendLine("[FromRoute] Guid sagaId,");
        sb.AppendLine("CancellationToken cancellationToken = default");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();
        sb.AppendLine("SagaStatusProjection? status = await Orchestrator.GetStatusAsync(sagaId);");
        sb.AppendLine();
        sb.AppendLine("if (status is null)");
        sb.OpenBrace();
        sb.AppendLine("return NotFound();");
        sb.CloseBrace();
        sb.AppendLine();
        sb.AppendLine("return Ok(status);");
        sb.CloseBrace();
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Gets saga information from the compilation, including referenced assemblies.
    /// </summary>
    private static List<SagaInfo> GetSagasFromCompilation(
        Compilation compilation,
        string targetRootNamespace
    )
    {
        List<SagaInfo> sagas = [];
        INamedTypeSymbol? sagaAttrSymbol = compilation.GetTypeByMetadataName(GenerateSagaEndpointsAttributeFullName);
        INamedTypeSymbol? sagaDefinitionSymbol = compilation.GetTypeByMetadataName(ISagaDefinitionFullName);
        if (sagaAttrSymbol is null || sagaDefinitionSymbol is null)
        {
            return sagas;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindSagasInNamespace(
                referencedAssembly.GlobalNamespace,
                sagaAttrSymbol,
                sagaDefinitionSymbol,
                sagas,
                targetRootNamespace);
        }

        return sagas;
    }

    /// <summary>
    ///     Tries to get saga info from a type symbol.
    /// </summary>
    private static SagaInfo? TryGetSagaInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol sagaAttrSymbol,
        INamedTypeSymbol sagaDefinitionSymbol,
        string targetRootNamespace
    )
    {
        // Check for [GenerateSagaEndpoints] attribute
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, sagaAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        // Check for ISagaDefinition interface
        bool implementsSagaDefinition = typeSymbol.AllInterfaces.Any(i =>
            SymbolEqualityComparer.Default.Equals(i, sagaDefinitionSymbol));
        if (!implementsSagaDefinition)
        {
            return null;
        }

        // Get InputType from attribute - skip if not set
        TypedConstant inputTypeArg = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "InputType").Value;
        if (inputTypeArg.IsNull || inputTypeArg.Value is not INamedTypeSymbol inputTypeSymbol)
        {
            return null;
        }

        // Extract saga name from type name (remove "SagaState" or "Saga" suffix)
        string sagaName = typeSymbol.Name;
        if (sagaName.EndsWith("SagaState", StringComparison.Ordinal))
        {
            sagaName = sagaName.Substring(0, sagaName.Length - "SagaState".Length);
        }
        else if (sagaName.EndsWith("Saga", StringComparison.Ordinal))
        {
            sagaName = sagaName.Substring(0, sagaName.Length - "Saga".Length);
        }

        string routePrefix = NamingConventions.ToKebabCase(sagaName);
        string stateNamespace = typeSymbol.ContainingNamespace.ToDisplayString();
        string inputNamespace = inputTypeSymbol.ContainingNamespace.ToDisplayString();

        // Generate output namespace based on target root namespace
        string outputNamespace = NamingConventions.GetServerSagaNamespace(stateNamespace, targetRootNamespace);
        return new(
            sagaName,
            routePrefix,
            typeSymbol.Name,
            inputTypeSymbol.Name,
            stateNamespace,
            inputNamespace,
            outputNamespace);
    }

    /// <inheritdoc />
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);
        IncrementalValueProvider<List<SagaInfo>> sagasProvider = compilationAndOptions.Select((
            source,
            _
        ) =>
        {
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.RootNamespaceProperty,
                out string? rootNamespace);
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.AssemblyNameProperty,
                out string? assemblyName);
            string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                rootNamespace,
                assemblyName,
                source.Compilation);
            return GetSagasFromCompilation(source.Compilation, targetRootNamespace);
        });
        context.RegisterSourceOutput(
            sagasProvider,
            static (
                spc,
                sagas
            ) =>
            {
                foreach (SagaInfo saga in sagas)
                {
                    string controllerSource = GenerateController(saga);
                    spc.AddSource($"{saga.ControllerTypeName}.g.cs", SourceText.From(controllerSource, Encoding.UTF8));
                }
            });
    }

    /// <summary>
    ///     Information about a saga type.
    /// </summary>
    private sealed class SagaInfo
    {
        public SagaInfo(
            string sagaName,
            string routePrefix,
            string stateTypeName,
            string inputTypeName,
            string stateNamespace,
            string inputNamespace,
            string outputNamespace
        )
        {
            SagaName = sagaName;
            RoutePrefix = routePrefix;
            StateTypeName = stateTypeName;
            InputTypeName = inputTypeName;
            StateNamespace = stateNamespace;
            InputNamespace = inputNamespace;
            OutputNamespace = outputNamespace;
        }

        public string ControllerTypeName => SagaName + "SagaController";

        public string DtoTypeName => "Start" + SagaName + "SagaDto";

        public string InputNamespace { get; }

        public string InputTypeName { get; }

        public string OutputNamespace { get; }

        public string RoutePrefix { get; }

        public string SagaName { get; }

        public string StateNamespace { get; }

        public string StateTypeName { get; }
    }
}