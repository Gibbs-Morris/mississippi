using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates client-side reducer registrations and DTO registry mappings for projections
///     marked with [GenerateProjectionEndpoints].
/// </summary>
/// <remarks>
///     <para>
///         This generator produces a static registration class that wires up reducers
///         for all projection action types (Loading, Loaded, Updated, Error, ConnectionChanged)
///         and a DTO registry mapping method for path-to-type resolution.
///     </para>
///     <para>
///         Example: For a projection "BankAccountBalanceProjection" with
///         [GenerateProjectionEndpoints(Path = "bank-account-balance")],
///         generates reducer registrations for ProjectionLoadingAction&lt;BankAccountBalanceDto&gt;,
///         etc., and a registry mapping from "bank-account-balance" to typeof(BankAccountBalanceDto).
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class ProjectionClientRegistrationGenerator : IIncrementalGenerator
{
    private const string GenerateProjectionEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateProjectionEndpointsAttribute";

    /// <summary>
    ///     Recursively finds projections in a namespace.
    /// </summary>
    private static void FindProjectionsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        List<ProjectionDtoInfo> projectionDtos
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            ProjectionDtoInfo? info = TryGetProjectionDtoInfo(typeSymbol, generateAttrSymbol);
            if (info is not null)
            {
                projectionDtos.Add(info);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindProjectionsInNamespace(childNs, generateAttrSymbol, projectionDtos);
        }
    }

    /// <summary>
    ///     Generates the registration class for all projection reducers and DTO mappings.
    /// </summary>
    private static void GenerateRegistration(
        SourceProductionContext context,
        List<ProjectionDtoInfo> projectionDtos,
        string targetRootNamespace
    )
    {
        if (projectionDtos.Count == 0)
        {
            return;
        }

        StringBuilder sb = new();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Mississippi.Inlet.Client.Abstractions.Actions;");
        sb.AppendLine("using Mississippi.Inlet.Client.Abstractions.State;");
        sb.AppendLine("using Mississippi.Inlet.Client.ActionEffects;");
        sb.AppendLine("using Mississippi.Inlet.Client.Reducers;");
        sb.AppendLine("using Mississippi.Reservoir.Abstractions.Builders;");
        sb.AppendLine();

        // Add unique namespaces for DTO types (derived from projection namespaces)
        IEnumerable<string> uniqueNamespaces = projectionDtos.Select(p => p.DtoNamespace).Distinct().OrderBy(n => n);
        foreach (string ns in uniqueNamespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();

        // Namespace - use the target root namespace with .Features suffix
        string registrationNamespace = targetRootNamespace;
        if (!registrationNamespace.EndsWith(".Features", StringComparison.Ordinal))
        {
            registrationNamespace += ".Features";
        }

        sb.AppendLine($"namespace {registrationNamespace};");
        sb.AppendLine();

        // Registration class
        sb.AppendLine("/// <summary>");
        sb.AppendLine("///     Extension methods for registering projection reducers.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("///     <para>");
        sb.AppendLine("///         This class is auto-generated and registers reducers for all projection");
        sb.AppendLine("///         action types (Loading, Loaded, Updated, Error, ConnectionChanged).");
        sb.AppendLine("///     </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"ProjectionClientRegistrationGenerator\", \"1.0.0\")]");
        sb.AppendLine("public static class ProjectionsFeatureRegistration");
        sb.AppendLine("{");

        // Extension method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    ///     Adds projection reducers for all known projection types.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"builder\">The Reservoir builder.</param>");
        sb.AppendLine("    /// <returns>The Reservoir builder for chaining.</returns>");
        sb.AppendLine("    public static IReservoirBuilder AddProjectionsFeature(");
        sb.AppendLine("        this IReservoirBuilder builder");
        sb.AppendLine("    )");
        sb.AppendLine("    {");

        // Register feature state
        sb.AppendLine("        // Register the projections feature state");
        sb.AppendLine("        builder.AddFeature<ProjectionsFeatureState>(featureBuilder =>");
        sb.AppendLine("        {");

        // Generate reducer registrations for each projection DTO (use Select + ToList + ForEach to satisfy S3267)
        projectionDtos.Select(dto => dto.DtoTypeName)
            .OrderBy(typeName => typeName, StringComparer.Ordinal)
            .ToList()
            .ForEach(typeName =>
            {
                sb.AppendLine($"            // Reducers for {typeName}");
                sb.AppendLine($"            featureBuilder.AddReducer<ProjectionLoadingAction<{typeName}>>(");
                sb.AppendLine($"                ProjectionsReducer.ReduceLoading<{typeName}>);");
                sb.AppendLine($"            featureBuilder.AddReducer<ProjectionLoadedAction<{typeName}>>(");
                sb.AppendLine($"                ProjectionsReducer.ReduceLoaded<{typeName}>);");
                sb.AppendLine($"            featureBuilder.AddReducer<ProjectionUpdatedAction<{typeName}>>(");
                sb.AppendLine($"                ProjectionsReducer.ReduceUpdated<{typeName}>);");
                sb.AppendLine($"            featureBuilder.AddReducer<ProjectionErrorAction<{typeName}>>(");
                sb.AppendLine($"                ProjectionsReducer.ReduceError<{typeName}>);");
                sb.AppendLine($"            featureBuilder.AddReducer<ProjectionConnectionChangedAction<{typeName}>>(");
                sb.AppendLine($"                ProjectionsReducer.ReduceConnectionChanged<{typeName}>);");
                sb.AppendLine();
            });
        sb.AppendLine("        });");
        sb.AppendLine("        return builder;");
        sb.AppendLine("    }");
        sb.AppendLine();

        // Generate DTO registry mappings method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    ///     Registers projection DTO type mappings in the given registry.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"registry\">The projection DTO registry to populate.</param>");
        sb.AppendLine("    public static void RegisterProjectionDtoMappings(");
        sb.AppendLine("        IProjectionDtoRegistry registry");
        sb.AppendLine("    )");
        sb.AppendLine("    {");
        projectionDtos.OrderBy(dto => dto.Path, StringComparer.Ordinal)
            .ToList()
            .ForEach(dto =>
            {
                sb.AppendLine($"        registry.Register(\"{dto.Path}\", typeof({dto.DtoTypeName}));");
            });
        sb.AppendLine("    }");

        sb.AppendLine("}");
        context.AddSource("ProjectionsFeatureRegistration.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets projection DTO information from the compilation by scanning referenced assemblies.
    /// </summary>
    private static List<ProjectionDtoInfo> GetProjectionDtosFromCompilation(
        Compilation compilation,
        string targetRootNamespace
    )
    {
        List<ProjectionDtoInfo> projectionDtos = new();

        // Get the attribute symbol
        INamedTypeSymbol? generateAttrSymbol =
            compilation.GetTypeByMetadataName(GenerateProjectionEndpointsAttributeFullName);
        if (generateAttrSymbol is null)
        {
            return projectionDtos;
        }

        // Scan referenced assemblies for [GenerateProjectionEndpoints]
        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindProjectionsInNamespace(
                referencedAssembly.GlobalNamespace, generateAttrSymbol, projectionDtos);
        }

        // Resolve DTO namespaces based on projection namespaces and target root namespace
        List<ProjectionDtoInfo> resolved = projectionDtos.Select(dto =>
            new ProjectionDtoInfo(
                NamingConventions.GetClientNamespace(dto.SourceNamespace, targetRootNamespace),
                NamingConventions.GetDtoName(dto.SourceTypeName),
                dto.Path,
                dto.SourceNamespace,
                dto.SourceTypeName))
            .ToList();

        return resolved;
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get projection DTO info from a type symbol.
    /// </summary>
    private static ProjectionDtoInfo? TryGetProjectionDtoInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol
    )
    {
        // Check for [GenerateProjectionEndpoints] attribute
        AttributeData? genAttr = typeSymbol.GetAttributes()
            .FirstOrDefault(attr =>
                SymbolEqualityComparer.Default.Equals(attr.AttributeClass, generateAttrSymbol));
        if (genAttr is null)
        {
            return null;
        }

        // Read Path from [GenerateProjectionEndpoints(Path = "...")] named argument
        string? projectionPath = genAttr.NamedArguments
            .FirstOrDefault(kvp => kvp.Key == "Path").Value.Value?.ToString();
        if (string.IsNullOrEmpty(projectionPath))
        {
            projectionPath = NamingConventions.GetRoutePrefix(typeSymbol.Name);
        }

        // Store the source namespace/name; DTO name/namespace will be resolved later
        return new(
            typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.Name,
            projectionPath!,
            typeSymbol.ContainingNamespace.ToDisplayString(),
            typeSymbol.Name);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Combine compilation with options provider
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);

        IncrementalValueProvider<(List<ProjectionDtoInfo> ProjectionDtos, string TargetRootNamespace)>
            projectionsProvider = compilationAndOptions.Select((
                source,
                _
            ) =>
            {
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.RootNamespaceProperty,
                    out string? rootNamespace);
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.AssemblyNameProperty,
                    out string? assemblyName);
                string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                    rootNamespace,
                    assemblyName,
                    source.Compilation);
                List<ProjectionDtoInfo> projectionDtos =
                    GetProjectionDtosFromCompilation(source.Compilation, targetRootNamespace);
                return (projectionDtos, targetRootNamespace);
            });

        // Register source output
        context.RegisterSourceOutput(
            projectionsProvider,
            static (
                spc,
                data
            ) => GenerateRegistration(spc, data.ProjectionDtos, data.TargetRootNamespace));
    }

    /// <summary>
    ///     Information about a projection DTO type.
    /// </summary>
    private sealed class ProjectionDtoInfo
    {
        public ProjectionDtoInfo(
            string dtoNamespace,
            string dtoTypeName,
            string path,
            string sourceNamespace,
            string sourceTypeName
        )
        {
            DtoNamespace = dtoNamespace;
            DtoTypeName = dtoTypeName;
            Path = path;
            SourceNamespace = sourceNamespace;
            SourceTypeName = sourceTypeName;
        }

        public string DtoNamespace { get; }

        public string DtoTypeName { get; }

        public string Path { get; }

        public string SourceNamespace { get; }

        public string SourceTypeName { get; }
    }
}