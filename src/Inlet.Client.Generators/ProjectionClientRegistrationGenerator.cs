using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates client-side reducer registrations for projections marked with [ProjectionPath].
/// </summary>
/// <remarks>
///     <para>
///         This generator produces a static registration class that wires up reducers
///         for all projection action types (Loading, Loaded, Updated, Error, ConnectionChanged).
///     </para>
///     <para>
///         Example: For a projection DTO "BankAccountOverviewDto" with [ProjectionPath],
///         generates reducer registrations for ProjectionLoadingAction&lt;BankAccountOverviewDto&gt;, etc.
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class ProjectionClientRegistrationGenerator : IIncrementalGenerator
{
    private const string ProjectionPathAttributeFullName = "Mississippi.Inlet.Abstractions.ProjectionPathAttribute";

    /// <summary>
    ///     Recursively finds projection DTOs in a namespace.
    /// </summary>
    private static void FindProjectionDtosInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol projectionPathAttrSymbol,
        List<ProjectionDtoInfo> projectionDtos
    )
    {
        // Check types in this namespace
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            ProjectionDtoInfo? info = TryGetProjectionDtoInfo(typeSymbol, projectionPathAttrSymbol);
            if (info is not null)
            {
                projectionDtos.Add(info);
            }
        }

        // Recurse into nested namespaces
        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindProjectionDtosInNamespace(childNs, projectionPathAttrSymbol, projectionDtos);
        }
    }

    /// <summary>
    ///     Generates the registration class for all projection reducers.
    /// </summary>
    private static void GenerateRegistration(
        SourceProductionContext context,
        List<ProjectionDtoInfo> projectionDtos,
        string targetRootNamespace
    )
    {
        if (projectionDtos.Count == 0)
        {
            return;
        }

        StringBuilder sb = new();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        sb.AppendLine("using Mississippi.Inlet.Client.Abstractions.Actions;");
        sb.AppendLine("using Mississippi.Inlet.Client.Abstractions.State;");
        sb.AppendLine("using Mississippi.Inlet.Client.Reducers;");
        sb.AppendLine("using Mississippi.Reservoir;");
        sb.AppendLine();

        // Add using for each unique namespace containing projection DTOs
        IEnumerable<string> uniqueNamespaces = projectionDtos.Select(p => p.Namespace).Distinct().OrderBy(n => n);
        foreach (string ns in uniqueNamespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();

        // Namespace - use the target root namespace with .Features suffix
        string registrationNamespace = targetRootNamespace;
        if (!registrationNamespace.EndsWith(".Features", StringComparison.Ordinal))
        {
            registrationNamespace += ".Features";
        }

        sb.AppendLine($"namespace {registrationNamespace};");
        sb.AppendLine();

        // Registration class
        sb.AppendLine("/// <summary>");
        sb.AppendLine("///     Extension methods for registering projection reducers.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("///     <para>");
        sb.AppendLine("///         This class is auto-generated and registers reducers for all projection");
        sb.AppendLine("///         action types (Loading, Loaded, Updated, Error, ConnectionChanged).");
        sb.AppendLine("///     </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"ProjectionClientRegistrationGenerator\", \"1.0.0\")]");
        sb.AppendLine("public static class ProjectionsFeatureRegistration");
        sb.AppendLine("{");

        // Extension method
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    ///     Adds projection reducers for all known projection types.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <param name=\"services\">The service collection.</param>");
        sb.AppendLine("    /// <returns>The service collection for chaining.</returns>");
        sb.AppendLine("    public static IServiceCollection AddProjectionsFeature(");
        sb.AppendLine("        this IServiceCollection services");
        sb.AppendLine("    )");
        sb.AppendLine("    {");

        // Register feature state
        sb.AppendLine("        // Register the projections feature state");
        sb.AppendLine("        services.AddFeatureState<ProjectionsFeatureState>();");
        sb.AppendLine();

        // Generate reducer registrations for each projection DTO (use Select + ToList + ForEach to satisfy S3267)
        projectionDtos.Select(dto => dto.TypeName)
            .OrderBy(typeName => typeName, StringComparer.Ordinal)
            .ToList()
            .ForEach(typeName =>
            {
                sb.AppendLine($"        // Reducers for {typeName}");
                sb.AppendLine(
                    $"        services.AddReducer<ProjectionLoadingAction<{typeName}>, ProjectionsFeatureState>(");
                sb.AppendLine($"            ProjectionsReducer.ReduceLoading<{typeName}>);");
                sb.AppendLine(
                    $"        services.AddReducer<ProjectionLoadedAction<{typeName}>, ProjectionsFeatureState>(");
                sb.AppendLine($"            ProjectionsReducer.ReduceLoaded<{typeName}>);");
                sb.AppendLine(
                    $"        services.AddReducer<ProjectionUpdatedAction<{typeName}>, ProjectionsFeatureState>(");
                sb.AppendLine($"            ProjectionsReducer.ReduceUpdated<{typeName}>);");
                sb.AppendLine(
                    $"        services.AddReducer<ProjectionErrorAction<{typeName}>, ProjectionsFeatureState>(");
                sb.AppendLine($"            ProjectionsReducer.ReduceError<{typeName}>);");
                sb.AppendLine(
                    $"        services.AddReducer<ProjectionConnectionChangedAction<{typeName}>, ProjectionsFeatureState>(");
                sb.AppendLine($"            ProjectionsReducer.ReduceConnectionChanged<{typeName}>);");
                sb.AppendLine();
            });
        sb.AppendLine("        return services;");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        context.AddSource("ProjectionsFeatureRegistration.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets projection DTO information from the compilation (current assembly only).
    /// </summary>
    private static List<ProjectionDtoInfo> GetProjectionDtosFromCompilation(
        Compilation compilation
    )
    {
        List<ProjectionDtoInfo> projectionDtos = new();

        // Get the attribute symbol
        INamedTypeSymbol? projectionPathAttrSymbol = compilation.GetTypeByMetadataName(ProjectionPathAttributeFullName);
        if (projectionPathAttrSymbol is null)
        {
            return projectionDtos;
        }

        // Only scan the current assembly (where generated DTOs live)
        FindProjectionDtosInNamespace(compilation.Assembly.GlobalNamespace, projectionPathAttrSymbol, projectionDtos);
        return projectionDtos;
    }

    /// <summary>
    ///     Tries to get projection DTO info from a type symbol.
    /// </summary>
    private static ProjectionDtoInfo? TryGetProjectionDtoInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol projectionPathAttrSymbol
    )
    {
        // Check for [ProjectionPath] attribute
        AttributeData? projectionPathAttr = typeSymbol.GetAttributes()
            .FirstOrDefault(attr =>
                SymbolEqualityComparer.Default.Equals(attr.AttributeClass, projectionPathAttrSymbol));
        if (projectionPathAttr is null)
        {
            return null;
        }

        // Get the path from constructor argument
        string? projectionPath = projectionPathAttr.ConstructorArguments.FirstOrDefault().Value?.ToString();
        if (string.IsNullOrEmpty(projectionPath))
        {
            return null;
        }

        return new(typeSymbol.ContainingNamespace.ToDisplayString(), typeSymbol.Name, projectionPath!);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Combine compilation with options provider
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);

        // Use the compilation provider to find projection DTOs
        IncrementalValueProvider<(List<ProjectionDtoInfo> ProjectionDtos, string TargetRootNamespace)>
            projectionsProvider = compilationAndOptions.Select((
                source,
                _
            ) =>
            {
                List<ProjectionDtoInfo> projectionDtos = GetProjectionDtosFromCompilation(source.Compilation);
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.RootNamespaceProperty,
                    out string? rootNamespace);
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.AssemblyNameProperty,
                    out string? assemblyName);
                string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                    rootNamespace,
                    assemblyName,
                    source.Compilation);
                return (projectionDtos, targetRootNamespace);
            });

        // Register source output
        context.RegisterSourceOutput(
            projectionsProvider,
            static (
                spc,
                data
            ) => GenerateRegistration(spc, data.ProjectionDtos, data.TargetRootNamespace));
    }

    /// <summary>
    ///     Information about a projection DTO type.
    /// </summary>
    private sealed class ProjectionDtoInfo
    {
        public ProjectionDtoInfo(
            string @namespace,
            string typeName,
            string path
        )
        {
            Namespace = @namespace;
            TypeName = typeName;
            Path = path;
        }

        public string Namespace { get; }

        public string Path { get; }

        public string TypeName { get; }
    }
}