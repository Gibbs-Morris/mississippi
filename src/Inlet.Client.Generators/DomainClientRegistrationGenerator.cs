using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates client-side domain composition registrations that aggregate all generated feature registrations.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DomainClientRegistrationGenerator : IIncrementalGenerator
{
    private const string GenerateCommandAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateCommandAttribute";

    private const string GenerateProjectionEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateProjectionEndpointsAttribute";

    private const string GenerateSagaEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateSagaEndpointsAttribute";

    private const string GenerateSagaEndpointsAttributeGenericFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateSagaEndpointsAttribute`1";

    private static bool ContainsAttribute(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol? attributeSymbol
    ) =>
        attributeSymbol is not null &&
        typeSymbol.GetAttributes()
            .Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, attributeSymbol));

    private static void GatherFromNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol? generateCommandAttribute,
        INamedTypeSymbol? generateSagaAttribute,
        INamedTypeSymbol? generateSagaGenericAttribute,
        INamedTypeSymbol? generateProjectionAttribute,
        Dictionary<string, HashSet<string>> aggregateNamesByDomain,
        Dictionary<string, HashSet<string>> sagaNamesByDomain,
        HashSet<string> domainsWithProjections
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            string containingNamespace = typeSymbol.ContainingNamespace.ToDisplayString();
            if (string.IsNullOrWhiteSpace(containingNamespace))
            {
                continue;
            }

            string domainRoot = NamingConventions.GetDomainRootNamespace(containingNamespace);
            if (string.IsNullOrWhiteSpace(domainRoot))
            {
                continue;
            }

            if (ContainsAttribute(typeSymbol, generateCommandAttribute))
            {
                string? aggregateName = TargetNamespaceResolver.ExtractAggregateName(containingNamespace);
                if (!string.IsNullOrEmpty(aggregateName))
                {
                    if (!aggregateNamesByDomain.TryGetValue(domainRoot, out HashSet<string>? aggregateNames))
                    {
                        aggregateNames = [];
                        aggregateNamesByDomain[domainRoot] = aggregateNames;
                    }

                    aggregateNames.Add(aggregateName!);
                }
            }

            if (ContainsAttribute(typeSymbol, generateSagaAttribute) ||
                ContainsAttribute(typeSymbol, generateSagaGenericAttribute))
            {
                string sagaName = GetSagaName(typeSymbol.Name);
                if (!sagaNamesByDomain.TryGetValue(domainRoot, out HashSet<string>? sagaNames))
                {
                    sagaNames = [];
                    sagaNamesByDomain[domainRoot] = sagaNames;
                }

                sagaNames.Add(sagaName);
            }

            if (ContainsAttribute(typeSymbol, generateProjectionAttribute))
            {
                domainsWithProjections.Add(domainRoot);
            }
        }

        foreach (INamespaceSymbol child in namespaceSymbol.GetNamespaceMembers())
        {
            GatherFromNamespace(
                child,
                generateCommandAttribute,
                generateSagaAttribute,
                generateSagaGenericAttribute,
                generateProjectionAttribute,
                aggregateNamesByDomain,
                sagaNamesByDomain,
                domainsWithProjections);
        }
    }

    private static string GenerateRegistrationsSource(
        IReadOnlyList<DomainRegistrationModel> models,
        string targetRootNamespace
    )
    {
        StringBuilder sb = new();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        sb.AppendLine();
        string[] usingNamespaces = models
            .SelectMany(m => m.AggregateNames.Select(name => $"{m.FeatureNamespace}.{name}Aggregate"))
            .Concat(models.SelectMany(m => m.SagaNames.Select(name => $"{m.FeatureNamespace}.{name}Saga")))
            .Distinct(StringComparer.Ordinal)
            .OrderBy(ns => ns, StringComparer.Ordinal)
            .ToArray();
        foreach (string ns in usingNamespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        if (usingNamespaces.Length > 0)
        {
            sb.AppendLine();
        }

        string outputNamespace = targetRootNamespace.EndsWith(".Features", StringComparison.Ordinal)
            ? targetRootNamespace
            : targetRootNamespace + ".Features";
        sb.AppendLine($"namespace {outputNamespace};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine("///     Extension methods for registering complete client domain feature sets.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[System.CodeDom.Compiler.GeneratedCode(\"DomainClientRegistrationGenerator\", \"1.0.0\")]");
        sb.AppendLine("public static class DomainFeatureRegistrations");
        sb.AppendLine("{");
        foreach (DomainRegistrationModel model in models.OrderBy(m => m.DomainMethodName, StringComparer.Ordinal))
        {
            sb.AppendLine("    /// <summary>");
            sb.AppendLine($"    ///     Adds all generated client features for the {model.DomainRoot} domain.");
            sb.AppendLine("    /// </summary>");
            sb.AppendLine("    /// <param name=\"services\">The service collection.</param>");
            sb.AppendLine("    /// <returns>The service collection for chaining.</returns>");
            sb.AppendLine(
                $"    public static IServiceCollection {model.DomainMethodName}(this IServiceCollection services)");
            sb.AppendLine("    {");
            sb.AppendLine("        ArgumentNullException.ThrowIfNull(services);");
            foreach (string aggregate in model.AggregateNames.OrderBy(n => n, StringComparer.Ordinal))
            {
                sb.AppendLine($"        services.Add{aggregate}AggregateFeature();");
            }

            foreach (string saga in model.SagaNames.OrderBy(n => n, StringComparer.Ordinal))
            {
                sb.AppendLine($"        services.Add{saga}SagaFeature();");
            }

            if (model.IncludesProjections)
            {
                sb.AppendLine("        services.AddProjectionsFeature();");
            }

            sb.AppendLine("        return services;");
            sb.AppendLine("    }");
            sb.AppendLine();
        }

        sb.AppendLine("}");
        return sb.ToString();
    }

    private static DomainRegistrationModel[] GetDomainRegistrations(
        Compilation compilation,
        string targetRootNamespace
    )
    {
        INamedTypeSymbol? generateCommandAttribute =
            compilation.GetTypeByMetadataName(GenerateCommandAttributeFullName);
        INamedTypeSymbol? generateSagaAttribute =
            compilation.GetTypeByMetadataName(GenerateSagaEndpointsAttributeFullName);
        INamedTypeSymbol? generateSagaGenericAttribute =
            compilation.GetTypeByMetadataName(GenerateSagaEndpointsAttributeGenericFullName);
        INamedTypeSymbol? generateProjectionAttribute =
            compilation.GetTypeByMetadataName(GenerateProjectionEndpointsAttributeFullName);
        Dictionary<string, HashSet<string>> aggregateNamesByDomain = new(StringComparer.Ordinal);
        Dictionary<string, HashSet<string>> sagaNamesByDomain = new(StringComparer.Ordinal);
        HashSet<string> domainsWithProjections = new(StringComparer.Ordinal);
        foreach (IAssemblySymbol assembly in GetReferencedAssemblies(compilation))
        {
            GatherFromNamespace(
                assembly.GlobalNamespace,
                generateCommandAttribute,
                generateSagaAttribute,
                generateSagaGenericAttribute,
                generateProjectionAttribute,
                aggregateNamesByDomain,
                sagaNamesByDomain,
                domainsWithProjections);
        }

        HashSet<string> domains = new(StringComparer.Ordinal);
        foreach (string domain in aggregateNamesByDomain.Keys)
        {
            domains.Add(domain);
        }

        foreach (string domain in sagaNamesByDomain.Keys)
        {
            domains.Add(domain);
        }

        foreach (string domain in domainsWithProjections)
        {
            domains.Add(domain);
        }

        string featureNamespace = targetRootNamespace.EndsWith(".Features", StringComparison.Ordinal)
            ? targetRootNamespace
            : targetRootNamespace + ".Features";
        return domains.Select(domain =>
            {
                string[] aggregateNames = aggregateNamesByDomain.TryGetValue(domain, out HashSet<string>? aggregates)
                    ? aggregates.OrderBy(n => n, StringComparer.Ordinal).ToArray()
                    : [];
                string[] sagaNames = sagaNamesByDomain.TryGetValue(domain, out HashSet<string>? sagas)
                    ? sagas.OrderBy(n => n, StringComparer.Ordinal).ToArray()
                    : [];
                return new DomainRegistrationModel(
                    NamingConventions.GetDomainRegistrationMethodName(domain) + "Client",
                    domain,
                    featureNamespace,
                    domainsWithProjections.Contains(domain),
                    aggregateNames,
                    sagaNames);
            })
            .Where(model =>
                (model.AggregateNames.Count > 0) || (model.SagaNames.Count > 0) || model.IncludesProjections)
            .OrderBy(model => model.DomainMethodName, StringComparer.Ordinal)
            .ToArray();
    }

    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    private static string GetSagaName(
        string typeName
    )
    {
        if (typeName.EndsWith("SagaState", StringComparison.Ordinal))
        {
            return typeName.Substring(0, typeName.Length - "SagaState".Length);
        }

        if (typeName.EndsWith("State", StringComparison.Ordinal))
        {
            return typeName.Substring(0, typeName.Length - "State".Length);
        }

        return typeName;
    }

    /// <inheritdoc />
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);
        IncrementalValueProvider<(IReadOnlyList<DomainRegistrationModel> Domains, string TargetRootNamespace)>
            domainsProvider = compilationAndOptions.Select((
                source,
                _
            ) =>
            {
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.RootNamespaceProperty,
                    out string? rootNamespace);
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.AssemblyNameProperty,
                    out string? assemblyName);
                string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                    rootNamespace,
                    assemblyName,
                    source.Compilation);
                IReadOnlyList<DomainRegistrationModel> domains = GetDomainRegistrations(
                    source.Compilation,
                    targetRootNamespace);
                return (domains, targetRootNamespace);
            });
        context.RegisterSourceOutput(
            domainsProvider,
            static (
                spc,
                result
            ) =>
            {
                if (result.Domains.Count == 0)
                {
                    return;
                }

                string source = GenerateRegistrationsSource(result.Domains, result.TargetRootNamespace);
                spc.AddSource("DomainFeatureRegistrations.g.cs", SourceText.From(source, Encoding.UTF8));
            });
    }

    private sealed class DomainRegistrationModel
    {
        public DomainRegistrationModel(
            string domainMethodName,
            string domainRoot,
            string featureNamespace,
            bool includesProjections,
            IReadOnlyList<string> aggregateNames,
            IReadOnlyList<string> sagaNames
        )
        {
            DomainMethodName = domainMethodName;
            DomainRoot = domainRoot;
            FeatureNamespace = featureNamespace;
            IncludesProjections = includesProjections;
            AggregateNames = aggregateNames;
            SagaNames = sagaNames;
        }

        public IReadOnlyList<string> AggregateNames { get; }

        public string DomainMethodName { get; }

        public string DomainRoot { get; }

        public string FeatureNamespace { get; }

        public bool IncludesProjections { get; }

        public IReadOnlyList<string> SagaNames { get; }
    }
}