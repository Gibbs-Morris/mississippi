using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates domain registration wrappers for client projects.
/// </summary>
[Generator(LanguageNames.CSharp)]
public sealed class DomainClientRegistrationGenerator : IIncrementalGenerator
{
    private const string GenerateCommandAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateCommandAttribute";

    private const string ProjectionPathAttributeFullName =
        "Mississippi.Inlet.Abstractions.ProjectionPathAttribute";

    /// <inheritdoc />
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)> source =
            context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);
        context.RegisterSourceOutput(
            source,
            static (
                spc,
                value
            ) => Generate(spc, value.Compilation, value.Options));
    }

    private static void Generate(
        SourceProductionContext context,
        Compilation compilation,
        AnalyzerConfigOptionsProvider optionsProvider
    )
    {
        string targetRootNamespace = ResolveTargetRootNamespace(compilation, optionsProvider);
        string? productNamespace = GetProductNamespace(targetRootNamespace, ".Client");
        if (string.IsNullOrWhiteSpace(productNamespace))
        {
            return;
        }

        string productTypeName = BuildTypeName(productNamespace);
        HashSet<string> aggregateNames = GetAggregateNames(compilation);
        List<SagaClientGeneratorHelper.SagaClientInfo> sagas =
            SagaClientGeneratorHelper.GetSagasFromCompilation(compilation, optionsProvider);
        bool hasProjections = HasProjectionDtos(compilation);
        if (aggregateNames.Count == 0 && sagas.Count == 0 && !hasProjections)
        {
            return;
        }

        HashSet<string> registrationNamespaces = new(StringComparer.Ordinal);
        if (hasProjections)
        {
            registrationNamespaces.Add(targetRootNamespace + ".Features");
        }

        foreach (string aggregateName in aggregateNames)
        {
            registrationNamespaces.Add(targetRootNamespace + ".Features." + aggregateName + "Aggregate");
        }

        foreach (SagaClientGeneratorHelper.SagaClientInfo saga in sagas)
        {
            registrationNamespaces.Add(saga.FeatureRootNamespace);
        }

        string registrationsNamespace = targetRootNamespace + ".Registrations";
        string className = productTypeName + "DomainClientRegistrations";
        string methodName = "Add" + productTypeName + "Domain";

        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("Mississippi.Reservoir.Abstractions.Builders");
        foreach (string usingNamespace in registrationNamespaces.OrderBy(x => x, StringComparer.Ordinal))
        {
            sb.AppendUsing(usingNamespace);
        }

        sb.AppendFileScopedNamespace(registrationsNamespace);
        sb.AppendLine();
        sb.AppendSummary("Extension methods for registering the domain client features.");
        sb.AppendGeneratedCodeAttribute("DomainClientRegistrationGenerator");
        sb.AppendLine($"public static class {className}");
        sb.OpenBrace();
        sb.AppendSummary("Adds domain client features generated from the domain project.");
        sb.AppendLine("/// <param name=\"builder\">The Reservoir builder.</param>");
        sb.AppendLine("/// <returns>The Reservoir builder for chaining.</returns>");
        sb.AppendLine($"public static IReservoirBuilder {methodName}(");
        sb.IncreaseIndent();
        sb.AppendLine("this IReservoirBuilder builder");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();
        sb.AppendLine("ArgumentNullException.ThrowIfNull(builder);");
        foreach (string aggregateName in aggregateNames.OrderBy(x => x, StringComparer.Ordinal))
        {
            sb.AppendLine($"builder.Add{aggregateName}AggregateFeature();");
        }

        foreach (string sagaName in sagas.Select(s => s.SagaName).OrderBy(x => x, StringComparer.Ordinal))
        {
            sb.AppendLine($"builder.Add{sagaName}SagaFeature();");
        }

        if (hasProjections)
        {
            sb.AppendLine("builder.AddProjectionsFeature();");
        }

        sb.AppendLine("return builder;");
        sb.CloseBrace();
        sb.CloseBrace();
        context.AddSource(
            className + ".g.cs",
            SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    private static HashSet<string> GetAggregateNames(
        Compilation compilation
    )
    {
        HashSet<string> aggregateNames = new(StringComparer.Ordinal);
        INamedTypeSymbol? generateAttrSymbol = compilation.GetTypeByMetadataName(GenerateCommandAttributeFullName);
        if (generateAttrSymbol is null)
        {
            return aggregateNames;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindCommandsInNamespace(referencedAssembly.GlobalNamespace, generateAttrSymbol, aggregateNames);
        }

        return aggregateNames;
    }

    private static bool HasProjectionDtos(
        Compilation compilation
    )
    {
        INamedTypeSymbol? projectionPathAttrSymbol =
            compilation.GetTypeByMetadataName(ProjectionPathAttributeFullName);
        if (projectionPathAttrSymbol is null)
        {
            return false;
        }

        return FindProjectionDtosInNamespace(compilation.Assembly.GlobalNamespace, projectionPathAttrSymbol);
    }

    private static bool FindProjectionDtosInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol projectionPathAttrSymbol
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            if (typeSymbol.GetAttributes()
                    .Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, projectionPathAttrSymbol)))
            {
                return true;
            }
        }

        foreach (INamespaceSymbol child in namespaceSymbol.GetNamespaceMembers())
        {
            if (FindProjectionDtosInNamespace(child, projectionPathAttrSymbol))
            {
                return true;
            }
        }

        return false;
    }

    private static void FindCommandsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        HashSet<string> aggregateNames
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            if (typeSymbol.GetAttributes()
                    .Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, generateAttrSymbol)))
            {
                string? aggregateName = NamingConventions.GetAggregateNameFromNamespace(
                    typeSymbol.ContainingNamespace.ToDisplayString());
                if (!string.IsNullOrWhiteSpace(aggregateName))
                {
                    aggregateNames.Add(aggregateName);
                }
            }
        }

        foreach (INamespaceSymbol child in namespaceSymbol.GetNamespaceMembers())
        {
            FindCommandsInNamespace(child, generateAttrSymbol, aggregateNames);
        }
    }

    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    private static string ResolveTargetRootNamespace(
        Compilation compilation,
        AnalyzerConfigOptionsProvider optionsProvider
    )
    {
        optionsProvider.GlobalOptions.TryGetValue(
            TargetNamespaceResolver.RootNamespaceProperty,
            out string? rootNamespace);
        optionsProvider.GlobalOptions.TryGetValue(
            TargetNamespaceResolver.AssemblyNameProperty,
            out string? assemblyName);
        return TargetNamespaceResolver.GetTargetRootNamespace(rootNamespace, assemblyName, compilation);
    }

    private static string? GetProductNamespace(
        string targetRootNamespace,
        string suffix
    )
    {
        if (!targetRootNamespace.EndsWith(suffix, StringComparison.Ordinal))
        {
            return null;
        }

        return targetRootNamespace.Substring(0, targetRootNamespace.Length - suffix.Length);
    }

    private static string BuildTypeName(
        string namespacePrefix
    )
    {
        string[] parts = namespacePrefix.Split('.', StringSplitOptions.RemoveEmptyEntries);
        return string.Concat(parts);
    }
}
