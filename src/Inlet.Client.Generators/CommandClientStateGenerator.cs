using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Analysis;
using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates client-side aggregate state records for commands marked with [GenerateCommand].
/// </summary>
/// <remarks>
///     <para>
///         This generator produces one state record per aggregate that inherits from
///         <c>AggregateCommandStateBase</c> and implements <c>IAggregateCommandState</c>.
///         The state record has a <c>FeatureKey</c> property derived from the aggregate name.
///     </para>
///     <para>
///         Example: For commands in "Spring.Domain.Aggregates.BankAccount.Commands",
///         generates "BankAccountAggregateState" in "Spring.Client.Features.BankAccountAggregate.State".
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class CommandClientStateGenerator : IIncrementalGenerator
{
    private const string GenerateCommandAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateCommandAttribute";

    /// <summary>
    ///     Recursively finds commands in a namespace.
    /// </summary>
    private static void FindCommandsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        List<CommandModel> commands
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            CommandModel? model = TryGetCommandModel(typeSymbol, generateAttrSymbol);
            if (model is not null)
            {
                commands.Add(model);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindCommandsInNamespace(childNs, generateAttrSymbol, commands);
        }
    }

    /// <summary>
    ///     Generates the state record for an aggregate.
    /// </summary>
    private static void GenerateState(
        SourceProductionContext context,
        AggregateInfo aggregate
    )
    {
        string stateTypeName = aggregate.AggregateName + "AggregateState";
        string featureKey = NamingConventions.ToCamelCase(aggregate.AggregateName) + "Aggregate";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("Mississippi.Inlet.Blazor.WebAssembly.Abstractions.State");
        sb.AppendFileScopedNamespace(aggregate.StateNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Feature state for {aggregate.AggregateName} aggregate command execution.");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("///     <para>");
        sb.AppendLine("///         This state tracks the status of command execution (loading, success, failure)");
        sb.AppendLine(
            "///         with per-command history and correlation via <see cref=\"IAggregateCommandState\" />.");
        sb.AppendLine("///     </para>");
        sb.AppendLine("///     <para>");
        sb.AppendLine("///         It does NOT hold read model data - that belongs in the projection feature state.");
        sb.AppendLine("///     </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendGeneratedCodeAttribute("CommandClientStateGenerator");
        sb.AppendLine($"internal sealed record {stateTypeName} : AggregateCommandStateBase, IAggregateCommandState");
        sb.OpenBrace();
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public static string FeatureKey => \"{featureKey}\";");
        sb.CloseBrace();
        context.AddSource($"{stateTypeName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets aggregates from command models by grouping on aggregate name.
    /// </summary>
    private static List<AggregateInfo> GetAggregatesFromCommands(
        List<CommandModel> commands
    )
    {
        return commands.Select(c => new
            {
                Command = c,
                AggregateName = NamingConventions.GetAggregateNameFromNamespace(c.Namespace),
            })
            .Where(x => x.AggregateName is not null)
            .GroupBy(x => x.AggregateName!)
            .Select(g =>
            {
                CommandModel firstCommand = g.First().Command;
                string stateNamespace = NamingConventions.GetClientStateNamespace(firstCommand.Namespace);
                return new AggregateInfo(g.Key, stateNamespace, firstCommand.Namespace);
            })
            .ToList();
    }

    /// <summary>
    ///     Gets command models from the compilation.
    /// </summary>
    private static List<CommandModel> GetCommandsFromCompilation(
        Compilation compilation
    )
    {
        List<CommandModel> commands = new();
        INamedTypeSymbol? generateAttrSymbol = compilation.GetTypeByMetadataName(GenerateCommandAttributeFullName);
        if (generateAttrSymbol is null)
        {
            return commands;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindCommandsInNamespace(referencedAssembly.GlobalNamespace, generateAttrSymbol, commands);
        }

        return commands;
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get command model from a type symbol.
    /// </summary>
    private static CommandModel? TryGetCommandModel(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol
    )
    {
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, generateAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        string? route = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "Route").Value.Value?.ToString();
        if (string.IsNullOrEmpty(route))
        {
            route = NamingConventions.ToKebabCase(typeSymbol.Name);
        }

        string httpMethod =
            attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "HttpMethod").Value.Value?.ToString() ?? "POST";
        return new(typeSymbol, route!, httpMethod);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The incremental generator initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<List<AggregateInfo>> aggregatesProvider = context.CompilationProvider.Select((
            compilation,
            _
        ) =>
        {
            List<CommandModel> commands = GetCommandsFromCompilation(compilation);
            return GetAggregatesFromCommands(commands);
        });
        context.RegisterSourceOutput(
            aggregatesProvider,
            static (
                spc,
                aggregates
            ) =>
            {
                foreach (AggregateInfo aggregate in aggregates)
                {
                    GenerateState(spc, aggregate);
                }
            });
    }

    /// <summary>
    ///     Information about an aggregate derived from command namespaces.
    /// </summary>
    private sealed class AggregateInfo
    {
        public AggregateInfo(
            string aggregateName,
            string stateNamespace,
            string commandNamespace
        )
        {
            AggregateName = aggregateName;
            StateNamespace = stateNamespace;
            CommandNamespace = commandNamespace;
        }

        public string AggregateName { get; }

        public string CommandNamespace { get; }

        public string StateNamespace { get; }
    }
}