using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Analysis;
using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates client-side mappers that convert Flux actions to request DTOs.
/// </summary>
/// <remarks>
///     <para>
///         This generator produces {Command}ActionMapper classes that implement
///         IMapper&lt;{Command}Action, {Command}RequestDto&gt;, mapping action
///         properties (excluding EntityId) to the DTO.
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class CommandClientMappersGenerator : IIncrementalGenerator
{
    private const string GenerateCommandAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateCommandAttribute";

    /// <summary>
    ///     Recursively finds commands in a namespace.
    /// </summary>
    private static void FindCommandsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        string targetRootNamespace,
        List<CommandInfo> commands
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            CommandInfo? info = TryGetCommandInfo(typeSymbol, generateAttrSymbol, targetRootNamespace);
            if (info is not null)
            {
                commands.Add(info);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindCommandsInNamespace(childNs, generateAttrSymbol, targetRootNamespace, commands);
        }
    }

    /// <summary>
    ///     Generates the mapper class for a command.
    /// </summary>
    private static void GenerateMapper(
        SourceProductionContext context,
        CommandInfo command
    )
    {
        string actionName = command.Model.TypeName + "Action";
        string dtoName = NamingConventions.GetCommandRequestDtoName(command.Model.TypeName);
        string mapperName = command.Model.TypeName + "ActionMapper";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("Mississippi.Common.Abstractions.Mapping");
        sb.AppendLine($"using {command.ActionsNamespace};");
        sb.AppendLine($"using {command.DtosNamespace};");
        sb.AppendLine();
        sb.AppendFileScopedNamespace(command.MappersNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Maps {actionName} to {dtoName}.");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine($"///     Derived from domain command: <c>{command.Model.FullTypeName}</c>.");
        sb.AppendLine("/// </remarks>");
        sb.AppendGeneratedCodeAttribute("CommandClientMappersGenerator");
        sb.AppendLine($"internal sealed class {mapperName} : IMapper<{actionName}, {dtoName}>");
        sb.OpenBrace();
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public {dtoName} Map({actionName} input) =>");
        sb.IncreaseIndent();

        // Build DTO constructor call with command properties (excluding EntityId)
        if (command.Model.Properties.Length == 0)
        {
            sb.AppendLine($"new {dtoName}();");
        }
        else
        {
            string dtoArgs = string.Join(", ", command.Model.Properties.Select(p => $"input.{p.Name}"));
            sb.AppendLine($"new({dtoArgs});");
        }

        sb.DecreaseIndent();
        sb.CloseBrace();
        context.AddSource($"{mapperName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets command information from the compilation.
    /// </summary>
    private static List<CommandInfo> GetCommandsFromCompilation(
        Compilation compilation,
        AnalyzerConfigOptionsProvider optionsProvider
    )
    {
        List<CommandInfo> commands = new();
        INamedTypeSymbol? generateAttrSymbol = compilation.GetTypeByMetadataName(GenerateCommandAttributeFullName);
        if (generateAttrSymbol is null)
        {
            return commands;
        }

        optionsProvider.GlobalOptions.TryGetValue(
            TargetNamespaceResolver.RootNamespaceProperty,
            out string? rootNamespace);
        optionsProvider.GlobalOptions.TryGetValue(
            TargetNamespaceResolver.AssemblyNameProperty,
            out string? assemblyName);
        string targetRootNamespace =
            TargetNamespaceResolver.GetTargetRootNamespace(rootNamespace, assemblyName, compilation);
        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindCommandsInNamespace(
                referencedAssembly.GlobalNamespace,
                generateAttrSymbol,
                targetRootNamespace,
                commands);
        }

        return commands;
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get command info from a type symbol.
    /// </summary>
    private static CommandInfo? TryGetCommandInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol,
        string targetRootNamespace
    )
    {
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, generateAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        string? route = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "Route").Value.Value?.ToString();
        if (string.IsNullOrEmpty(route))
        {
            route = NamingConventions.ToKebabCase(typeSymbol.Name);
        }

        string httpMethod =
            attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "HttpMethod").Value.Value?.ToString() ?? "POST";
        CommandModel model = new(typeSymbol, route!, httpMethod);
        string actionsNamespace = NamingConventions.GetClientActionsNamespace(model.Namespace, targetRootNamespace);
        string dtosNamespace = NamingConventions.GetClientCommandDtoNamespace(model.Namespace, targetRootNamespace);
        string mappersNamespace = NamingConventions.GetClientMappersNamespace(model.Namespace, targetRootNamespace);
        return new(model, actionsNamespace, dtosNamespace, mappersNamespace);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The incremental generator initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);
        IncrementalValueProvider<List<CommandInfo>> commandsProvider = compilationAndOptions.Select((
            source,
            _
        ) => GetCommandsFromCompilation(source.Compilation, source.Options));
        context.RegisterSourceOutput(
            commandsProvider,
            static (
                spc,
                commands
            ) =>
            {
                foreach (CommandInfo command in commands)
                {
                    GenerateMapper(spc, command);
                }
            });
    }

    /// <summary>
    ///     Information about a command type.
    /// </summary>
    private sealed class CommandInfo
    {
        public CommandInfo(
            CommandModel model,
            string actionsNamespace,
            string dtosNamespace,
            string mappersNamespace
        )
        {
            Model = model;
            ActionsNamespace = actionsNamespace;
            DtosNamespace = dtosNamespace;
            MappersNamespace = mappersNamespace;
        }

        public string ActionsNamespace { get; }

        public string DtosNamespace { get; }

        public string MappersNamespace { get; }

        public CommandModel Model { get; }
    }
}