using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Analysis;
using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates client-side Flux actions for sagas marked with [GenerateSagaEndpoints].
/// </summary>
/// <remarks>
///     <para>
///         This generator produces four action types per saga:
///     </para>
///     <list type="bullet">
///         <item>Start{SagaName}SagaAction - The primary action with SagaId + input properties.</item>
///         <item>Start{SagaName}SagaExecutingAction - Dispatched when saga start begins.</item>
///         <item>Start{SagaName}SagaSucceededAction - Dispatched when saga start completes successfully.</item>
///         <item>Start{SagaName}SagaFailedAction - Dispatched when saga start fails.</item>
///     </list>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class SagaClientActionsGenerator : IIncrementalGenerator
{
    private const string ActionsNamespaceImport = "Mississippi.Inlet.Client.Abstractions.Actions";

    private const string GenerateSagaEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateSagaEndpointsAttribute";

    private const string GeneratorName = "SagaClientActionsGenerator";

    private const string ISagaDefinitionFullName = "Mississippi.EventSourcing.Sagas.Abstractions.ISagaDefinition";

    private const string SystemNamespaceImport = "System";

    /// <summary>
    ///     Recursively finds sagas in a namespace.
    /// </summary>
    private static void FindSagasInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol sagaAttrSymbol,
        INamedTypeSymbol sagaDefinitionSymbol,
        string targetRootNamespace,
        List<SagaClientInfo> sagas
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            SagaClientInfo? info = TryGetSagaClientInfo(
                typeSymbol,
                sagaAttrSymbol,
                sagaDefinitionSymbol,
                targetRootNamespace);
            if (info is not null)
            {
                sagas.Add(info);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindSagasInNamespace(childNs, sagaAttrSymbol, sagaDefinitionSymbol, targetRootNamespace, sagas);
        }
    }

    /// <summary>
    ///     Generates all action types for a saga.
    /// </summary>
    private static void GenerateActions(
        SourceProductionContext context,
        SagaClientInfo saga
    )
    {
        // Generate primary action
        GeneratePrimaryAction(context, saga);

        // Generate executing action
        GenerateExecutingAction(context, saga);

        // Generate succeeded action
        GenerateSucceededAction(context, saga);

        // Generate failed action
        GenerateFailedAction(context, saga);
    }

    /// <summary>
    ///     Generates the executing action.
    /// </summary>
    private static void GenerateExecutingAction(
        SourceProductionContext context,
        SagaClientInfo saga
    )
    {
        string actionName = $"Start{saga.SagaName}SagaExecutingAction";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing(SystemNamespaceImport);
        sb.AppendUsing(ActionsNamespaceImport);
        sb.AppendFileScopedNamespace(saga.ActionsNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Action dispatched when a Start{saga.SagaName}Saga request starts executing.");
        sb.AppendLine("/// <param name=\"SagaId\">The saga instance identifier.</param>");
        sb.AppendLine("/// <param name=\"SagaType\">The saga type name.</param>");
        sb.AppendLine("/// <param name=\"Timestamp\">The timestamp when execution started.</param>");
        sb.AppendGeneratedCodeAttribute(GeneratorName);
        sb.AppendLine($"internal sealed record {actionName}(Guid SagaId, string SagaType, DateTimeOffset Timestamp)");
        sb.IncreaseIndent();
        sb.AppendLine($": ISagaExecutingAction<{actionName}>");
        sb.DecreaseIndent();
        sb.OpenBrace();
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public static {actionName} Create(");
        sb.IncreaseIndent();
        sb.AppendLine("Guid sagaId,");
        sb.AppendLine("string sagaType,");
        sb.AppendLine("DateTimeOffset timestamp");
        sb.DecreaseIndent();
        sb.AppendLine(") =>");
        sb.IncreaseIndent();
        sb.AppendLine("new(sagaId, sagaType, timestamp);");
        sb.DecreaseIndent();
        sb.CloseBrace();
        context.AddSource($"{actionName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Generates the failed action.
    /// </summary>
    private static void GenerateFailedAction(
        SourceProductionContext context,
        SagaClientInfo saga
    )
    {
        string actionName = $"Start{saga.SagaName}SagaFailedAction";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing(SystemNamespaceImport);
        sb.AppendUsing(ActionsNamespaceImport);
        sb.AppendFileScopedNamespace(saga.ActionsNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Action dispatched when a Start{saga.SagaName}Saga request fails.");
        sb.AppendLine("/// <param name=\"SagaId\">The saga instance identifier.</param>");
        sb.AppendLine("/// <param name=\"ErrorCode\">The error code.</param>");
        sb.AppendLine("/// <param name=\"ErrorMessage\">The error message.</param>");
        sb.AppendLine("/// <param name=\"Timestamp\">The timestamp when the failure occurred.</param>");
        sb.AppendGeneratedCodeAttribute(GeneratorName);
        sb.AppendLine(
            $"internal sealed record {actionName}(Guid SagaId, string? ErrorCode, string? ErrorMessage, DateTimeOffset Timestamp)");
        sb.IncreaseIndent();
        sb.AppendLine($": ISagaFailedAction<{actionName}>");
        sb.DecreaseIndent();
        sb.OpenBrace();
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public static {actionName} Create(");
        sb.IncreaseIndent();
        sb.AppendLine("Guid sagaId,");
        sb.AppendLine("string? errorCode,");
        sb.AppendLine("string? errorMessage,");
        sb.AppendLine("DateTimeOffset timestamp");
        sb.DecreaseIndent();
        sb.AppendLine(") =>");
        sb.IncreaseIndent();
        sb.AppendLine("new(sagaId, errorCode, errorMessage, timestamp);");
        sb.DecreaseIndent();
        sb.CloseBrace();
        context.AddSource($"{actionName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Generates the primary saga action.
    /// </summary>
    private static void GeneratePrimaryAction(
        SourceProductionContext context,
        SagaClientInfo saga
    )
    {
        string actionName = $"Start{saga.SagaName}SagaAction";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing(SystemNamespaceImport);
        sb.AppendUsing(ActionsNamespaceImport);
        sb.AppendFileScopedNamespace(saga.ActionsNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Action to start a {saga.SagaName} saga.");

        // Build parameter list
        List<string> parameters = ["Guid SagaId"];
        foreach (PropertyModel prop in saga.InputProperties)
        {
            parameters.Add($"{prop.SourceTypeName} {prop.Name}");
        }

        parameters.Add("string? CorrelationId = null");
        sb.AppendGeneratedCodeAttribute(GeneratorName);
        sb.AppendLine($"public sealed record {actionName}(");
        sb.IncreaseIndent();
        for (int i = 0; i < parameters.Count; i++)
        {
            string comma = i < (parameters.Count - 1) ? "," : string.Empty;
            sb.AppendLine(parameters[i] + comma);
        }

        sb.DecreaseIndent();
        sb.AppendLine(") : ISagaAction;");
        context.AddSource($"{actionName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Generates the succeeded action.
    /// </summary>
    private static void GenerateSucceededAction(
        SourceProductionContext context,
        SagaClientInfo saga
    )
    {
        string actionName = $"Start{saga.SagaName}SagaSucceededAction";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing(SystemNamespaceImport);
        sb.AppendUsing(ActionsNamespaceImport);
        sb.AppendFileScopedNamespace(saga.ActionsNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Action dispatched when a Start{saga.SagaName}Saga request succeeds.");
        sb.AppendLine("/// <param name=\"SagaId\">The saga instance identifier.</param>");
        sb.AppendLine("/// <param name=\"Timestamp\">The timestamp when success occurred.</param>");
        sb.AppendGeneratedCodeAttribute(GeneratorName);
        sb.AppendLine($"internal sealed record {actionName}(Guid SagaId, DateTimeOffset Timestamp)");
        sb.IncreaseIndent();
        sb.AppendLine($": ISagaSucceededAction<{actionName}>");
        sb.DecreaseIndent();
        sb.OpenBrace();
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public static {actionName} Create(");
        sb.IncreaseIndent();
        sb.AppendLine("Guid sagaId,");
        sb.AppendLine("DateTimeOffset timestamp");
        sb.DecreaseIndent();
        sb.AppendLine(") =>");
        sb.IncreaseIndent();
        sb.AppendLine("new(sagaId, timestamp);");
        sb.DecreaseIndent();
        sb.CloseBrace();
        context.AddSource($"{actionName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (IAssemblySymbol assemblySymbol in compilation.References
                     .Select(reference => compilation.GetAssemblyOrModuleSymbol(reference))
                     .OfType<IAssemblySymbol>())
        {
            yield return assemblySymbol;
        }
    }

    /// <summary>
    ///     Gets saga information from the compilation.
    /// </summary>
    private static List<SagaClientInfo> GetSagasFromCompilation(
        Compilation compilation,
        string targetRootNamespace
    )
    {
        List<SagaClientInfo> sagas = [];
        INamedTypeSymbol? sagaAttrSymbol = compilation.GetTypeByMetadataName(GenerateSagaEndpointsAttributeFullName);
        INamedTypeSymbol? sagaDefinitionSymbol = compilation.GetTypeByMetadataName(ISagaDefinitionFullName);
        if (sagaAttrSymbol is null || sagaDefinitionSymbol is null)
        {
            return sagas;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindSagasInNamespace(
                referencedAssembly.GlobalNamespace,
                sagaAttrSymbol,
                sagaDefinitionSymbol,
                targetRootNamespace,
                sagas);
        }

        return sagas;
    }

    /// <summary>
    ///     Tries to get saga client info from a type symbol.
    /// </summary>
    private static SagaClientInfo? TryGetSagaClientInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol sagaAttrSymbol,
        INamedTypeSymbol sagaDefinitionSymbol,
        string targetRootNamespace
    )
    {
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, sagaAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        bool implementsSagaDefinition = typeSymbol.AllInterfaces.Any(i =>
            SymbolEqualityComparer.Default.Equals(i, sagaDefinitionSymbol));
        if (!implementsSagaDefinition)
        {
            return null;
        }

        TypedConstant inputTypeArg = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "InputType").Value;
        if (inputTypeArg.IsNull || inputTypeArg.Value is not INamedTypeSymbol inputTypeSymbol)
        {
            return null;
        }

        // Extract saga name
        string sagaName = typeSymbol.Name;
        if (sagaName.EndsWith("SagaState", StringComparison.Ordinal))
        {
            sagaName = sagaName.Substring(0, sagaName.Length - "SagaState".Length);
        }
        else if (sagaName.EndsWith("Saga", StringComparison.Ordinal))
        {
            sagaName = sagaName.Substring(0, sagaName.Length - "Saga".Length);
        }

        string stateNamespace = typeSymbol.ContainingNamespace.ToDisplayString();

        // Get client feature namespace: {targetRoot}.Features.{SagaName}Saga.Actions
        string actionsNamespace = NamingConventions.GetClientSagaFeatureNamespace(
            stateNamespace,
            targetRootNamespace,
            "Actions");

        // Extract input properties
        PropertyModel[] inputProperties = inputTypeSymbol.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => (p.DeclaredAccessibility == Accessibility.Public) && p.GetMethod is not null)
            .Select(p => new PropertyModel(p))
            .ToArray();
        return new(sagaName, actionsNamespace, inputProperties);
    }

    /// <inheritdoc />
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);
        IncrementalValueProvider<List<SagaClientInfo>> sagasProvider = compilationAndOptions.Select((
            source,
            _
        ) =>
        {
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.RootNamespaceProperty,
                out string? rootNamespace);
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.AssemblyNameProperty,
                out string? assemblyName);
            string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                rootNamespace,
                assemblyName,
                source.Compilation);
            return GetSagasFromCompilation(source.Compilation, targetRootNamespace);
        });
        context.RegisterSourceOutput(
            sagasProvider,
            static (
                spc,
                sagas
            ) =>
            {
                foreach (SagaClientInfo saga in sagas)
                {
                    GenerateActions(spc, saga);
                }
            });
    }

    /// <summary>
    ///     Information about a saga for client action generation.
    /// </summary>
    private sealed class SagaClientInfo
    {
        public SagaClientInfo(
            string sagaName,
            string actionsNamespace,
            PropertyModel[] inputProperties
        )
        {
            SagaName = sagaName;
            ActionsNamespace = actionsNamespace;
            InputProperties = inputProperties;
        }

        public string ActionsNamespace { get; }

        public PropertyModel[] InputProperties { get; }

        public string SagaName { get; }
    }
}