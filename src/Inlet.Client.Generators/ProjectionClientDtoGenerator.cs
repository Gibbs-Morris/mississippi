using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Analysis;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates client-side DTOs for projections marked with [GenerateProjectionEndpoints].
/// </summary>
/// <remarks>
///     <para>
///         This generator scans referenced assemblies (including Domain projects referenced
///         with ExcludeAssets="runtime") to find projection types and generates matching
///         client-side DTOs with [ProjectionPath] attributes.
///     </para>
///     <para>
///         The ExcludeAssets="runtime" pattern allows the generator to see Domain types at
///         compile time without deploying Orleans-contaminated assemblies to the WASM bundle.
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class ProjectionClientDtoGenerator : IIncrementalGenerator
{
    private const string GenerateProjectionEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateProjectionEndpointsAttribute";

    private const string ProjectionPathAttributeFullName =
        "Mississippi.Inlet.Projection.Abstractions.ProjectionPathAttribute";

    /// <summary>
    ///     Recursively finds projections in a namespace.
    /// </summary>
    private static void FindProjectionsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        INamedTypeSymbol projectionPathAttrSymbol,
        List<ProjectionInfo> projections
    )
    {
        // Check types in this namespace
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            ProjectionInfo? info = TryGetProjectionInfo(typeSymbol, generateAttrSymbol, projectionPathAttrSymbol);
            if (info is not null)
            {
                projections.Add(info);
            }
        }

        // Recurse into nested namespaces
        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindProjectionsInNamespace(childNs, generateAttrSymbol, projectionPathAttrSymbol, projections);
        }
    }

    /// <summary>
    ///     Generates the client DTO for a projection.
    /// </summary>
    private static void GenerateClientDto(
        SourceProductionContext context,
        ProjectionInfo projection
    )
    {
        // Use client namespace convention
        string clientNamespace = NamingConventions.GetClientNamespace(projection.Namespace);
        string dtoName = NamingConventions.GetDtoName(projection.TypeName);
        StringBuilder sb = new();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Mississippi.Inlet.Projection.Abstractions;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {clientNamespace};");
        sb.AppendLine();

        // DTO record with ProjectionPath attribute
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"///     Client-side DTO for <see cref=\"{projection.Namespace}.{projection.TypeName}\"/>.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"[ProjectionPath(\"{projection.Path}\")]");
        sb.Append($"public sealed record {dtoName}(");

        // Generate constructor parameters from properties
        bool first = true;
        foreach (PropertyModel prop in projection.Model.Properties)
        {
            if (!first)
            {
                sb.Append(", ");
            }

            first = false;
            sb.Append($"{prop.DtoTypeName} {prop.Name}");
        }

        sb.AppendLine(");");

        // Add source
        context.AddSource($"{dtoName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets projection information from the compilation, including referenced assemblies.
    /// </summary>
    private static List<ProjectionInfo> GetProjectionsFromCompilation(
        Compilation compilation
    )
    {
        List<ProjectionInfo> projections = new();

        // Get the attribute symbols
        INamedTypeSymbol? generateAttrSymbol =
            compilation.GetTypeByMetadataName(GenerateProjectionEndpointsAttributeFullName);
        INamedTypeSymbol? projectionPathAttrSymbol = compilation.GetTypeByMetadataName(ProjectionPathAttributeFullName);
        if (generateAttrSymbol is null || projectionPathAttrSymbol is null)
        {
            return projections;
        }

        // Scan all assemblies referenced by this compilation
        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindProjectionsInNamespace(
                referencedAssembly.GlobalNamespace,
                generateAttrSymbol,
                projectionPathAttrSymbol,
                projections);
        }

        return projections;
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        // Include the current assembly
        yield return compilation.Assembly;

        // Include all referenced assemblies
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get projection info from a type symbol.
    /// </summary>
    private static ProjectionInfo? TryGetProjectionInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol,
        INamedTypeSymbol projectionPathAttrSymbol
    )
    {
        // Check for [GenerateProjectionEndpoints] attribute
        bool hasGenerateAttribute = typeSymbol.GetAttributes()
            .Any(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, generateAttrSymbol));
        if (!hasGenerateAttribute)
        {
            return null;
        }

        // Check for [ProjectionPath] attribute and get path
        AttributeData? projectionPathAttr = typeSymbol.GetAttributes()
            .FirstOrDefault(attr =>
                SymbolEqualityComparer.Default.Equals(attr.AttributeClass, projectionPathAttrSymbol));
        if (projectionPathAttr is null)
        {
            return null;
        }

        // Get the path from constructor argument
        string? projectionPath = projectionPathAttr.ConstructorArguments.FirstOrDefault().Value?.ToString();
        if (string.IsNullOrEmpty(projectionPath))
        {
            return null;
        }

        // Build projection model
        ProjectionModel model = new(typeSymbol, projectionPath!);
        return new(typeSymbol.ContainingNamespace.ToDisplayString(), typeSymbol.Name, projectionPath!, model);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Use the compilation provider to scan referenced assemblies
        IncrementalValueProvider<List<ProjectionInfo>> projectionsProvider = context.CompilationProvider.Select((
            compilation,
            _
        ) => GetProjectionsFromCompilation(compilation));

        // Register source output
        context.RegisterSourceOutput(
            projectionsProvider,
            static (
                spc,
                projections
            ) =>
            {
                foreach (ProjectionInfo projection in projections)
                {
                    GenerateClientDto(spc, projection);
                }
            });
    }

    /// <summary>
    ///     Information about a projection type.
    /// </summary>
    private sealed class ProjectionInfo
    {
        public ProjectionInfo(
            string @namespace,
            string typeName,
            string path,
            ProjectionModel model
        )
        {
            Namespace = @namespace;
            TypeName = typeName;
            Path = path;
            Model = model;
        }

        public ProjectionModel Model { get; }

        public string Namespace { get; }

        public string Path { get; }

        public string TypeName { get; }
    }
}