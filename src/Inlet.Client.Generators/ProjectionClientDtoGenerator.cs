using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Analysis;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates client-side DTOs for projections marked with [GenerateProjectionEndpoints].
/// </summary>
/// <remarks>
///     <para>
///         This generator scans referenced assemblies (including Domain projects referenced
///         with ExcludeAssets="runtime") to find projection types and generates matching
///         client-side DTOs with [ProjectionPath] attributes.
///     </para>
///     <para>
///         The ExcludeAssets="runtime" pattern allows the generator to see Domain types at
///         compile time without deploying Orleans-contaminated assemblies to the WASM bundle.
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class ProjectionClientDtoGenerator : IIncrementalGenerator
{
    private const string GenerateProjectionEndpointsAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateProjectionEndpointsAttribute";

    private const string ProjectionPathAttributeFullName =
        "Mississippi.Inlet.Projection.Abstractions.ProjectionPathAttribute";

    /// <summary>
    ///     Recursively finds projections in a namespace.
    /// </summary>
    private static void FindProjectionsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        INamedTypeSymbol projectionPathAttrSymbol,
        List<ProjectionInfo> projections
    )
    {
        // Check types in this namespace
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            ProjectionInfo? info = TryGetProjectionInfo(typeSymbol, generateAttrSymbol, projectionPathAttrSymbol);
            if (info is not null)
            {
                projections.Add(info);
            }
        }

        // Recurse into nested namespaces
        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindProjectionsInNamespace(childNs, generateAttrSymbol, projectionPathAttrSymbol, projections);
        }
    }

    /// <summary>
    ///     Generates the client DTO for a projection.
    /// </summary>
    private static void GenerateClientDto(
        SourceProductionContext context,
        ProjectionInfo projection,
        string targetRootNamespace,
        HashSet<string> generatedNestedTypes
    )
    {
        // Use client namespace convention
        string clientNamespace = NamingConventions.GetClientNamespace(projection.Namespace, targetRootNamespace);
        string dtoName = NamingConventions.GetDtoName(projection.TypeName);
        StringBuilder sb = new();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Immutable;");
        sb.AppendLine();
        sb.AppendLine("using Mississippi.Inlet.Projection.Abstractions;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {clientNamespace};");
        sb.AppendLine();

        // DTO record with ProjectionPath attribute
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"///     Client-side DTO for <see cref=\"{projection.Namespace}.{projection.TypeName}\"/>.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"[ProjectionPath(\"{projection.Path}\")]");
        sb.Append($"public sealed record {dtoName}(");

        // Generate constructor parameters from properties
        bool first = true;
        foreach (PropertyModel prop in projection.Model.Properties)
        {
            if (!first)
            {
                sb.Append(", ");
            }

            first = false;
            sb.Append($"{prop.DtoTypeName} {prop.Name}");
        }

        sb.AppendLine(");");

        // Add source
        context.AddSource($"{dtoName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));

        // Generate DTOs for nested custom types (e.g., collection element types)
        // Use GroupBy to avoid duplicate generation for the same DTO type name
        List<PropertyModel> nestedTypeProperties = projection.Model.Properties
            .Where(prop => prop.ElementTypeSymbol is INamedTypeSymbol &&
                           prop.ElementDtoTypeName is not null &&
                           !generatedNestedTypes.Contains(prop.ElementDtoTypeName!))
            .GroupBy(prop => prop.ElementDtoTypeName)
            .Select(g => g.First())
            .ToList();
        foreach (PropertyModel prop in nestedTypeProperties)
        {
            generatedNestedTypes.Add(prop.ElementDtoTypeName!);
            GenerateNestedTypeDto(
                context,
                (INamedTypeSymbol)prop.ElementTypeSymbol!,
                prop.ElementDtoTypeName!,
                clientNamespace);
        }
    }

    /// <summary>
    ///     Generates a DTO for a nested enum type.
    /// </summary>
    private static void GenerateNestedEnumDto(
        SourceProductionContext context,
        INamedTypeSymbol sourceType,
        string dtoName,
        string targetNamespace
    )
    {
        StringBuilder sb = new();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {targetNamespace};");
        sb.AppendLine();

        // Enum DTO
        sb.AppendLine("/// <summary>");
        sb.AppendLine(
            $"///     Client-side DTO for <see cref=\"{sourceType.ContainingNamespace}.{sourceType.Name}\"/>.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public enum {dtoName}");
        sb.AppendLine("{");

        // Generate enum members
        IEnumerable<IFieldSymbol> enumMembers = sourceType.GetMembers()
            .OfType<IFieldSymbol>()
            .Where(f => f.HasConstantValue);
        foreach (IFieldSymbol member in enumMembers)
        {
            sb.AppendLine($"    /// <summary>{member.Name} value.</summary>");
            sb.AppendLine($"    {member.Name} = {member.ConstantValue},");
            sb.AppendLine();
        }

        sb.AppendLine("}");

        // Add source
        context.AddSource($"{dtoName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Generates a DTO for a nested custom type (e.g., collection element type).
    /// </summary>
    private static void GenerateNestedTypeDto(
        SourceProductionContext context,
        INamedTypeSymbol sourceType,
        string dtoName,
        string targetNamespace
    )
    {
        // If the source is an enum, generate an enum DTO
        if (sourceType.TypeKind == TypeKind.Enum)
        {
            GenerateNestedEnumDto(context, sourceType, dtoName, targetNamespace);
            return;
        }

        StringBuilder sb = new();

        // File header
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Immutable;");
        sb.AppendLine();

        // Namespace
        sb.AppendLine($"namespace {targetNamespace};");
        sb.AppendLine();

        // DTO record
        sb.AppendLine("/// <summary>");
        sb.AppendLine(
            $"///     Client-side DTO for <see cref=\"{sourceType.ContainingNamespace}.{sourceType.Name}\"/>.");
        sb.AppendLine("/// </summary>");
        sb.Append($"public sealed record {dtoName}(");

        // Generate constructor parameters from properties
        IPropertySymbol[] properties = sourceType.GetMembers()
            .OfType<IPropertySymbol>()
            .Where(p => (p.DeclaredAccessibility == Accessibility.Public) && !p.IsStatic && p.GetMethod is not null)
            .ToArray();
        bool first = true;
        foreach (IPropertySymbol prop in properties)
        {
            if (!first)
            {
                sb.Append(", ");
            }

            first = false;
            string propDtoTypeName = TypeAnalyzer.GetDtoTypeName(prop.Type);
            sb.Append($"{propDtoTypeName} {prop.Name}");
        }

        sb.AppendLine(");");

        // Add source
        context.AddSource($"{dtoName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));

        // Check for enum properties that need DTO generation
        IEnumerable<INamedTypeSymbol> enumTypes = properties.Select(p => p.Type)
            .Select(UnwrapNullable)
            .OfType<INamedTypeSymbol>()
            .Where(t => t.TypeKind == TypeKind.Enum);
        foreach (INamedTypeSymbol enumType in enumTypes)
        {
            string enumDtoName = enumType.Name + "Dto";
            GenerateNestedEnumDto(context, enumType, enumDtoName, targetNamespace);
        }
    }

    /// <summary>
    ///     Gets projection information from the compilation, including referenced assemblies.
    /// </summary>
    private static List<ProjectionInfo> GetProjectionsFromCompilation(
        Compilation compilation
    )
    {
        List<ProjectionInfo> projections = new();

        // Get the attribute symbols
        INamedTypeSymbol? generateAttrSymbol =
            compilation.GetTypeByMetadataName(GenerateProjectionEndpointsAttributeFullName);
        INamedTypeSymbol? projectionPathAttrSymbol = compilation.GetTypeByMetadataName(ProjectionPathAttributeFullName);
        if (generateAttrSymbol is null || projectionPathAttrSymbol is null)
        {
            return projections;
        }

        // Scan all assemblies referenced by this compilation
        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindProjectionsInNamespace(
                referencedAssembly.GlobalNamespace,
                generateAttrSymbol,
                projectionPathAttrSymbol,
                projections);
        }

        return projections;
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        // Include the current assembly
        yield return compilation.Assembly;

        // Include all referenced assemblies
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get projection info from a type symbol.
    /// </summary>
    private static ProjectionInfo? TryGetProjectionInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol,
        INamedTypeSymbol projectionPathAttrSymbol
    )
    {
        // Check for [GenerateProjectionEndpoints] attribute
        AttributeData? generateAttr = typeSymbol.GetAttributes()
            .FirstOrDefault(attr => SymbolEqualityComparer.Default.Equals(attr.AttributeClass, generateAttrSymbol));
        if (generateAttr is null)
        {
            return null;
        }

        // Check if client subscription generation is opted out
        if (!TypeAnalyzer.GetBooleanProperty(generateAttr, "GenerateClientSubscription"))
        {
            return null;
        }

        // Check for [ProjectionPath] attribute and get path
        AttributeData? projectionPathAttr = typeSymbol.GetAttributes()
            .FirstOrDefault(attr =>
                SymbolEqualityComparer.Default.Equals(attr.AttributeClass, projectionPathAttrSymbol));
        if (projectionPathAttr is null)
        {
            return null;
        }

        // Get the path from constructor argument
        string? projectionPath = projectionPathAttr.ConstructorArguments.FirstOrDefault().Value?.ToString();
        if (string.IsNullOrEmpty(projectionPath))
        {
            return null;
        }

        // Build projection model
        ProjectionModel model = new(typeSymbol, projectionPath!);
        return new(typeSymbol.ContainingNamespace.ToDisplayString(), typeSymbol.Name, projectionPath!, model);
    }

    /// <summary>
    ///     Unwraps nullable value types to get the underlying type.
    /// </summary>
    /// <param name="typeSymbol">The type symbol to unwrap.</param>
    /// <returns>The underlying type if nullable; otherwise, the original type.</returns>
    private static ITypeSymbol UnwrapNullable(
        ITypeSymbol typeSymbol
    ) =>
        typeSymbol is INamedTypeSymbol { IsValueType: true } namedType &&
        (namedType.OriginalDefinition.SpecialType == SpecialType.System_Nullable_T)
            ? namedType.TypeArguments[0]
            : typeSymbol;

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Combine compilation with options provider
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);

        // Use the compilation provider to scan referenced assemblies
        IncrementalValueProvider<(List<ProjectionInfo> Projections, string TargetRootNamespace)> projectionsProvider =
            compilationAndOptions.Select((
                source,
                _
            ) =>
            {
                List<ProjectionInfo> projections = GetProjectionsFromCompilation(source.Compilation);
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.RootNamespaceProperty,
                    out string? rootNamespace);
                source.Options.GlobalOptions.TryGetValue(
                    TargetNamespaceResolver.AssemblyNameProperty,
                    out string? assemblyName);
                string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                    rootNamespace,
                    assemblyName,
                    source.Compilation);
                return (projections, targetRootNamespace);
            });

        // Register source output
        context.RegisterSourceOutput(
            projectionsProvider,
            static (
                spc,
                data
            ) =>
            {
                HashSet<string> generatedNestedTypes = new();
                foreach (ProjectionInfo projection in data.Projections)
                {
                    GenerateClientDto(spc, projection, data.TargetRootNamespace, generatedNestedTypes);
                }
            });
    }

    /// <summary>
    ///     Information about a projection type.
    /// </summary>
    private sealed class ProjectionInfo
    {
        public ProjectionInfo(
            string @namespace,
            string typeName,
            string path,
            ProjectionModel model
        )
        {
            Namespace = @namespace;
            TypeName = typeName;
            Path = path;
            Model = model;
        }

        public ProjectionModel Model { get; }

        public string Namespace { get; }

        public string Path { get; }

        public string TypeName { get; }
    }
}