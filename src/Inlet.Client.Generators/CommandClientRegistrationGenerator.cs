using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Inlet.Generators.Core.Analysis;
using Mississippi.Inlet.Generators.Core.Emit;
using Mississippi.Inlet.Generators.Core.Naming;


namespace Mississippi.Inlet.Client.Generators;

/// <summary>
///     Generates client-side feature registration classes for commands marked with [GenerateCommand].
/// </summary>
/// <remarks>
///     <para>
///         This generator produces one registration class per aggregate that registers
///         all mappers, reducers, and effects for the aggregate's commands.
///     </para>
///     <para>
///         Example: For commands in "Contoso.Domain.Aggregates.BankAccount.Commands",
///         generates "BankAccountAggregateFeatureRegistration" in "Contoso.Client.Features.BankAccountAggregate".
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class CommandClientRegistrationGenerator : IIncrementalGenerator
{
    private const string GenerateCommandAttributeFullName =
        "Mississippi.Inlet.Generators.Abstractions.GenerateCommandAttribute";

    /// <summary>
    ///     Recursively finds commands in a namespace.
    /// </summary>
    private static void FindCommandsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        List<CommandModel> commands
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            CommandModel? model = TryGetCommandModel(typeSymbol, generateAttrSymbol);
            if (model is not null)
            {
                commands.Add(model);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindCommandsInNamespace(childNs, generateAttrSymbol, commands);
        }
    }

    /// <summary>
    ///     Generates the registration class for an aggregate.
    /// </summary>
    private static void GenerateRegistration(
        SourceProductionContext context,
        AggregateInfo aggregate
    )
    {
        string registrationTypeName = aggregate.AggregateName + "AggregateFeatureRegistration";
        string stateTypeName = aggregate.AggregateName + "AggregateState";
        string reducersTypeName = aggregate.AggregateName + "AggregateReducers";
        string methodName = "Add" + aggregate.AggregateName + "AggregateFeature";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("Microsoft.Extensions.DependencyInjection");
        sb.AppendLine();
        sb.AppendUsing("Mississippi.Common.Abstractions.Mapping");
        sb.AppendUsing("Mississippi.Reservoir");
        sb.AppendLine();
        sb.AppendLine($"using {aggregate.ActionsNamespace};");
        sb.AppendLine($"using {aggregate.DtosNamespace};");
        sb.AppendLine($"using {aggregate.ActionEffectsNamespace};");
        sb.AppendLine($"using {aggregate.MappersNamespace};");
        sb.AppendLine($"using {aggregate.ReducersNamespace};");
        sb.AppendLine($"using {aggregate.StateNamespace};");
        sb.AppendFileScopedNamespace(aggregate.FeatureNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Extension methods for registering the {aggregate.AggregateName}Aggregate feature.");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine(
            $"///     This feature handles the write side (command execution) for the {aggregate.AggregateName} aggregate.");
        sb.AppendLine("/// </remarks>");
        sb.AppendGeneratedCodeAttribute("CommandClientRegistrationGenerator");
        sb.AppendLine($"internal static class {registrationTypeName}");
        sb.OpenBrace();

        // Extension method
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"///     Adds the {aggregate.AggregateName}Aggregate feature to the service collection.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <param name=\"services\">The service collection.</param>");
        sb.AppendLine("/// <returns>The service collection for chaining.</returns>");
        sb.AppendLine($"public static IServiceCollection {methodName}(");
        sb.IncreaseIndent();
        sb.AppendLine("this IServiceCollection services");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.OpenBrace();

        // Mappers section
        sb.AppendLine("// Mappers (Action â†’ DTO)");
        foreach (string commandName in aggregate.CommandNames.OrderBy(n => n))
        {
            sb.AppendLine(
                $"services.AddMapper<{commandName}Action, {commandName}RequestDto, {commandName}ActionMapper>();");
        }

        sb.AppendLine();

        // Command reducers section
        foreach (string commandName in aggregate.CommandNames.OrderBy(n => n))
        {
            sb.AppendLine($"// Reducers - {commandName}");
            sb.AppendLine($"services.AddReducer<{commandName}ExecutingAction, {stateTypeName}>(");
            sb.IncreaseIndent();
            sb.AppendLine($"{reducersTypeName}.{commandName}Executing);");
            sb.DecreaseIndent();
            sb.AppendLine($"services.AddReducer<{commandName}SucceededAction, {stateTypeName}>(");
            sb.IncreaseIndent();
            sb.AppendLine($"{reducersTypeName}.{commandName}Succeeded);");
            sb.DecreaseIndent();
            sb.AppendLine($"services.AddReducer<{commandName}FailedAction, {stateTypeName}>(");
            sb.IncreaseIndent();
            sb.AppendLine($"{reducersTypeName}.{commandName}Failed);");
            sb.DecreaseIndent();
            sb.AppendLine();
        }

        // Action Effects
        sb.AppendLine("// Action Effects");
        foreach (string commandName in aggregate.CommandNames.OrderBy(n => n))
        {
            sb.AppendLine($"services.AddActionEffect<{commandName}ActionEffect>();");
        }

        sb.AppendLine();
        sb.AppendLine("return services;");
        sb.CloseBrace();
        sb.CloseBrace();
        context.AddSource($"{registrationTypeName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets aggregates from command models by grouping on aggregate name.
    /// </summary>
    private static List<AggregateInfo> GetAggregatesFromCommands(
        List<CommandModel> commands,
        string targetRootNamespace
    )
    {
        return commands.Select(c => new
            {
                Command = c,
                AggregateName = NamingConventions.GetAggregateNameFromNamespace(c.Namespace),
            })
            .Where(x => x.AggregateName is not null)
            .GroupBy(x => x.AggregateName!)
            .Select(g =>
            {
                CommandModel firstCommand = g.First().Command;
                string featureNamespace = NamingConventions.GetClientFeatureRootNamespace(
                    firstCommand.Namespace,
                    targetRootNamespace);
                string stateNamespace =
                    NamingConventions.GetClientStateNamespace(firstCommand.Namespace, targetRootNamespace);
                string reducersNamespace =
                    NamingConventions.GetClientReducersNamespace(firstCommand.Namespace, targetRootNamespace);
                string actionsNamespace =
                    NamingConventions.GetClientActionsNamespace(firstCommand.Namespace, targetRootNamespace);
                string actionEffectsNamespace =
                    NamingConventions.GetClientActionEffectsNamespace(firstCommand.Namespace, targetRootNamespace);
                string dtosNamespace = NamingConventions.GetClientCommandDtoNamespace(
                    firstCommand.Namespace,
                    targetRootNamespace);
                string mappersNamespace =
                    NamingConventions.GetClientMappersNamespace(firstCommand.Namespace, targetRootNamespace);
                AggregateInfo aggregate = new(
                    g.Key,
                    featureNamespace,
                    stateNamespace,
                    reducersNamespace,
                    actionsNamespace,
                    actionEffectsNamespace,
                    dtosNamespace,
                    mappersNamespace);
                foreach (CommandModel cmd in g.Select(x => x.Command))
                {
                    aggregate.CommandNames.Add(cmd.TypeName);
                }

                return aggregate;
            })
            .ToList();
    }

    /// <summary>
    ///     Gets command models from the compilation.
    /// </summary>
    private static List<CommandModel> GetCommandsFromCompilation(
        Compilation compilation
    )
    {
        List<CommandModel> commands = new();
        INamedTypeSymbol? generateAttrSymbol = compilation.GetTypeByMetadataName(GenerateCommandAttributeFullName);
        if (generateAttrSymbol is null)
        {
            return commands;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindCommandsInNamespace(referencedAssembly.GlobalNamespace, generateAttrSymbol, commands);
        }

        return commands;
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get command model from a type symbol.
    /// </summary>
    private static CommandModel? TryGetCommandModel(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol
    )
    {
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, generateAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        string? route = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "Route").Value.Value?.ToString();
        if (string.IsNullOrEmpty(route))
        {
            route = NamingConventions.ToKebabCase(typeSymbol.Name);
        }

        string httpMethod =
            attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "HttpMethod").Value.Value?.ToString() ?? "POST";
        return new(typeSymbol, route!, httpMethod);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The incremental generator initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<(Compilation Compilation, AnalyzerConfigOptionsProvider Options)>
            compilationAndOptions = context.CompilationProvider.Combine(context.AnalyzerConfigOptionsProvider);
        IncrementalValueProvider<List<AggregateInfo>> aggregatesProvider = compilationAndOptions.Select((
            source,
            _
        ) =>
        {
            List<CommandModel> commands = GetCommandsFromCompilation(source.Compilation);
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.RootNamespaceProperty,
                out string? rootNamespace);
            source.Options.GlobalOptions.TryGetValue(
                TargetNamespaceResolver.AssemblyNameProperty,
                out string? assemblyName);
            string targetRootNamespace = TargetNamespaceResolver.GetTargetRootNamespace(
                rootNamespace,
                assemblyName,
                source.Compilation);
            return GetAggregatesFromCommands(commands, targetRootNamespace);
        });
        context.RegisterSourceOutput(
            aggregatesProvider,
            static (
                spc,
                aggregates
            ) =>
            {
                foreach (AggregateInfo aggregate in aggregates)
                {
                    GenerateRegistration(spc, aggregate);
                }
            });
    }

    /// <summary>
    ///     Information about an aggregate derived from command namespaces.
    /// </summary>
    private sealed class AggregateInfo
    {
        public AggregateInfo(
            string aggregateName,
            string featureNamespace,
            string stateNamespace,
            string reducersNamespace,
            string actionsNamespace,
            string actionEffectsNamespace,
            string dtosNamespace,
            string mappersNamespace
        )
        {
            AggregateName = aggregateName;
            FeatureNamespace = featureNamespace;
            StateNamespace = stateNamespace;
            ReducersNamespace = reducersNamespace;
            ActionsNamespace = actionsNamespace;
            ActionEffectsNamespace = actionEffectsNamespace;
            DtosNamespace = dtosNamespace;
            MappersNamespace = mappersNamespace;
            CommandNames = new();
        }

        public string ActionEffectsNamespace { get; }

        public string ActionsNamespace { get; }

        public string AggregateName { get; }

        public List<string> CommandNames { get; }

        public string DtosNamespace { get; }

        public string FeatureNamespace { get; }

        public string MappersNamespace { get; }

        public string ReducersNamespace { get; }

        public string StateNamespace { get; }
    }
}