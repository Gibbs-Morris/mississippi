using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Text;
using System.Threading;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

using Mississippi.Ripples.Generators.Models;


namespace Mississippi.Ripples.Generators;

/// <summary>
///     Incremental source generator for Ripples: generates aggregate controllers, route registry, and ripple registrations.
/// </summary>
/// <remarks>
///     Projection controllers are now generated by
///     <c>Mississippi.EventSourcing.UxProjections.Api.Generators.ProjectionApiGenerator</c>
///     using the same <c>[UxProjection]</c> attribute.
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class RipplesGenerator : IIncrementalGenerator
{
    private const string CommandRouteAttributeFullName = "Mississippi.Ripples.Abstractions.CommandRouteAttribute";

    private const string UxAggregateAttributeFullName = "Mississippi.Ripples.Abstractions.UxAggregateAttribute";

    private const string UxProjectionAttributeFullName =
        "Mississippi.EventSourcing.UxProjections.Abstractions.Attributes.UxProjectionAttribute";

    private static AggregateInfo? ExtractAggregateInfo(
        GeneratorAttributeSyntaxContext context,
        CancellationToken ct
    )
    {
        ct.ThrowIfCancellationRequested();
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        AttributeData? attribute = null;
        foreach (AttributeData attr in typeSymbol.GetAttributes())
        {
            if (attr.AttributeClass?.ToDisplayString() == UxAggregateAttributeFullName)
            {
                attribute = attr;
                break;
            }
        }

        if (attribute is null)
        {
            return null;
        }

        // Extract route from constructor argument
        string route = attribute.ConstructorArguments.Length > 0
            ? attribute.ConstructorArguments[0].Value?.ToString() ?? string.Empty
            : string.Empty;

        // Extract authorize from named arguments
        string? authorize = null;
        foreach (KeyValuePair<string, TypedConstant> arg in attribute.NamedArguments)
        {
            if (arg.Key == "Authorize")
            {
                authorize = arg.Value.Value?.ToString();
                break;
            }
        }

        // Extract commands from interface methods
        List<CommandInfo> commands = new();
        foreach (ISymbol member in typeSymbol.GetMembers())
        {
            if (member is not IMethodSymbol methodSymbol || (methodSymbol.MethodKind != MethodKind.Ordinary))
            {
                continue;
            }

            CommandInfo commandInfo = ExtractCommandInfo(methodSymbol);
            commands.Add(commandInfo);
        }

        // Derive aggregate name from interface name
        string interfaceName = typeSymbol.Name;
        string aggregateName = interfaceName;

        // Remove "I" prefix if present
        if (aggregateName.StartsWith("I", StringComparison.Ordinal) &&
            (aggregateName.Length > 1) &&
            char.IsUpper(aggregateName[1]))
        {
            aggregateName = aggregateName.Substring(1);
        }

        // Remove "Grain" suffix if present
        if (aggregateName.EndsWith("Grain", StringComparison.Ordinal))
        {
            aggregateName = aggregateName.Substring(0, aggregateName.Length - 5);
        }

        // Remove "Aggregate" suffix if present (we'll add it back for the controller)
        if (aggregateName.EndsWith("Aggregate", StringComparison.Ordinal))
        {
            aggregateName = aggregateName.Substring(0, aggregateName.Length - 9);
        }

        return new()
        {
            FullTypeName = typeSymbol.ToDisplayString(),
            InterfaceName = interfaceName,
            AggregateName = aggregateName,
            Namespace = typeSymbol.ContainingNamespace.ToDisplayString(),
            Route = route,
            Authorize = authorize,
            Commands = commands.ToArray(),
        };
    }

    private static CommandInfo ExtractCommandInfo(
        IMethodSymbol methodSymbol
    )
    {
        // Check for [CommandRoute] attribute
        string? route = null;
        foreach (AttributeData attr in methodSymbol.GetAttributes())
        {
            if (attr.AttributeClass?.ToDisplayString() == CommandRouteAttributeFullName)
            {
                if (attr.ConstructorArguments.Length > 0)
                {
                    route = attr.ConstructorArguments[0].Value?.ToString();
                }

                break;
            }
        }

        // Default route from method name (remove Async suffix, convert to kebab-case)
        if (route is null)
        {
            string methodName = methodSymbol.Name;
            if (methodName.EndsWith("Async", StringComparison.Ordinal))
            {
                methodName = methodName.Substring(0, methodName.Length - 5);
            }

            route = ToKebabCase(methodName);
        }

        // Extract parameter info
        string? parameterType = null;
        string? parameterName = null;
        if (methodSymbol.Parameters.Length > 0)
        {
            IParameterSymbol firstParam = methodSymbol.Parameters[0];

            // Skip CancellationToken parameters
            if (firstParam.Type.ToDisplayString() != "System.Threading.CancellationToken")
            {
                parameterType = firstParam.Type.ToDisplayString();
                parameterName = firstParam.Name;
            }
        }

        // Extract XML documentation
        string? xmlDoc = methodSymbol.GetDocumentationCommentXml();
        return new()
        {
            MethodName = methodSymbol.Name,
            Route = route,
            ParameterType = parameterType,
            ParameterName = parameterName,
            ReturnType = methodSymbol.ReturnType.ToDisplayString(),
            XmlDocSummary = xmlDoc,
        };
    }

    private static ProjectionInfo? ExtractProjectionInfo(
        GeneratorAttributeSyntaxContext context,
        CancellationToken ct
    )
    {
        ct.ThrowIfCancellationRequested();
        if (context.TargetSymbol is not INamedTypeSymbol typeSymbol)
        {
            return null;
        }

        AttributeData? attribute = null;
        foreach (AttributeData attr in typeSymbol.GetAttributes())
        {
            if (attr.AttributeClass?.ToDisplayString() == UxProjectionAttributeFullName)
            {
                attribute = attr;
                break;
            }
        }

        if (attribute is null)
        {
            return null;
        }

        // Extract route from constructor argument
        string route = attribute.ConstructorArguments.Length > 0
            ? attribute.ConstructorArguments[0].Value?.ToString() ?? string.Empty
            : string.Empty;

        // Extract optional properties
        bool isBatchEnabled = true;
        string? authorize = null;
        string? brookName = null;
        foreach (KeyValuePair<string, TypedConstant> arg in attribute.NamedArguments)
        {
            switch (arg.Key)
            {
                case "IsBatchEnabled":
                    isBatchEnabled = (bool)(arg.Value.Value ?? true);
                    break;
                case "Authorize":
                    authorize = arg.Value.Value?.ToString();
                    break;
                case "BrookName":
                    brookName = arg.Value.Value?.ToString();
                    break;
            }
        }

        return new()
        {
            FullTypeName = typeSymbol.ToDisplayString(),
            TypeName = typeSymbol.Name,
            Namespace = typeSymbol.ContainingNamespace.ToDisplayString(),
            Route = route,
            IsBatchEnabled = isBatchEnabled,
            Authorize = authorize,
            BrookName = brookName,
        };
    }

    private static string GenerateAggregateController(
        AggregateInfo aggregate
    )
    {
        string authorizeAttribute = aggregate.Authorize is not null
            ? $"\n    [Authorize(Policy = \"{aggregate.Authorize}\")]"
            : string.Empty;
        StringBuilder methods = new();
        foreach (CommandInfo command in aggregate.Commands)
        {
            string parameterDeclaration = command.HasParameter
                ? $",\n        [FromBody] {command.ParameterType} {command.ParameterName}"
                : string.Empty;
            string methodCall = command.HasParameter
                ? $"await grain.{command.MethodName}({command.ParameterName})"
                : $"await grain.{command.MethodName}()";
            methods.Append(
                $@"

    /// <summary>
    /// Executes the {RemoveAsyncSuffix(command.MethodName)} command.
    /// </summary>
    [HttpPost(""{command.Route}"")]
    [ProducesResponseType(typeof(OperationResult), StatusCodes.Status200OK)]
    [ProducesResponseType(typeof(OperationResult), StatusCodes.Status400BadRequest)]
    public async Task<ActionResult<OperationResult>> {command.MethodName}(
        [FromRoute] string entityId{parameterDeclaration},
        CancellationToken cancellationToken = default)
    {{
        var grain = ClusterClient.GetGrain<{aggregate.InterfaceName}>(entityId);
        var result = {methodCall};

        return result.IsSuccess
            ? Ok(result)
            : BadRequest(result);
    }}");
        }

        return $@"// <auto-generated/>
#nullable enable

using System;
using System.CodeDom.Compiler;
using System.Threading;
using System.Threading.Tasks;

using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Http;
using Microsoft.AspNetCore.Mvc;
using Microsoft.Extensions.Logging;

using Mississippi.EventSourcing.Aggregates;

using Orleans;

namespace {aggregate.Namespace};

/// <summary>
/// API controller for <see cref=""{aggregate.InterfaceName}""/> commands.
/// </summary>
[GeneratedCode(""Mississippi.Ripples.Generators"", ""1.0.0"")]
[Route(""api/commands/{aggregate.Route}/{{entityId}}"")]{authorizeAttribute}
[ApiController]
public sealed partial class {aggregate.AggregateName}Controller : ControllerBase
{{
    /// <summary>
    /// Gets the Orleans cluster client.
    /// </summary>
    private IClusterClient ClusterClient {{ get; }}

    /// <summary>
    /// Gets the logger.
    /// </summary>
    private ILogger<{aggregate.AggregateName}Controller> Logger {{ get; }}

    /// <summary>
    /// Initializes a new instance of the <see cref=""{aggregate.AggregateName}Controller""/> class.
    /// </summary>
    /// <param name=""clusterClient"">The Orleans cluster client.</param>
    /// <param name=""logger"">The logger instance.</param>
    public {aggregate.AggregateName}Controller(
        IClusterClient clusterClient,
        ILogger<{aggregate.AggregateName}Controller> logger)
    {{
        ClusterClient = clusterClient;
        Logger = logger;
    }}{methods}
}}
";
    }

    private static string GenerateRippleRegistrations(
        ImmutableArray<ProjectionInfo> projections
    )
    {
        StringBuilder registrations = new();
        foreach (ProjectionInfo projection in projections)
        {
            registrations.Append(
                $@"
        // {projection.TypeName}
        if (mode == RippleHostingMode.Server || mode == RippleHostingMode.Auto)
        {{
            services.AddScoped<IRipple<{projection.FullTypeName}>, ServerRipple<{projection.FullTypeName}>>();
            services.AddScoped<IRipplePool<{projection.FullTypeName}>, ServerRipplePool<{projection.FullTypeName}>>();
        }}
        else
        {{
            services.AddScoped<IRipple<{projection.FullTypeName}>, ClientRipple<{projection.FullTypeName}>>();
            services.AddScoped<IRipplePool<{projection.FullTypeName}>, ClientRipplePool<{projection.FullTypeName}>>();
        }}
");
        }

        return $@"// <auto-generated/>
#nullable enable

using System;
using System.CodeDom.Compiler;

using Microsoft.Extensions.DependencyInjection;

using Mississippi.Ripples;
using Mississippi.Ripples.Abstractions;
using Mississippi.Ripples.Client;
using Mississippi.Ripples.Server;

namespace Microsoft.Extensions.DependencyInjection;

/// <summary>
/// Extension methods for registering generated Ripples.
/// </summary>
[GeneratedCode(""Mississippi.Ripples.Generators"", ""1.0.0"")]
public static partial class RippleServiceCollectionExtensions
{{
    /// <summary>
    /// Adds all generated IRipple and IRipplePool registrations.
    /// </summary>
    /// <param name=""services"">The service collection.</param>
    /// <param name=""mode"">The ripple hosting mode.</param>
    /// <returns>The service collection for chaining.</returns>
    public static IServiceCollection AddGeneratedRipples(
        this IServiceCollection services,
        RippleHostingMode mode = RippleHostingMode.Auto)
    {{{registrations}
        return services;
    }}
}}

/// <summary>
/// Determines how Ripples connect to the backend.
/// </summary>
public enum RippleHostingMode
{{
    /// <summary>
    /// Auto-detect based on hosting environment.
    /// </summary>
    Auto,

    /// <summary>
    /// Direct grain access (Blazor Server).
    /// </summary>
    Server,

    /// <summary>
    /// HTTP + SignalR (Blazor WASM).
    /// </summary>
    Client,
}}
";
    }

    private static string GenerateRouteRegistry(
        ImmutableArray<ProjectionInfo> projections,
        ImmutableArray<AggregateInfo> aggregates
    )
    {
        StringBuilder projectionMethods = new();
        foreach (ProjectionInfo projection in projections)
        {
            projectionMethods.Append(
                $@"
        /// <summary>
        /// Gets the route for {projection.TypeName} with the specified entity ID.
        /// </summary>
        public static string {projection.TypeName}(string entityId)
            => $""api/projections/{projection.Route}/{{entityId}}"";
");
            if (projection.IsBatchEnabled)
            {
                projectionMethods.Append(
                    $@"
        /// <summary>
        /// Gets the batch route for {projection.TypeName}.
        /// </summary>
        public static string {projection.TypeName}Batch()
            => ""api/projections/{projection.Route}/batch"";
");
            }
        }

        StringBuilder commandMethods = new();
        foreach (AggregateInfo aggregate in aggregates)
        {
            foreach (CommandInfo command in aggregate.Commands)
            {
                string methodNameWithoutAsync = command.MethodName.EndsWith("Async", StringComparison.Ordinal)
                    ? command.MethodName.Substring(0, command.MethodName.Length - 5)
                    : command.MethodName;
                commandMethods.Append(
                    $@"
        /// <summary>
        /// Gets the route for {aggregate.AggregateName}.{methodNameWithoutAsync} command.
        /// </summary>
        public static string {aggregate.AggregateName}_{methodNameWithoutAsync}(string entityId)
            => $""api/commands/{aggregate.Route}/{{entityId}}/{command.Route}"";
");
            }
        }

        return $@"// <auto-generated/>
#nullable enable

using System;
using System.CodeDom.Compiler;

namespace Mississippi.Ripples;

/// <summary>
/// Registry of all projection and command routes for client-side URL construction.
/// </summary>
[GeneratedCode(""Mississippi.Ripples.Generators"", ""1.0.0"")]
public static partial class RouteRegistry
{{
    /// <summary>
    /// Projection routes.
    /// </summary>
    public static class Projections
    {{{projectionMethods}    }}

    /// <summary>
    /// Command routes.
    /// </summary>
    public static class Commands
    {{{commandMethods}    }}
}}
";
    }

    private static string RemoveAsyncSuffix(
        string methodName
    )
    {
        if (methodName.EndsWith("Async", StringComparison.Ordinal))
        {
            return methodName.Substring(0, methodName.Length - 5);
        }

        return methodName;
    }

    private static string ToKebabCase(
        string input
    )
    {
        if (string.IsNullOrEmpty(input))
        {
            return input;
        }

        StringBuilder sb = new();
        for (int i = 0; i < input.Length; i++)
        {
            char c = input[i];
            if (char.IsUpper(c))
            {
                if (i > 0)
                {
                    sb.Append('-');
                }

                sb.Append(char.ToLowerInvariant(c));
            }
            else
            {
                sb.Append(c);
            }
        }

        return sb.ToString();
    }

    /// <inheritdoc />
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Filter for types with [UxProjection] attribute
        IncrementalValuesProvider<ProjectionInfo> projections = context.SyntaxProvider.ForAttributeWithMetadataName(
                UxProjectionAttributeFullName,
                static (
                    node,
                    _
                ) => node is ClassDeclarationSyntax or RecordDeclarationSyntax,
                static (
                    ctx,
                    ct
                ) => ExtractProjectionInfo(ctx, ct))
            .Where(static info => info is not null)!;

        // Filter for interfaces with [UxAggregate] attribute
        IncrementalValuesProvider<AggregateInfo> aggregates = context.SyntaxProvider.ForAttributeWithMetadataName(
                UxAggregateAttributeFullName,
                static (
                    node,
                    _
                ) => node is InterfaceDeclarationSyntax,
                static (
                    ctx,
                    ct
                ) => ExtractAggregateInfo(ctx, ct))
            .Where(static info => info is not null)!;

        // Collect all projections for route registry generation
        IncrementalValueProvider<ImmutableArray<ProjectionInfo>> allProjections = projections.Collect();
        IncrementalValueProvider<ImmutableArray<AggregateInfo>> allAggregates = aggregates.Collect();

        // Generate aggregate controllers
        context.RegisterSourceOutput(
            aggregates,
            static (
                spc,
                aggregate
            ) =>
            {
                string source = GenerateAggregateController(aggregate);
                spc.AddSource($"{aggregate.AggregateName}Controller.g.cs", source);
            });

        // Combine projections and aggregates for route registry
        IncrementalValueProvider<(ImmutableArray<ProjectionInfo> Projections, ImmutableArray<AggregateInfo> Aggregates)>
            combined = allProjections.Combine(allAggregates);

        // Generate route registry
        context.RegisterSourceOutput(
            combined,
            static (
                spc,
                data
            ) =>
            {
                if ((data.Projections.Length == 0) && (data.Aggregates.Length == 0))
                {
                    return;
                }

                string source = GenerateRouteRegistry(data.Projections, data.Aggregates);
                spc.AddSource("RouteRegistry.g.cs", source);
            });

        // Generate Ripple service registrations
        context.RegisterSourceOutput(
            allProjections,
            static (
                spc,
                projections
            ) =>
            {
                if (projections.Length == 0)
                {
                    return;
                }

                string source = GenerateRippleRegistrations(projections);
                spc.AddSource("RippleServiceCollectionExtensions.g.cs", source);
            });
    }
}