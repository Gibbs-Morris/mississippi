using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Sdk.Generators.Core.Analysis;
using Mississippi.Sdk.Generators.Core.Emit;
using Mississippi.Sdk.Generators.Core.Naming;


namespace Mississippi.Sdk.Client.Generators;

/// <summary>
///     Generates client-side effect classes for commands marked with [GenerateCommand].
/// </summary>
/// <remarks>
///     <para>
///         This generator produces one effect class per command that extends
///         <c>CommandEffectBase</c> with the appropriate type parameters and route configuration.
///     </para>
///     <para>
///         Example: For "DepositFunds" command in "Contoso.Domain.Aggregates.BankAccount.Commands",
///         generates "DepositFundsEffect" in "Contoso.Client.Features.BankAccountAggregate.Effects".
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class CommandClientEffectsGenerator : IIncrementalGenerator
{
    private const string GenerateCommandAttributeFullName =
        "Mississippi.Sdk.Generators.Abstractions.GenerateCommandAttribute";

    /// <summary>
    ///     Recursively finds commands in a namespace.
    /// </summary>
    private static void FindCommandsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        List<CommandModel> commands
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            CommandModel? model = TryGetCommandModel(typeSymbol, generateAttrSymbol);
            if (model is not null)
            {
                commands.Add(model);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindCommandsInNamespace(childNs, generateAttrSymbol, commands);
        }
    }

    /// <summary>
    ///     Generates the effect class for a command.
    /// </summary>
    private static void GenerateEffect(
        SourceProductionContext context,
        CommandModel command
    )
    {
        string commandName = command.TypeName;
        string effectTypeName = commandName + "Effect";
        string effectsNamespace = NamingConventions.GetClientEffectsNamespace(command.Namespace);
        string actionsNamespace = NamingConventions.GetClientActionsNamespace(command.Namespace);
        string dtosNamespace = NamingConventions.GetClientCommandDtoNamespace(command.Namespace);

        // Derive aggregate route prefix from namespace
        string? aggregateName = NamingConventions.GetAggregateNameFromNamespace(command.Namespace);
        if (aggregateName is null)
        {
            return;
        }

        string aggregateRouteSegment = NamingConventions.ToKebabCase(aggregateName);
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Net.Http;");
        sb.AppendLine();
        sb.AppendUsing("Mississippi.Common.Abstractions.Mapping");
        sb.AppendUsing("Mississippi.Inlet.Blazor.WebAssembly.Abstractions.Effects");
        sb.AppendLine();
        sb.AppendLine($"using {actionsNamespace};");
        sb.AppendLine($"using {dtosNamespace};");
        sb.AppendFileScopedNamespace(effectsNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Effect that handles the {commandName} command.");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine("///     <para>");
        sb.AppendLine($"///         This effect posts to the {aggregateRouteSegment} aggregate endpoint");
        sb.AppendLine($"///         at <c>/api/aggregates/{aggregateRouteSegment}/{{entityId}}/{command.Route}</c>.");
        sb.AppendLine("///     </para>");
        sb.AppendLine("/// </remarks>");
        sb.AppendGeneratedCodeAttribute("CommandClientEffectsGenerator");
        sb.AppendLine($"internal sealed class {effectTypeName}");
        sb.IncreaseIndent();
        sb.AppendLine(
            $": CommandEffectBase<{commandName}Action, {commandName}RequestDto, {commandName}ExecutingAction,");
        sb.AppendLine($"    {commandName}SucceededAction, {commandName}FailedAction>");
        sb.DecreaseIndent();
        sb.OpenBrace();

        // Constructor
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"///     Initializes a new instance of the <see cref=\"{effectTypeName}\" /> class.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("/// <param name=\"httpClient\">The HTTP client for API calls.</param>");
        sb.AppendLine("/// <param name=\"mapper\">The mapper for action-to-DTO conversion.</param>");
        sb.AppendLine("/// <param name=\"timeProvider\">The time provider for timestamps.</param>");
        sb.AppendLine($"public {effectTypeName}(");
        sb.IncreaseIndent();
        sb.AppendLine("HttpClient httpClient,");
        sb.AppendLine($"IMapper<{commandName}Action, {commandName}RequestDto> mapper,");
        sb.AppendLine("TimeProvider? timeProvider = null");
        sb.DecreaseIndent();
        sb.AppendLine(")");
        sb.IncreaseIndent();
        sb.AppendLine(": base(httpClient, mapper, timeProvider)");
        sb.DecreaseIndent();
        sb.OpenBrace();
        sb.CloseBrace();
        sb.AppendLine();

        // AggregateRoutePrefix property
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine(
            $"protected override string AggregateRoutePrefix => \"/api/aggregates/{aggregateRouteSegment}\";");
        sb.AppendLine();

        // Route property
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"protected override string Route => \"{command.Route}\";");
        sb.CloseBrace();
        context.AddSource($"{effectTypeName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets command models from the compilation.
    /// </summary>
    private static List<CommandModel> GetCommandsFromCompilation(
        Compilation compilation
    )
    {
        List<CommandModel> commands = new();
        INamedTypeSymbol? generateAttrSymbol = compilation.GetTypeByMetadataName(GenerateCommandAttributeFullName);
        if (generateAttrSymbol is null)
        {
            return commands;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindCommandsInNamespace(referencedAssembly.GlobalNamespace, generateAttrSymbol, commands);
        }

        return commands;
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get command model from a type symbol.
    /// </summary>
    private static CommandModel? TryGetCommandModel(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol
    )
    {
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, generateAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        string? route = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "Route").Value.Value?.ToString();
        if (string.IsNullOrEmpty(route))
        {
            route = NamingConventions.ToKebabCase(typeSymbol.Name);
        }

        string httpMethod =
            attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "HttpMethod").Value.Value?.ToString() ?? "POST";
        return new(typeSymbol, route!, httpMethod);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The incremental generator initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<List<CommandModel>> commandsProvider = context.CompilationProvider.Select((
            compilation,
            _
        ) => GetCommandsFromCompilation(compilation));
        context.RegisterSourceOutput(
            commandsProvider,
            static (
                spc,
                commands
            ) =>
            {
                foreach (CommandModel command in commands)
                {
                    GenerateEffect(spc, command);
                }
            });
    }
}