using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Sdk.Generators.Core.Analysis;
using Mississippi.Sdk.Generators.Core.Emit;
using Mississippi.Sdk.Generators.Core.Naming;


namespace Mississippi.Sdk.Client.Generators;

/// <summary>
///     Generates client-side request DTOs for commands marked with [GenerateCommand].
/// </summary>
/// <remarks>
///     <para>
///         This generator scans referenced assemblies (including Domain projects referenced
///         with ExcludeAssets="runtime") to find command types and generates matching
///         client-side request DTOs as internal sealed records.
///     </para>
///     <para>
///         The ExcludeAssets="runtime" pattern allows the generator to see Domain types at
///         compile time without deploying Orleans-contaminated assemblies to the WASM bundle.
///     </para>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class CommandClientDtoGenerator : IIncrementalGenerator
{
    private const string GenerateCommandAttributeFullName =
        "Mississippi.Sdk.Generators.Abstractions.GenerateCommandAttribute";

    /// <summary>
    ///     Recursively finds commands in a namespace.
    /// </summary>
    private static void FindCommandsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        List<CommandInfo> commands
    )
    {
        // Check types in this namespace
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            CommandInfo? info = TryGetCommandInfo(typeSymbol, generateAttrSymbol);
            if (info is not null)
            {
                commands.Add(info);
            }
        }

        // Recurse into nested namespaces
        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindCommandsInNamespace(childNs, generateAttrSymbol, commands);
        }
    }

    /// <summary>
    ///     Generates the client request DTO for a command.
    /// </summary>
    private static void GenerateClientDto(
        SourceProductionContext context,
        CommandInfo command
    )
    {
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendFileScopedNamespace(command.OutputNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Request DTO for the {command.Model.TypeName} command.");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine(
            $"///     Mirrors server DTO: <c>{NamingConventions.GetServerCommandDtoNamespace(command.Model.Namespace)}.{command.Model.DtoTypeName}</c>.");
        sb.AppendLine("/// </remarks>");

        // Build parameter documentation using LINQ to satisfy S3267
        command.Model.Properties.ToList()
            .ForEach(prop => sb.AppendLine(
                $"/// <param name=\"{prop.Name}\">The {NamingConventions.ToCamelCase(prop.Name)} value.</param>"));
        sb.AppendGeneratedCodeAttribute("CommandClientDtoGenerator");

        // Build the positional record - internal sealed
        // Use string.Join to build parameter list in a LINQ-friendly way
        string parameters = string.Join(", ", command.Model.Properties.Select(p => $"{p.SourceTypeName} {p.Name}"));
        sb.AppendLine($"internal sealed record {command.RequestDtoTypeName}({parameters});");

        // Add source
        context.AddSource($"{command.RequestDtoTypeName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets command information from the compilation, including referenced assemblies.
    /// </summary>
    private static List<CommandInfo> GetCommandsFromCompilation(
        Compilation compilation
    )
    {
        List<CommandInfo> commands = new();

        // Get the attribute symbol
        INamedTypeSymbol? generateAttrSymbol = compilation.GetTypeByMetadataName(GenerateCommandAttributeFullName);
        if (generateAttrSymbol is null)
        {
            return commands;
        }

        // Scan all assemblies referenced by this compilation
        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindCommandsInNamespace(referencedAssembly.GlobalNamespace, generateAttrSymbol, commands);
        }

        return commands;
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        // Include the current assembly
        yield return compilation.Assembly;

        // Include all referenced assemblies
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get command info from a type symbol.
    /// </summary>
    private static CommandInfo? TryGetCommandInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol
    )
    {
        // Check for [GenerateCommand] attribute
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, generateAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        // Get Route from named argument, fallback to kebab-case of type name
        string? route = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "Route").Value.Value?.ToString();
        if (string.IsNullOrEmpty(route))
        {
            route = NamingConventions.ToKebabCase(typeSymbol.Name);
        }

        // Get HttpMethod from named argument, default to POST
        string httpMethod =
            attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "HttpMethod").Value.Value?.ToString() ?? "POST";

        // Build command model
        CommandModel model = new(typeSymbol, route!, httpMethod);
        string outputNamespace = NamingConventions.GetClientCommandDtoNamespace(model.Namespace);
        string requestDtoTypeName = NamingConventions.GetCommandRequestDtoName(model.TypeName);
        return new(model, outputNamespace, requestDtoTypeName);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        // Use the compilation provider to scan referenced assemblies
        IncrementalValueProvider<List<CommandInfo>> commandsProvider = context.CompilationProvider.Select((
            compilation,
            _
        ) => GetCommandsFromCompilation(compilation));

        // Register source output
        context.RegisterSourceOutput(
            commandsProvider,
            static (
                spc,
                commands
            ) =>
            {
                foreach (CommandInfo command in commands)
                {
                    GenerateClientDto(spc, command);
                }
            });
    }

    /// <summary>
    ///     Information about a command type.
    /// </summary>
    private sealed class CommandInfo
    {
        public CommandInfo(
            CommandModel model,
            string outputNamespace,
            string requestDtoTypeName
        )
        {
            Model = model;
            OutputNamespace = outputNamespace;
            RequestDtoTypeName = requestDtoTypeName;
        }

        public CommandModel Model { get; }

        public string OutputNamespace { get; }

        public string RequestDtoTypeName { get; }
    }
}