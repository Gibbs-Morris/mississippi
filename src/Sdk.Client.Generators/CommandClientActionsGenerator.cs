using System.Collections.Generic;
using System.Linq;
using System.Text;

using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.Text;

using Mississippi.Sdk.Generators.Core.Analysis;
using Mississippi.Sdk.Generators.Core.Emit;
using Mississippi.Sdk.Generators.Core.Naming;


namespace Mississippi.Sdk.Client.Generators;

/// <summary>
///     Generates client-side Flux actions for commands marked with [GenerateCommand].
/// </summary>
/// <remarks>
///     <para>
///         This generator produces four action types per command:
///     </para>
///     <list type="bullet">
///         <item>{Command}Action - The primary action with EntityId + command properties.</item>
///         <item>{Command}ExecutingAction - Dispatched when command starts executing.</item>
///         <item>{Command}SucceededAction - Dispatched when command completes successfully.</item>
///         <item>{Command}FailedAction - Dispatched when command fails.</item>
///     </list>
/// </remarks>
[Generator(LanguageNames.CSharp)]
public sealed class CommandClientActionsGenerator : IIncrementalGenerator
{
    private const string GenerateCommandAttributeFullName =
        "Mississippi.Sdk.Generators.Abstractions.GenerateCommandAttribute";

    /// <summary>
    ///     Recursively finds commands in a namespace.
    /// </summary>
    private static void FindCommandsInNamespace(
        INamespaceSymbol namespaceSymbol,
        INamedTypeSymbol generateAttrSymbol,
        List<CommandInfo> commands
    )
    {
        foreach (INamedTypeSymbol typeSymbol in namespaceSymbol.GetTypeMembers())
        {
            CommandInfo? info = TryGetCommandInfo(typeSymbol, generateAttrSymbol);
            if (info is not null)
            {
                commands.Add(info);
            }
        }

        foreach (INamespaceSymbol childNs in namespaceSymbol.GetNamespaceMembers())
        {
            FindCommandsInNamespace(childNs, generateAttrSymbol, commands);
        }
    }

    /// <summary>
    ///     Generates all action types for a command.
    /// </summary>
    private static void GenerateActions(
        SourceProductionContext context,
        CommandInfo command
    )
    {
        // Generate primary action
        GeneratePrimaryAction(context, command);

        // Generate executing action
        GenerateExecutingAction(context, command);

        // Generate succeeded action
        GenerateSucceededAction(context, command);

        // Generate failed action
        GenerateFailedAction(context, command);
    }

    /// <summary>
    ///     Generates the executing action ({Command}ExecutingAction).
    /// </summary>
    private static void GenerateExecutingAction(
        SourceProductionContext context,
        CommandInfo command
    )
    {
        string actionName = command.Model.TypeName + "ExecutingAction";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("Mississippi.Inlet.Blazor.WebAssembly.Abstractions.Actions");
        sb.AppendFileScopedNamespace(command.ActionsNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Action dispatched when a {command.Model.TypeName} command starts executing.");
        sb.AppendLine("/// <param name=\"CommandId\">The unique command invocation identifier.</param>");
        sb.AppendLine("/// <param name=\"CommandType\">The name of the command type.</param>");
        sb.AppendLine("/// <param name=\"Timestamp\">The timestamp when the command started.</param>");
        sb.AppendGeneratedCodeAttribute("CommandClientActionsGenerator");
        sb.AppendLine(
            $"internal sealed record {actionName}(string CommandId, string CommandType, DateTimeOffset Timestamp)");
        sb.IncreaseIndent();
        sb.AppendLine($": ICommandExecutingAction<{actionName}>");
        sb.DecreaseIndent();
        sb.OpenBrace();
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public static {actionName} Create(");
        sb.IncreaseIndent();
        sb.AppendLine("string commandId,");
        sb.AppendLine("string commandType,");
        sb.AppendLine("DateTimeOffset timestamp");
        sb.DecreaseIndent();
        sb.AppendLine(") =>");
        sb.IncreaseIndent();
        sb.AppendLine("new(commandId, commandType, timestamp);");
        sb.DecreaseIndent();
        sb.CloseBrace();
        context.AddSource($"{actionName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Generates the failed action ({Command}FailedAction).
    /// </summary>
    private static void GenerateFailedAction(
        SourceProductionContext context,
        CommandInfo command
    )
    {
        string actionName = command.Model.TypeName + "FailedAction";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("Mississippi.Inlet.Blazor.WebAssembly.Abstractions.Actions");
        sb.AppendFileScopedNamespace(command.ActionsNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Action dispatched when a {command.Model.TypeName} command fails.");
        sb.AppendLine("/// <param name=\"CommandId\">The unique command invocation identifier.</param>");
        sb.AppendLine("/// <param name=\"ErrorCode\">The error code.</param>");
        sb.AppendLine("/// <param name=\"ErrorMessage\">The error message.</param>");
        sb.AppendLine("/// <param name=\"Timestamp\">The timestamp when the command failed.</param>");
        sb.AppendGeneratedCodeAttribute("CommandClientActionsGenerator");
        sb.AppendLine($"internal sealed record {actionName}(");
        sb.IncreaseIndent();
        sb.AppendLine("string CommandId,");
        sb.AppendLine("string? ErrorCode,");
        sb.AppendLine("string? ErrorMessage,");
        sb.AppendLine("DateTimeOffset Timestamp");
        sb.DecreaseIndent();
        sb.AppendLine($") : ICommandFailedAction<{actionName}>");
        sb.OpenBrace();
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public static {actionName} Create(");
        sb.IncreaseIndent();
        sb.AppendLine("string commandId,");
        sb.AppendLine("string? errorCode,");
        sb.AppendLine("string? errorMessage,");
        sb.AppendLine("DateTimeOffset timestamp");
        sb.DecreaseIndent();
        sb.AppendLine(") =>");
        sb.IncreaseIndent();
        sb.AppendLine("new(commandId, errorCode, errorMessage, timestamp);");
        sb.DecreaseIndent();
        sb.CloseBrace();
        context.AddSource($"{actionName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Generates the primary action ({Command}Action).
    /// </summary>
    private static void GeneratePrimaryAction(
        SourceProductionContext context,
        CommandInfo command
    )
    {
        string actionName = command.Model.TypeName + "Action";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("Mississippi.Inlet.Blazor.WebAssembly.Abstractions.Actions");
        sb.AppendFileScopedNamespace(command.ActionsNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Action dispatched to execute the {command.Model.TypeName} command.");
        sb.AppendLine("/// <remarks>");
        sb.AppendLine($"///     Derived from domain command: <c>{command.Model.FullTypeName}</c>.");
        sb.AppendLine("/// </remarks>");
        sb.AppendLine("/// <param name=\"EntityId\">The target entity ID.</param>");

        // Add param docs for command properties
        command.Model.Properties.ToList()
            .ForEach(prop => sb.AppendLine(
                $"/// <param name=\"{prop.Name}\">The {NamingConventions.ToCamelCase(prop.Name)} value.</param>"));
        sb.AppendGeneratedCodeAttribute("CommandClientActionsGenerator");

        // Build parameters: EntityId + command properties
        string parameters = "string EntityId";
        if (command.Model.Properties.Length > 0)
        {
            string propParams = string.Join(", ", command.Model.Properties.Select(p => $"{p.SourceTypeName} {p.Name}"));
            parameters += ", " + propParams;
        }

        sb.AppendLine($"internal sealed record {actionName}({parameters}) : ICommandAction;");
        context.AddSource($"{actionName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Generates the succeeded action ({Command}SucceededAction).
    /// </summary>
    private static void GenerateSucceededAction(
        SourceProductionContext context,
        CommandInfo command
    )
    {
        string actionName = command.Model.TypeName + "SucceededAction";
        SourceBuilder sb = new();
        sb.AppendAutoGeneratedHeader();
        sb.AppendUsing("System");
        sb.AppendUsing("Mississippi.Inlet.Blazor.WebAssembly.Abstractions.Actions");
        sb.AppendFileScopedNamespace(command.ActionsNamespace);
        sb.AppendLine();
        sb.AppendSummary($"Action dispatched when a {command.Model.TypeName} command completes successfully.");
        sb.AppendLine("/// <param name=\"CommandId\">The unique command invocation identifier.</param>");
        sb.AppendLine("/// <param name=\"Timestamp\">The timestamp when the command completed.</param>");
        sb.AppendGeneratedCodeAttribute("CommandClientActionsGenerator");
        sb.AppendLine($"internal sealed record {actionName}(string CommandId, DateTimeOffset Timestamp)");
        sb.IncreaseIndent();
        sb.AppendLine($": ICommandSucceededAction<{actionName}>");
        sb.DecreaseIndent();
        sb.OpenBrace();
        sb.AppendLine("/// <inheritdoc />");
        sb.AppendLine($"public static {actionName} Create(");
        sb.IncreaseIndent();
        sb.AppendLine("string commandId,");
        sb.AppendLine("DateTimeOffset timestamp");
        sb.DecreaseIndent();
        sb.AppendLine(") =>");
        sb.IncreaseIndent();
        sb.AppendLine("new(commandId, timestamp);");
        sb.DecreaseIndent();
        sb.CloseBrace();
        context.AddSource($"{actionName}.g.cs", SourceText.From(sb.ToString(), Encoding.UTF8));
    }

    /// <summary>
    ///     Gets command information from the compilation.
    /// </summary>
    private static List<CommandInfo> GetCommandsFromCompilation(
        Compilation compilation
    )
    {
        List<CommandInfo> commands = new();
        INamedTypeSymbol? generateAttrSymbol = compilation.GetTypeByMetadataName(GenerateCommandAttributeFullName);
        if (generateAttrSymbol is null)
        {
            return commands;
        }

        foreach (IAssemblySymbol referencedAssembly in GetReferencedAssemblies(compilation))
        {
            FindCommandsInNamespace(referencedAssembly.GlobalNamespace, generateAttrSymbol, commands);
        }

        return commands;
    }

    /// <summary>
    ///     Gets all referenced assemblies from the compilation.
    /// </summary>
    private static IEnumerable<IAssemblySymbol> GetReferencedAssemblies(
        Compilation compilation
    )
    {
        yield return compilation.Assembly;
        foreach (MetadataReference reference in compilation.References)
        {
            if (compilation.GetAssemblyOrModuleSymbol(reference) is IAssemblySymbol assemblySymbol)
            {
                yield return assemblySymbol;
            }
        }
    }

    /// <summary>
    ///     Tries to get command info from a type symbol.
    /// </summary>
    private static CommandInfo? TryGetCommandInfo(
        INamedTypeSymbol typeSymbol,
        INamedTypeSymbol generateAttrSymbol
    )
    {
        AttributeData? attr = typeSymbol.GetAttributes()
            .FirstOrDefault(a => SymbolEqualityComparer.Default.Equals(a.AttributeClass, generateAttrSymbol));
        if (attr is null)
        {
            return null;
        }

        string? route = attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "Route").Value.Value?.ToString();
        if (string.IsNullOrEmpty(route))
        {
            route = NamingConventions.ToKebabCase(typeSymbol.Name);
        }

        string httpMethod =
            attr.NamedArguments.FirstOrDefault(kvp => kvp.Key == "HttpMethod").Value.Value?.ToString() ?? "POST";
        CommandModel model = new(typeSymbol, route!, httpMethod);
        string actionsNamespace = NamingConventions.GetClientActionsNamespace(model.Namespace);
        string dtosNamespace = NamingConventions.GetClientCommandDtoNamespace(model.Namespace);
        return new(model, actionsNamespace, dtosNamespace);
    }

    /// <summary>
    ///     Initializes the generator pipeline.
    /// </summary>
    /// <param name="context">The incremental generator initialization context.</param>
    public void Initialize(
        IncrementalGeneratorInitializationContext context
    )
    {
        IncrementalValueProvider<List<CommandInfo>> commandsProvider = context.CompilationProvider.Select((
            compilation,
            _
        ) => GetCommandsFromCompilation(compilation));
        context.RegisterSourceOutput(
            commandsProvider,
            static (
                spc,
                commands
            ) =>
            {
                // Generate per-command actions
                foreach (CommandInfo command in commands)
                {
                    GenerateActions(spc, command);
                }
            });
    }

    /// <summary>
    ///     Information about a command type.
    /// </summary>
    private sealed class CommandInfo
    {
        public CommandInfo(
            CommandModel model,
            string actionsNamespace,
            string dtosNamespace
        )
        {
            Model = model;
            ActionsNamespace = actionsNamespace;
            DtosNamespace = dtosNamespace;
        }

        public string ActionsNamespace { get; }

        public string DtosNamespace { get; }

        public CommandModel Model { get; }
    }
}